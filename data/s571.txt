<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>
<a href="#approach-4-using-hashmapaccepted">Approach #4 Using HashMap[Accepted]:</a></li>
<a href="#approach-5-in-single-loop-accepted">Approach #5 In single loop [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
In the brute force solution, we consider every possible subsequence that can be formed using the elements of the given array. For every subsequence, we find the maximum and minimum values in the subsequence. If the difference between the maximum and the minimum values obtained is 1, it means the current subsequence forms a harmonious subsequence. Thus, we can consider the number of elements in this subsequence to be compared with the length of the last longest harmonious subsequence. </p>
In order to obtain all the subseqeuences possible, we make use of binary number representation of decimal numbers. For a binary number of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, a total of <span class="maths katex-rendered">2</mn>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.664392em;"></span><span class="strut bottom" style="height: 0.664392em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> different binary numbers can be generated. We generate all these binary numbers from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">2</mn>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.664392em;"></span><span class="strut bottom" style="height: 0.664392em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>. For every binary number generated, we consider the subsequence to be comprised of only those elements of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> which have a 1 at the corresponding position in the current binary number. The following figure shows an example of the way the elements of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> are considered in the current subsequence.</p>
<img alt="Harmonic_Subsequence" src="../Figures/594_Harmonic_Subsequence_Binary.PNG"></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findLHS</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> res</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> (</span>1</span> &lt;&lt;</span> nums</span>.</span>length</span>);</span> i</span>++)</span> {</span>
            int</span> count</span> =</span> 0</span>,</span> min</span> =</span> Integer</span>.</span>MAX_VALUE</span>,</span> max</span> =</span> Integer</span>.</span>MIN_VALUE</span>;</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> nums</span>.</span>length</span>;</span> j</span>++)</span> {</span>
                if</span> ((</span>i</span> &amp;</span> (</span>1</span> &lt;&lt;</span> j</span>))</span> !=</span> 0</span>)</span> {</span>
                    min</span> =</span> Math</span>.</span>min</span>(</span>min</span>,</span> nums</span>[</span>j</span>]);</span>
                    max</span> =</span> Math</span>.</span>max</span>(</span>max</span>,</span> nums</span>[</span>j</span>]);</span>
                    count</span>++;</span>
                }</span>
            }</span>
            if</span> (</span>max</span> -</span> min</span> ==</span> 1</span>)</span>
                res</span> =</span> Math</span>.</span>max</span>(</span>res</span>,</span> count</span>);</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>2</mn>n</mi></msup>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Number of subsequences generated will be <span class="maths katex-rendered">2</mn>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.664392em;"></span><span class="strut bottom" style="height: 0.664392em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space required.</p>
</li>
</ul>

<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
In the last approach, we created every possible subsequence, and for every such subsequence, we found out if it satisfies the harmonicity condition. Instead of doing this, we can do as follows. We can consider every element of the given <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array one by one. For <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> chosen to be the current element, we determine the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> of all the elements in the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array, which satisfy the harmonicity condition with <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, i.e. the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> of all such <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> satisfying <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>=</mo>=</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i] == nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span>=</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> or <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>=</mo>=</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">nums[i] == nums[j] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span>=</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>. When we reach the end of the array for <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> being the current element, we compare this <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> obtained with the result obtained from the previous traversals and update the result appropriately. When all the elements of the array have been chosen as the element to be chosen as the base for harmonicity check, we get the required length of the longest harmonic subsequence.</p>
The following animation illustrates the process:</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 18</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findLHS</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> res</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            int</span> count</span> =</span> 0</span>;</span>
            boolean</span> flag</span> =</span> false</span>;</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> nums</span>.</span>length</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>nums</span>[</span>j</span>]</span> ==</span> nums</span>[</span>i</span>])</span>
                    count</span>++;</span>
                else</span> if</span> (</span>nums</span>[</span>j</span>]</span> +</span> 1</span> ==</span> nums</span>[</span>i</span>])</span> {</span>
                    count</span>++;</span>
                    flag</span> =</span> true</span>;</span>
                }</span>
            }</span>
            if</span> (</span>flag</span>)</span>
                res</span> =</span> Math</span>.</span>max</span>(</span>count</span>,</span> res</span>);</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Two nested loops are there.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space required.</p>
</li>
</ul>

<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>
Algorithm</strong></p>
Since we are concerned only with the count of elements which are at a difference of 1, we can use sorting to our advantage. If we sort the given <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array, the related elements will get arranged close to each other. Thus, we can traverse over the sorted array, and find the count of similar elements and elements one larger than the current ones, which occur consecutively(all the similar elements will be lying consecutively now). Initially, this value is stored in <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi>_</mi>c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">prev_count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.92508em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> variable. Then, if we encounter an element which is just 1 larger than the last elements, we count the occurences of such elements as well. This value is stored in <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> variable. </p>
Thus, now for the harmonic subsequence comprised of only these two elements is a subsequence of length <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>+</mo>p</mi>r</mi>e</mi>v</mi>_</mi>c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count + prev_count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.92508em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>+</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span>. This result is stored in <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> for each subsequence found. When we move forward to considering the next set of similar consecutive elements, we need to update the <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi>_</mi>c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">prev_count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.92508em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> with the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span>'s value, since now <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> will act as the count of the elements 1 lesser than the next elements encountered. The value of <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> is always updated to be the larger of previous <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> and the current <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>+</mo>p</mi>r</mi>e</mi>v</mi>_</mi>c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count + prev_count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.92508em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>+</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> value.</p>
When we are done traversing over the whole array, the value of <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> gives us the required result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findLHS</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        Arrays</span>.</span>sort</span>(</span>nums</span>);</span>
        int</span> prev_count</span> =</span> 1</span>,</span> res</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            int</span> count</span> =</span> 1</span>;</span>
            if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> nums</span>[</span>i</span>]</span> -</span> nums</span>[</span>i</span> -</span> 1</span>]</span> ==</span> 1</span>)</span> {</span>
                while</span> (</span>i</span> &lt;</span> nums</span>.</span>length</span> -</span> 1</span> &amp;&amp;</span> nums</span>[</span>i</span>]</span> ==</span> nums</span>[</span>i</span> +</span> 1</span>])</span> {</span>
                    count</span>++;</span>
                    i</span>++;</span>
                }</span>
                res</span> =</span> Math</span>.</span>max</span>(</span>res</span>,</span> count</span> +</span> prev_count</span>);</span>
                prev_count</span> =</span> count</span>;</span>
            }</span> else</span> {</span>
                while</span> (</span>i</span> &lt;</span> nums</span>.</span>length</span> -</span> 1</span> &amp;&amp;</span> nums</span>[</span>i</span>]</span> ==</span> nums</span>[</span>i</span> +</span> 1</span>])</span> {</span>
                    count</span>++;</span>
                    i</span>++;</span>
                }</span>
                prev_count</span> =</span> count</span>;</span>
            }</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Sorting takes <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span>)</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">l</mi>o</mi>g</mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span></span></span></span></span> space is required by sorting in average case.</p>
</li>
</ul>

<h4 id="approach-4-using-hashmapaccepted">Approach #4 Using HashMap[Accepted]:</h4>
Algorithm</strong></p>
In this approach, we make use of a hashmap <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> which stores the number of times an element occurs in the array along with the element's value in the form <span class="maths katex-rendered">(</mo>n</mi>u</mi>m</mi>:</mo>c</mi>o</mi>u</mi>n</mi>t</mi>_</mi>n</mi>u</mi>m</mi>)</mo></mrow><annotation encoding="application/x-tex">(num: count_num)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.06em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span>:</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> refers to an element in the array and <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>_</mi>n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">count_num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.92508em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> refers to the number of times this <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> occurs in the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array. We traverse over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array and fill this <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> once.</p>
After this, we traverse over the keys of the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> created. For every key of the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> considered, say <span class="maths katex-rendered">k</mi>e</mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span>, we find out if the map contains the <span class="maths katex-rendered">k</mi>e</mi>y</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">key + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>+</span><span class="mord mathrm">1</span></span></span></span></span>. Such an element is found, since only such elements can be counted for the harmonic subsequence if <span class="maths katex-rendered">k</mi>e</mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> is considered as one of the element of the harmonic subsequence. We need not care about <span class="maths katex-rendered">k</mi>e</mi>y</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">key - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span></span></span></span></span>, because if <span class="maths katex-rendered">k</mi>e</mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> is present in the harmonic subsequence, at one time either <span class="maths katex-rendered">k</mi>e</mi>y</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">key + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>+</span><span class="mord mathrm">1</span></span></span></span></span> or <span class="maths katex-rendered">k</mi>e</mi>y</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">key - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span></span></span></span></span> only could be included in the harmonic subsequence. The case of <span class="maths katex-rendered">k</mi>e</mi>y</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">key - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span></span></span></span></span> being in the harmonic subsequence will automatically be considered, when <span class="maths katex-rendered">k</mi>e</mi>y</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">key - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span></span></span></span></span> is encountered as the current key. </p>
Now, whenver we find that <span class="maths katex-rendered">k</mi>e</mi>y</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">key + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>+</span><span class="mord mathrm">1</span></span></span></span></span> exists in the keys of <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span>, we determine the count of the current harmonic subsequence as <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>k</mi>e</mi>y</mi></mrow></msub>+</mo>c</mi>o</mi>u</mi>n</mi>t</mi>k</mi>e</mi>y</mi>+</mo>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">count_{key} + count_{key+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.901188em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>+</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, where <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>i</mi></msub></mrow><annotation encoding="application/x-tex">count_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.76508em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> refers to the value corresponding to the key <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> in <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span>, which reprents the number of times <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> occurs in the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>.</p>
Look at the animation below for a pictorial view of the process:</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 15</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findLHS</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        HashMap</span> &lt;</span> Integer</span>,</span> Integer</span> &gt;</span> map</span> =</span> new</span> HashMap</span> &lt;</span> &gt;</span> ();</span>
        int</span> res</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> num</span>:</span> nums</span>)</span> {</span>
            map</span>.</span>put</span>(</span>num</span>,</span> map</span>.</span>getOrDefault</span>(</span>num</span>,</span> 0</span>)</span> +</span> 1</span>);</span>
        }</span>
        for</span> (</span>int</span> key</span>:</span> map</span>.</span>keySet</span>())</span> {</span>
            if</span> (</span>map</span>.</span>containsKey</span>(</span>key</span> +</span> 1</span>))</span>
                res</span> =</span> Math</span>.</span>max</span>(</span>res</span>,</span> map</span>.</span>get</span>(</span>key</span>)</span> +</span> map</span>.</span>get</span>(</span>key</span> +</span> 1</span>));</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. One loop is required to fill <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> and one for traversing the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. In worst case map size grows upto size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-5-in-single-loop-accepted">Approach #5 In single loop [Accepted]:</h4>
Algorithm</strong></p>
Instead of filling the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> first and then traversing over the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> to determine the lengths of the harmonic subsequences encountered, we can traverse over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array, and while doing the traversals, we can determine the lengths of the harmonic subsequences possible till the current index of the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array. </p>
The method of finding the length of harmonic subsequence remains the same as the last approach. But, this time, we need to consider the existence of both <span class="maths katex-rendered">k</mi>e</mi>y</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">key + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>+</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">k</mi>e</mi>y</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">key - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span></span></span></span></span> exclusively and determine the counts corresponding to both the cases. This is needed now because it could be possible that <span class="maths katex-rendered">k</mi>e</mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> has already been added to the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> and later on <span class="maths katex-rendered">k</mi>e</mi>y</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">key - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span></span></span></span></span> is encountered. In this case, if we consider the presence of <span class="maths katex-rendered">k</mi>e</mi>y</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">key + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>+</span><span class="mord mathrm">1</span></span></span></span></span> only, we'll go in the wrong direction.</p>
Thus, we consider the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span>s corresponding to both the cases separately for every <span class="maths katex-rendered">k</mi>e</mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> and determine the maximum out of them. 
Thus, now the same task can be done only in a single traveral of the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
See the animation below for understanding the process:</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 10</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findLHS</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        HashMap</span> &lt;</span> Integer</span>,</span> Integer</span> &gt;</span> map</span> =</span> new</span> HashMap</span> &lt;</span> &gt;</span> ();</span>
        int</span> res</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> num</span>:</span> nums</span>)</span> {</span>
            map</span>.</span>put</span>(</span>num</span>,</span> map</span>.</span>getOrDefault</span>(</span>num</span>,</span> 0</span>)</span> +</span> 1</span>);</span>
            if</span> (</span>map</span>.</span>containsKey</span>(</span>num</span> +</span> 1</span>))</span>
                res</span> =</span> Math</span>.</span>max</span>(</span>res</span>,</span> map</span>.</span>get</span>(</span>num</span>)</span> +</span> map</span>.</span>get</span>(</span>num</span> +</span> 1</span>));</span>
            if</span> (</span>map</span>.</span>containsKey</span>(</span>num</span> -</span> 1</span>))</span>
                res</span> =</span> Math</span>.</span>max</span>(</span>res</span>,</span> map</span>.</span>get</span>(</span>num</span>)</span> +</span> map</span>.</span>get</span>(</span>num</span> -</span> 1</span>));</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Only one loop is there.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> size grows upto size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>