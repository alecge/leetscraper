<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-using-two-arrays-accepted">Approach #2 Using two arrays [Accepted]</a></li>
<a href="#approach-3-using-one-array-accepted">Approach #3 Using one array [Accepted]</a></li>
<a href="#approach-4-single-pass-approach-with-constant-space-accepted">Approach #4 Single Pass Approach with Constant Space [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
The simplest approach makes use of a 1-d array, <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> to keep a track of the candies given to the students. Firstly, we give 1 candy to each student. Then, we start scanning the
array from left-to-right. At every element encountered, firstly, if the current element's ratings, <span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">ratings[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, is larger than the previous element(<span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">ratings[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>) and <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>&lt;</mo>=</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">candies[i]&lt;=candies[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&lt;</span>=</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>,
then we update <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> as <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>=</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">candies[i]=candies[i-1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>.Thus, now the candy distribution for these two elements <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">candies[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> becomes correct for the time being(locally).
 In the same step, we also check if the current element's ratings, <span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">ratings[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, is larger than the next element's ratings,
i.e. <span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>]</mo>&gt;</mo>r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">ratings[i]&gt;ratings[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&gt;</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. If so, we again update <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>=</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">candies[i]=candies[i+1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>. We continue this process for the whole <span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi></mrow><annotation encoding="application/x-tex">ratings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span></span></span></span></span> array. If in any traversal,
no updation of the <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> array occurs, it means we've reached at the final required distribution of the candies and we can stop the traversals. To keep a track of
this we make use of a <span class="maths katex-rendered">f</mi>l</mi>a</mi>g</mi></mrow><annotation encoding="application/x-tex">flag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span></span></span></span></span> which is set to <span class="maths katex-rendered">T</mi>r</mi>u</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{True}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">True</span></span></span></span></span></span> if any updation occurs in a traversal.</p>
At the end, we can sum up all the elements of the <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> array to obtain the required minimum number of candies.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> candy</span>(</span>int</span>[]</span> ratings</span>)</span> {</span>
        int</span>[]</span> candies</span> =</span> new</span> int</span>[</span>ratings</span>.</span>length</span>];</span>
        Arrays</span>.</span>fill</span>(</span>candies</span>,</span> 1</span>);</span>
        boolean</span> flag</span> =</span> true</span>;</span>
        int</span> sum</span> =</span> 0</span>;</span>
        while</span> (</span>flag</span>)</span> {</span>
            flag</span> =</span> false</span>;</span>
            for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> ratings</span>.</span>length</span>;</span> i</span>++)</span> {</span>
                if</span> (</span>i</span> !=</span> ratings</span>.</span>length</span> -</span> 1</span> &amp;&amp;</span> ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> +</span> 1</span>]</span> &amp;&amp;</span> candies</span>[</span>i</span>]</span> &lt;=</span> candies</span>[</span>i</span> +</span> 1</span>])</span> {</span>
                    candies</span>[</span>i</span>]</span> =</span> candies</span>[</span>i</span> +</span> 1</span>]</span> +</span> 1</span>;</span>
                    flag</span> =</span> true</span>;</span>
                }</span>
                if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> -</span> 1</span>]</span> &amp;&amp;</span> candies</span>[</span>i</span>]</span> &lt;=</span> candies</span>[</span>i</span> -</span> 1</span>])</span> {</span>
                    candies</span>[</span>i</span>]</span> =</span> candies</span>[</span>i</span> -</span> 1</span>]</span> +</span> 1</span>;</span>
                    flag</span> =</span> true</span>;</span>
                }</span>
            }</span>
        }</span>
        for</span> (</span>int</span> candy</span> :</span> candies</span>)</span> {</span>
            sum</span> +=</span> candy</span>;</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. We need to traverse the array at most <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> times.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. One <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</li>
</ul>

<h4 id="approach-2-using-two-arrays-accepted">Approach #2 Using two arrays [Accepted]</h4>
Algorithm</strong></p>
In this approach, we make use of two 1-d arrays <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left2right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">right2left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span>. The <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left2right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> array is used to store the number of candies required by the
current student taking care of the distribution relative to the left neighbours only. i.e. Assuming the distribution rule is: The student with a higher ratings
than its left neighbour should always get more candies than its left neighbour. Similarly, the <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">right2left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> array is used to store the number of candies candies required by the
current student taking care of the distribution relative to the right neighbours only. i.e. Assuming the distribution rule to be: The student with a higher ratings
than its right neighbour should always get more candies than its right neighbour. To do so, firstly we assign 1 candy to each student in both <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left2right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">right2left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> array.
 Then, we traverse the array from
left-to-right and whenever the current element's ratings is larger than the left neighbour we update the
current element's candies in the <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left2right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> array as <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi>[</mo>i</mi>]</mo>=</mo>l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">left2right[i] = left2right[i-1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>, since the current element's candies are always less than or equal candies than its left neighbour before updation.
After the forward traversal, we traverse the array from left-to-right and
update <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">right2left[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> as <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi>[</mo>i</mi>]</mo>=</mo>r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi>[</mo>i</mi>+</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">right2left[i] = right2left[i + 1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>, whenever the current(<span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>) element has a higher ratings than the
right(<span class="maths katex-rendered">(</mo>i</mi>+</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(i+1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>) element.</p>
Now, for the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> student in the array, we need to give <span class="maths katex-rendered">m</mi>a</mi>x</mi></mtext>(</mo>l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi>[</mo>i</mi>]</mo>,</mo>r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi>[</mo>i</mi>]</mo>)</mo></mrow><annotation encoding="application/x-tex">text{max}(left2right[i], right2left[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">max</span></span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>[</span><span class="mord mathit">i</span>]</span>)</span></span></span></span></span> to it, in order to satisfy both the left and the right neighbour
relationship. Thus, at the end, we obtain the minimum number of candies required as:</p>

<p class="maths katex-rendered">
text{minimum_candies}=sum_{i=0}^{n-1} text{max}(left2right[i], right2left[i]), quadtext{where } n = text{length of the ratings array.}
</span><script type="math/tex; mode=display">
text{minimum_candies}=sum_{i=0}^{n-1} text{max}(left2right[i], right2left[i]), quadtext{where } n = text{length of the ratings array.}
</script></p>
</p>
The following animation illustrates the method:</p>
<img alt="Candy_Two_Arrays" src="../Figures/135_Candy_Two_Pass.gif"></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> candy</span>(</span>int</span>[]</span> ratings</span>)</span> {</span>
        int</span> sum</span> =</span> 0</span>;</span>
        int</span>[]</span> left2right</span> =</span> new</span> int</span>[</span>ratings</span>.</span>length</span>];</span>
        int</span>[]</span> right2left</span> =</span> new</span> int</span>[</span>ratings</span>.</span>length</span>];</span>
        Arrays</span>.</span>fill</span>(</span>left2right</span>,</span> 1</span>);</span>
        Arrays</span>.</span>fill</span>(</span>right2left</span>,</span> 1</span>);</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> ratings</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> -</span> 1</span>])</span> {</span>
                left2right</span>[</span>i</span>]</span> =</span> left2right</span>[</span>i</span> -</span> 1</span>]</span> +</span> 1</span>;</span>
            }</span>
        }</span>
        for</span> (</span>int</span> i</span> =</span> ratings</span>.</span>length</span> -</span> 2</span>;</span> i</span> &gt;=</span> 0</span>;</span> i</span>--)</span> {</span>
            if</span> (</span>ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> +</span> 1</span>])</span> {</span>
                right2left</span>[</span>i</span>]</span> =</span> right2left</span>[</span>i</span> +</span> 1</span>]</span> +</span> 1</span>;</span>
            }</span>
        }</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> ratings</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            sum</span> +=</span> Math</span>.</span>max</span>(</span>left2right</span>[</span>i</span>],</span> right2left</span>[</span>i</span>]);</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left2right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">right2left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> arrays are traversed thrice.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Two arrays <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>2</mn>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left2right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>2</mn>l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">right2left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> are used.</p>
</li>
</ul>

<h4 id="approach-3-using-one-array-accepted">Approach #3 Using one array [Accepted]</h4>
Algorithm</strong></p>
In the previous approach, we used two arrays to keep track of the left neighbour and the right neighbour relation individually and later on combined these two. Instead of this, we
can make use of a single array <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> to keep the count of the number of candies to be allocated to the current student. In order to do so, firstly we assign 1 candy to
each student. Then, we traverse the array from left-to-right and distribute the candies following only the left neighbour relation i.e. whenever the current element's ratings is
larger than the left neighbour and has less than or equal candies than its left neighbour, we update the
current element's candies in the <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> array as <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>=</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">candies[i] = candies[i-1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>. While updating we need not compare <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> and <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">candies[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, since
 <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>≤</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">candies[i] leq candies[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>≤</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> before updation. After this, we traverse the array from right-to-left. Now, we need to
update the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element's candies in order to satisfy both the left neighbour and the right neighbour relation. Now, during the backward traversal, if <span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>]</mo>&gt;</mo>r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">ratings[i]&gt;ratings[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&gt;</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>,
considering only the right neighbour criteria, we could've updated <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> as <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>=</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">candies[i] = candies[i + 1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>. But, this time we need to update the <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> only
if <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>≤</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">candies[i] leq candies[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>≤</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. This happens because, this time we've already altered the <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> array during the forward traversal and thus <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> isn't
necessarily less than or equal to <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">candies[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. Thus, if <span class="maths katex-rendered">r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>]</mo>&gt;</mo>r</mi>a</mi>t</mi>i</mi>n</mi>g</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">ratings[i] &gt; ratings[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&gt;</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, we can update <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> as <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>=</mo>m</mi>a</mi>x</mi></mtext>(</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo>,</mo>c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>+</mo>1</mn>]</mo>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">candies[i] = text{max}(candies[i], candies[i + 1] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">max</span></span>(</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span>, which makes
<span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">candies[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> satisfy both the left neighbour and the right neighbour criteria.</p>
Again, we need sum up all the elements of the <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> array to obtain the required result.</p>

<p class="maths katex-rendered">[
text{minimum_candies} = sum_{i=0}^{n-1} candies[i], quadtext{where } n = text{length of the ratings array.}
]</p>
</p>
java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> candy</span>(</span>int</span>[]</span> ratings</span>)</span> {</span>
        int</span>[]</span> candies</span> =</span> new</span> int</span>[</span>ratings</span>.</span>length</span>];</span>
        Arrays</span>.</span>fill</span>(</span>candies</span>,</span> 1</span>);</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> ratings</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> -</span> 1</span>])</span> {</span>
                candies</span>[</span>i</span>]</span> =</span> candies</span>[</span>i</span> -</span> 1</span>]</span> +</span> 1</span>;</span>
            }</span>
        }</span>
        int</span> sum</span> =</span> candies</span>[</span>ratings</span>.</span>length</span> -</span> 1</span>];</span>
        for</span> (</span>int</span> i</span> =</span> ratings</span>.</span>length</span> -</span> 2</span>;</span> i</span> &gt;=</span> 0</span>;</span> i</span>--)</span> {</span>
            if</span> (</span>ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> +</span> 1</span>])</span> {</span>
                candies</span>[</span>i</span>]</span> =</span> Math</span>.</span>max</span>(</span>candies</span>[</span>i</span>],</span> candies</span>[</span>i</span> +</span> 1</span>]</span> +</span> 1</span>);</span>
            }</span>
            sum</span> +=</span> candies</span>[</span>i</span>];</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The array <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is traversed thrice.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. An array <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-4-single-pass-approach-with-constant-space-accepted">Approach #4 Single Pass Approach with Constant Space [Accepted]</h4>
Algorithm</strong></p>
This approach relies on the observation(as demonstrated in the figure below as well) that in order to distribute the candies as per the given criteria using
the minimum number of candies, the candies are always distributed in terms of increments of 1. Further, while distributing the candies, the local minimum number of candies
given to a student is 1. Thus, the sub-distributions always take the form: <span class="maths katex-rendered">1</mn>,</mi>&nbsp;</mtext>2</mn>,</mi>&nbsp;</mtext>3</mn>,</mi>&nbsp;</mtext>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>n</mi></mtext></mrow><annotation encoding="application/x-tex">text{1, 2, 3, ..., n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1,&nbsp;2,&nbsp;3,&nbsp;...,&nbsp;n</span></span></span></span></span></span> or <span class="maths katex-rendered">n</mi>,</mi>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>2</mn>,</mi>&nbsp;</mtext>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{n,..., 2, 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">n,...,&nbsp;2,&nbsp;1</span></span></span></span></span></span>, whose sum is simply given by <span class="maths katex-rendered">n</mi>(</mo>n</mi>+</mo>1</mn>)</mo>/</mi>2</mn></mrow><annotation encoding="application/x-tex">n(n+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
Now, we can view the given <span class="maths katex-rendered">r</mi>a</mi>n</mi>k</mi>i</mi>n</mi>g</mi>s</mi></mrow><annotation encoding="application/x-tex">rankings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span></span></span></span></span> as some
rising and falling slopes. Whenever the slope is rising, the distribution takes the form: <span class="maths katex-rendered">1</mn>,</mi>&nbsp;</mtext>2</mn>,</mi>&nbsp;</mtext>3</mn>,</mi>&nbsp;</mtext>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{1, 2, 3, ..., m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1,&nbsp;2,&nbsp;3,&nbsp;...,&nbsp;m</span></span></span></span></span></span>. Similarly, a falling slope takes the form:
<span class="maths katex-rendered">k</mi>,</mi>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>2</mn>,</mi>&nbsp;</mtext>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{k,..., 2, 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k,...,&nbsp;2,&nbsp;1</span></span></span></span></span></span>. An issue that arises now is that the local peak point can be included in only one of the slopes.
Whether to include the local peak point(<span class="maths katex-rendered">n</mi></mtext></mrow><annotation encoding="application/x-tex">text{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">n</span></span></span></span></span></span>) in the rising slope or the falling slope?</p>
In order to decide it,
we can observe that in order to satisfy both the right neighbour and the left neighbour criteria, the peak point's count needs to be the max. of the counts determined
by the rising and the falling slopes. Thus, in order to determine the number of candies required, the peak point needs to be included in the slope which contains more
number of points. The local valley point can also be included in only one of the slopes, but this issue can be resolved easily, since the local valley point will
always be assigned a candy count of 1(which can be subtracted from the next slope's count calculations).</p>
Coming to the implementation, we maintain two variables <span class="maths katex-rendered">o</mi>l</mi>d</mi>_</mi>s</mi>l</mi>o</mi>p</mi>e</mi></mrow><annotation encoding="application/x-tex">old_slope</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">d</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">e</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>e</mi>w</mi>_</mi>s</mi>l</mi>o</mi>p</mi>e</mi></mrow><annotation encoding="application/x-tex">new_slope</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">e</span></span></span></span></span> to determine the occurence of a peak or a valley. We also use
<span class="maths katex-rendered">u</mi>p</mi></mrow><annotation encoding="application/x-tex">up</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi></mrow><annotation encoding="application/x-tex">down</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span></span></span></span></span> variables to keep a track of the count of elements on the rising slope and on the falling slope respectively(without including the peak element). We always update the total count
of <span class="maths katex-rendered">c</mi>a</mi>n</mi>d</mi>i</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> at the end of a falling slope following a rising slope (or a mountain). The leveling of the points in <span class="maths katex-rendered">r</mi>a</mi>n</mi>k</mi>i</mi>n</mi>g</mi>s</mi></mrow><annotation encoding="application/x-tex">rankings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span></span></span></span></span> also works as the end of a mountain. At the end of the mountain, we determine whether to include the peak point in the rising slope or in the falling slope by comparing the <span class="maths katex-rendered">u</mi>p</mi></mrow><annotation encoding="application/x-tex">up</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi></mrow><annotation encoding="application/x-tex">down</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span></span></span></span></span> variables up to that point. Thus, the count assigned to the peak element becomes: <span class="maths katex-rendered">m</mi>a</mi>x</mi></mtext>(</mo>u</mi>p</mi>,</mo>d</mi>o</mi>w</mi>n</mi>)</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">text{max}(up, down) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">max</span></span>(</span><span class="mord mathit">u</span><span class="mord mathit">p</span>,</span><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>)</span>+</span><span class="mord mathrm">1</span></span></span></span></span>. At this point, we can reset the <span class="maths katex-rendered">u</mi>p</mi></mrow><annotation encoding="application/x-tex">up</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi></mrow><annotation encoding="application/x-tex">down</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span></span></span></span></span> variables indicating the start of a new mountain.</p>
The following figure shows the cases that need to be handled for this example:</p>
rankings: [1 2 3 4 5 3 2 1 2 6 5 4 3 3 2 1 1 3 3 3 4 2]</code></p>
<img alt="Candy_Two_Arrays" src="../Figures/135_Candy_Constant_Space.PNG"></p>
From this figure, we can see that the candy distributions in the subregions always take the form <span class="maths katex-rendered">1</mn>,</mi>&nbsp;</mtext>2</mn>,</mi>&nbsp;</mtext>.</mi>.</mi>.</mi>n</mi></mtext></mrow><annotation encoding="application/x-tex">text{1, 2, ...n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1,&nbsp;2,&nbsp;...n</span></span></span></span></span></span> or <span class="maths katex-rendered">n</mi>,</mi>&nbsp;</mtext>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>2</mn>,</mi>&nbsp;</mtext>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{n, ..., 2, 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">n,&nbsp;...,&nbsp;2,&nbsp;1</span></span></span></span></span></span>.
For the first mountain comprised by the regions <span class="maths katex-rendered">a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span></span></span></span></span> and <span class="maths katex-rendered">b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span></span>, while assigning candies to the local peak point(<span class="maths katex-rendered">p</mi>t</mi>.</mi>5</mn></mrow><annotation encoding="application/x-tex">pt. 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">5</span></span></span></span></span>), it needs to be included in
<span class="maths katex-rendered">a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span></span></span></span></span> to satisfy the left neighbour criteria. The local valley point at the end of region <span class="maths katex-rendered">b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span></span>(<span class="maths katex-rendered">p</mi>t</mi>.</mi>8</mn></mrow><annotation encoding="application/x-tex">pt. 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">8</span></span></span></span></span>) marks the end of the first mountain(region <span class="maths katex-rendered">c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span></span></span></span></span>).
 While performing the calculations, we can include this point in either the current or the following mountain. The <span class="maths katex-rendered">p</mi>t</mi>.</mi>1</mn>3</mn></mrow><annotation encoding="application/x-tex">pt. 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">3</span></span></span></span></span> marks the end of the second
 mountain due to levelling of the <span class="maths katex-rendered">p</mi>t</mi>.</mi>1</mn>3</mn></mrow><annotation encoding="application/x-tex">pt. 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">3</span></span></span></span></span> and <span class="maths katex-rendered">p</mi>t</mi>.</mi>1</mn>4</mn></mrow><annotation encoding="application/x-tex">pt. 14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">4</span></span></span></span></span>. Since, region <span class="maths katex-rendered">e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span></span></span></span></span> has more points than region <span class="maths katex-rendered">d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span></span>, the local peak(<span class="maths katex-rendered">p</mi>t</mi>.</mi>1</mn>0</mn></mrow><annotation encoding="application/x-tex">pt. 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span></span>) needs to be
 included in region <span class="maths katex-rendered">e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span></span></span></span></span> to satisfy the right neighbour criteria. Now, the third mountain <span class="maths katex-rendered">f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span></span></span></span></span> can be considered as a mountian with no rising slope(<span class="maths katex-rendered">u</mi>p</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">up=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>=</span><span class="mord mathrm">0</span></span></span></span></span>)
 but only a falling slope. Similarly, <span class="maths katex-rendered">p</mi>t</mi>.</mi>1</mn>6</mn>,</mo>1</mn>8</mn>,</mo>1</mn>9</mn></mrow><annotation encoding="application/x-tex">pt. 16, 18, 19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">6</span>,</span><span class="mord mathrm">1</span><span class="mord mathrm">8</span>,</span><span class="mord mathrm">1</span><span class="mord mathrm">9</span></span></span></span></span> also act as the mountain ends due to the levelling of the points.</p>
java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> count</span>(</span>int</span> n</span>)</span> {</span>
        return</span> (</span>n</span> *</span> (</span>n</span> +</span> 1</span>))</span> /</span> 2</span>;</span>
    }</span>
    public</span> int</span> candy</span>(</span>int</span>[]</span> ratings</span>)</span> {</span>
        if</span> (</span>ratings</span>.</span>length</span> &lt;=</span> 1</span>)</span> {</span>
            return</span> ratings</span>.</span>length</span>;</span>
        }</span>
        int</span> candies</span> =</span> 0</span>;</span>
        int</span> up</span> =</span> 0</span>;</span>
        int</span> down</span> =</span> 0</span>;</span>
        int</span> old_slope</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> ratings</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            int</span> new_slope</span> =</span> (</span>ratings</span>[</span>i</span>]</span> &gt;</span> ratings</span>[</span>i</span> -</span> 1</span>])</span> ?</span> 1</span> :</span> (</span>ratings</span>[</span>i</span>]</span> &lt;</span> ratings</span>[</span>i</span> -</span> 1</span>]</span> ?</span> -</span>1</span> :</span> 0</span>);</span>
            if</span> ((</span>old_slope</span> &gt;</span> 0</span> &amp;&amp;</span> new_slope</span> ==</span> 0</span>)</span> ||</span> (</span>old_slope</span> &lt;</span> 0</span> &amp;&amp;</span> new_slope</span> &gt;=</span> 0</span>))</span> {</span>
                candies</span> +=</span> count</span>(</span>up</span>)</span> +</span> count</span>(</span>down</span>)</span> +</span> Math</span>.</span>max</span>(</span>up</span>,</span> down</span>);</span>
                up</span> =</span> 0</span>;</span>
                down</span> =</span> 0</span>;</span>
            }</span>
            if</span> (</span>new_slope</span> &gt;</span> 0</span>)</span>
                up</span>++;</span>
            if</span> (</span>new_slope</span> &lt;</span> 0</span>)</span>
                down</span>++;</span>
            if</span> (</span>new_slope</span> ==</span> 0</span>)</span>
                candies</span>++;</span>

            old_slope</span> =</span> new_slope</span>;</span>
        }</span>
        candies</span> +=</span> count</span>(</span>up</span>)</span> +</span> count</span>(</span>down</span>)</span> +</span> Math</span>.</span>max</span>(</span>up</span>,</span> down</span>)</span> +</span> 1</span>;</span>
        return</span> candies</span>;</span>
    }</span>
};</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse the <span class="maths katex-rendered">r</mi>a</mi>n</mi>k</mi>i</mi>n</mi>g</mi>s</mi></mrow><annotation encoding="application/x-tex">rankings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">s</span></span></span></span></span> array once only.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant Extra Space is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>