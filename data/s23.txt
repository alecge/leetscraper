<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>
<a href="#approach-2-compare-one-by-one-accepted">Approach #2 Compare one by one [Accepted]</a></li>
<a href="#approach-3-optimize-approach-2-by-priority-queue-accepted">Approach #3 Optimize Approach 2 by Priority Queue [Accepted]</a></li>
<a href="#approach-4-merge-lists-one-by-one-accepted">Approach #4 Merge lists one by one [Accepted]</a></li>
<a href="#approach-5-merge-with-divide-and-conquer-accepted">Approach #5 Merge with Divide And Conquer [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>
Intuition &amp; Algorithm</strong></p>

Traverse all the linked lists and collect the values of the nodes into an array.</li>
Sort and iterate over this array to get the proper value of nodes.</li>
Create a new sorted linked list and extend it with the new nodes.</li>
</ul>
As for sorting, you can refer <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html">here</a> for more about sorting algorithms.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> mergeKLists</span>(</span>self</span>,</span> lists</span>):</span>
        """</span>
        :type lists: List[ListNode]</span>
        :rtype: ListNode</span>
        """</span>
        self</span>.</span>nodes</span> =</span> []</span>
        head</span> =</span> point</span> =</span> ListNode</span>(</span>0</span>)</span>
        for</span> l</span> in</span> lists</span>:</span>
            while</span> l</span>:</span>
                self</span>.</span>nodes</span>.</span>append</span>(</span>l</span>.</span>val</span>)</span>
                l</span> =</span> l</span>.</span>next</span>
        for</span> x</span> in</span> sorted</span>(</span>self</span>.</span>nodes</span>):</span>
            point</span>.</span>next</span> =</span> ListNode</span>(</span>x</span>)</span>
            point</span> =</span> point</span>.</span>next</span>
        return</span> head</span>.</span>next</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>N</mi>log</mi>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(Nlog N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the total number of nodes. </p>

Collecting all the values costs <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> time.</li>
A stable sorting algorithm costs <span class="maths katex-rendered">O</mi>(</mo>N</mi>log</mi>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(Nlog N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> time.</li>
Iterating for creating the linked list costs <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> time.</li>
</ul>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.</p>

Sorting cost <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> space (depends on the algorithm you choose).</li>
Creating a new linked list costs <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> space.</li>
</ul>
</li>
</ul>

<h4 id="approach-2-compare-one-by-one-accepted">Approach #2 Compare one by one [Accepted]</h4>
Algorithm</strong></p>

Compare every <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> nodes (head of every linked list) and get the node with the smallest value.</li>
Extend the final sorted linked list with the selected nodes.</li>
</ul>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 11</div></div></div>
Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(kN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> where <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> is the number of linked lists.</p>

Almost every selection of node in final linked costs <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> (<span class="maths katex-rendered">k</mi>-</mi>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k-1</span></span></span></span></span></span> times comparison).</li>
There are <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> nodes in the final linked list.</li>
</ul>
</li>

Space complexity :</p>


<span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> Creating a new linked list costs <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> space.</li>

<span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> It's not hard to apply in-place method - connect selected nodes instead of creating new nodes to fill the new linked list.</li>
</ul>
</li>
</ul>

<h4 id="approach-3-optimize-approach-2-by-priority-queue-accepted">Approach #3 Optimize Approach 2 by Priority Queue [Accepted]</h4>
Algorithm</strong></p>
Almost the same as the one above but optimize the comparison process</strong> by priority queue</strong>. You can refer <a href="https://en.wikipedia.org/wiki/Priority_queue">here</a> for more information about it.</p>
Python</strong></p>
</span>from</span> Queue</span> import</span> PriorityQueue</span>

class</span> Solution</span>(</span>object</span>):</span>
    def</span> mergeKLists</span>(</span>self</span>,</span> lists</span>):</span>
        """</span>
        :type lists: List[ListNode]</span>
        :rtype: ListNode</span>
        """</span>
        head</span> =</span> point</span> =</span> ListNode</span>(</span>0</span>)</span>
        q</span> =</span> PriorityQueue</span>()</span>
        for</span> l</span> in</span> lists</span>:</span>
            if</span> l</span>:</span>
                q</span>.</span>put</span>((</span>l</span>.</span>val</span>,</span> l</span>))</span>
        while</span> not</span> q</span>.</span>empty</span>():</span>
            val</span>,</span> node</span> =</span> q</span>.</span>get</span>()</span>
            point</span>.</span>next</span> =</span> ListNode</span>(</span>val</span>)</span>
            point</span> =</span> point</span>.</span>next</span>
            node</span> =</span> node</span>.</span>next</span>
            if</span> node</span>:</span>
                q</span>.</span>put</span>((</span>node</span>.</span>val</span>,</span> node</span>))</span>
        return</span> head</span>.</span>next</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>N</mi>log</mi>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(Nlog k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> where <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> is the number of linked lists.</p>

The comparison cost will be reduced to <span class="maths katex-rendered">O</mi>(</mo>log</mi>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> for every pop and insertion to priority queue. But finding the node with the smallest value just costs <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> time.</li>
There are <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> nodes in the final linked list.</li>
</ul>
</li>

Space complexity :</p>


<span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> Creating a new linked list costs <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> space.</li>

<span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> The code above present applies in-place method which cost <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> space. And the priority queue (often implemented with heaps) costs <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> space (it's far less than <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> in most situations).</li>
</ul>
</li>
</ul>

<h4 id="approach-4-merge-lists-one-by-one-accepted">Approach #4 Merge lists one by one [Accepted]</h4>
Algorithm</strong></p>
Convert merge <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> lists problem to merge 2 lists (<span class="maths katex-rendered">k</mi>-</mi>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k-1</span></span></span></span></span></span>) times. Here is the <a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">merge 2 lists</a> problem page.</p>
Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(kN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> where <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> is the number of linked lists.</p>

We can merge two sorted linked list in <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the total number of nodes in two lists.</li>
Sum up the merge process and we can get:  <span class="maths katex-rendered">O</mi>(</mo>∑</mo>i</mi>=</mo>1</mn></mrow>k</mi>−</mo>1</mn></mrow></msubsup>(</mo>i</mi>∗</mo>(</mo>N</mi></mrow>k</mi></mrow></mfrac>)</mo>+</mo>N</mi></mrow>k</mi></mrow></mfrac>)</mo>)</mo>=</mo>O</mi>(</mo>k</mi>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(sum_{i=1}^{k-1} (i*(frac{N}{k}) + frac{N}{k})) = O(kN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.889239em;"></span><span class="strut bottom" style="height: 1.23424em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.276864em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">1</span></span></span></span><span class="" style="top: -0.403131em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>(</span><span class="mord mathit">i</span>∗</span>(</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.10903em;">N</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>)</span>+</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.10903em;">N</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>)</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.</li>
</ul>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>
</p>

We can merge two sorted linked list in <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> space.</li>
</ul>
</li>
</ul>

<h4 id="approach-5-merge-with-divide-and-conquer-accepted">Approach #5 Merge with Divide And Conquer [Accepted]</h4>
Intuition &amp; Algorithm</strong></p>
This approach walks alongside the one above but is improved a lot. We don't need to traverse most nodes many times repeatedly</p>


Pair up <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> lists and merge each pair.</p>
</li>

After the first pairing, <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> lists are merged into <span class="maths katex-rendered">k</mi>/</mi>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> lists with average <span class="maths katex-rendered">2</mn>N</mi>/</mi>k</mi></mrow><annotation encoding="application/x-tex">2N/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> length, then <span class="maths katex-rendered">k</mi>/</mi>4</mn></mrow><annotation encoding="application/x-tex">k/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathrm">/</span><span class="mord mathrm">4</span></span></span></span></span>, <span class="maths katex-rendered">k</mi>/</mi>8</mn></mrow><annotation encoding="application/x-tex">k/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathrm">/</span><span class="mord mathrm">8</span></span></span></span></span> and so on.</p>
</li>

Repeat this procedure until we get the final sorted linked list.</p>
</li>
</ul>
Thus, we'll traverse almost <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> nodes per pairing and merging, and repeat this procedure about <span class="maths katex-rendered">log</mi>2</mn></mrow></msub>k</mi></mrow></mrow><annotation encoding="application/x-tex">log_{2}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.93888em; vertical-align: -0.24444em;"></span><span class="base textstyle uncramped">lo<span style="margin-right: 0.01389em;">g</span></span><span class="" style="top: 0.24444em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span></span>  times.</p>
<img alt="Divide_and_Conquer" src="../Figures/23/23_divide_and_conquer_new.png"></p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> mergeKLists</span>(</span>self</span>,</span> lists</span>):</span>
        """</span>
        :type lists: List[ListNode]</span>
        :rtype: ListNode</span>
        """</span>
        amount</span> =</span> len</span>(</span>lists</span>)</span>
        interval</span> =</span> 1</span>
        while</span> interval</span> &lt;</span> amount</span>:</span>
            for</span> i</span> in</span> range</span>(</span>0</span>,</span> amount</span> -</span> interval</span>,</span> interval</span> *</span> 2</span>):</span>
                lists</span>[</span>i</span>]</span> =</span> self</span>.</span>merge2Lists</span>(</span>lists</span>[</span>i</span>],</span> lists</span>[</span>i</span> +</span> interval</span>])</span>
            interval</span> *=</span> 2</span>
        return</span> lists</span>[</span>0</span>]</span> if</span> amount</span> &gt;</span> 0</span> else</span> lists</span>

    def</span> merge2Lists</span>(</span>self</span>,</span> l1</span>,</span> l2</span>):</span>
        head</span> =</span> point</span> =</span> ListNode</span>(</span>0</span>)</span>
        while</span> l1</span> and</span> l2</span>:</span>
            if</span> l1</span>.</span>val</span> &lt;=</span> l2</span>.</span>val</span>:</span>
                point</span>.</span>next</span> =</span> l1</span>
                l1</span> =</span> l1</span>.</span>next</span>
            else</span>:</span>
                point</span>.</span>next</span> =</span> l2</span>
                l2</span> =</span> l1</span>
                l1</span> =</span> point</span>.</span>next</span>.</span>next</span>
            point</span> =</span> point</span>.</span>next</span>
        if</span> not</span> l1</span>:</span>
            point</span>.</span>next</span>=</span>l2</span>
        else</span>:</span>
            point</span>.</span>next</span>=</span>l1</span>
        return</span> head</span>.</span>next</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>N</mi>log</mi>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(Nlog k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> where <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> is the number of linked lists.</p>

We can merge two sorted linked list in <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the total number of nodes in two lists.</li>
Sum up the merge process and we can get: <span class="maths katex-rendered">O</mi>(</mo>∑</mo>i</mi>=</mo>1</mn></mrow>l</mi>o</mi>g</mi>2</mn></mrow></msub>k</mi></mrow></mrow></msubsup>N</mi>)</mo>=</mo>O</mi>(</mo>N</mi>log</mi>k</mi>)</mo></mrow><annotation encoding="application/x-tex">Obig(sum_{i=1}^{log_{2}{k}}N big)= O(Nlog k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.967016em;"></span><span class="strut bottom" style="height: 1.31703em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.276864em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">1</span></span></span></span><span class="" style="top: -0.480908em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathit mtight">o</span><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">g</span><span class="" style="top: 0.143em; margin-right: 0.0714286em; margin-left: -0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord scriptscriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>
</li>
</ul>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>
</p>

We can merge two sorted linked lists in <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> space.</li>
</ul>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/hermann">@Hermann0</a></p>