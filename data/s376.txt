<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-dynamic-programming-accepted">Approach #2  Dynamic Programming [Accepted]</a></li>
<a href="#approach-3-linear-dynamic-programming-accepted">Approach #3 Linear Dynamic Programming [Accepted]</a></li>
<a href="#approach-4-space-optimized-dynamic-programming-accepted">Approach #4 Space-Optimized Dynamic Programming [Accepted]</a></li>
<a href="#approach-5-greedy-approach-accepted">Approach #5 Greedy Approach [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
We need to find the length of the longest wiggle subsequence. A wiggle subsequence consists of a subsequence with numbers which appears in alternating ascending / descending order.</p>
Solution</h2>
<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Here, we can find the length of every possible wiggle subsequence and find the maximum length out of them. To implement this, we use a recursive function, <span class="maths katex-rendered">c</mi>a</mi>l</mi>c</mi>u</mi>l</mi>a</mi>t</mi>e</mi></mtext>(</mo>n</mi>u</mi>m</mi>s</mi></mtext>,</mo>i</mi>n</mi>d</mi>e</mi>x</mi></mtext>,</mo>i</mi>s</mi>U</mi>p</mi></mtext>)</mo></mrow><annotation encoding="application/x-tex">text{calculate}(text{nums}, text{index}, text{isUp})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">calculate</span></span>(</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>,</span><span class="mord text textstyle uncramped"><span class="mord mathrm">index</span></span>,</span><span class="mord text textstyle uncramped"><span class="mord mathrm">isUp</span></span>)</span></span></span></span></span> which takes the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span></span></span></span></span>, the <span class="maths katex-rendered">i</mi>n</mi>d</mi>e</mi>x</mi></mtext></mrow><annotation encoding="application/x-tex">text{index}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">index</span></span></span></span></span></span> from which we need to find the length of the longest wiggle subsequence, boolean variable <span class="maths katex-rendered">i</mi>s</mi>U</mi>p</mi></mtext></mrow><annotation encoding="application/x-tex">text{isUp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">isUp</span></span></span></span></span></span> to tell whether we need to find an increasing wiggle or decreasing wiggle respectively. If the function <span class="maths katex-rendered">c</mi>a</mi>l</mi>c</mi>u</mi>l</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{calculate}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">calculate</span></span></span></span></span></span> is called after an increasing wiggle, we need to find the next decreasing wiggle with the same function. If the function <span class="maths katex-rendered">c</mi>a</mi>l</mi>c</mi>u</mi>l</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{calculate}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">calculate</span></span></span></span></span></span> is called after a decreasing wiggle, we need to find the next increasing wiggle with the same function.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    private</span> int</span> calculate</span>(</span>int</span>[]</span> nums</span>,</span> int</span> index</span>,</span> boolean</span> isUp</span>)</span> {</span>
        int</span> maxcount</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> index</span> +</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> ((</span>isUp</span> &amp;&amp;</span> nums</span>[</span>i</span>]</span> &gt;</span> nums</span>[</span>index</span>])</span> ||</span> (!</span>isUp</span> &amp;&amp;</span> nums</span>[</span>i</span>]</span> &lt;</span> nums</span>[</span>index</span>]))</span>
                maxcount</span> =</span> Math</span>.</span>max</span>(</span>maxcount</span>,</span> 1</span> +</span> calculate</span>(</span>nums</span>,</span> i</span>,</span> !</span>isUp</span>));</span>
        }</span>
        return</span> maxcount</span>;</span>
    }</span>

    public</span> int</span> wiggleMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 2</span>)</span>
            return</span> nums</span>.</span>length</span>;</span>
        return</span> 1</span> +</span> Math</span>.</span>max</span>(</span>calculate</span>(</span>nums</span>,</span> 0</span>,</span> true</span>),</span> calculate</span>(</span>nums</span>,</span> 0</span>,</span> false</span>));</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>!</mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>!</span>)</span></span></span></span></span>. <span class="maths katex-rendered">c</mi>a</mi>l</mi>c</mi>u</mi>l</mi>a</mi>t</mi>e</mi></mtext>(</mo>)</mo></mrow><annotation encoding="application/x-tex">text{calculate}()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">calculate</span></span>(</span>)</span></span></span></span></span> will be called maximum <span class="maths katex-rendered">n</mi>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>!</span></span></span></span></span> times.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Recursion of depth <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</li>
</ul>

<h4 id="approach-2-dynamic-programming-accepted">Approach #2  Dynamic Programming [Accepted]</h4>
Algorithm</strong></p>
To understand this approach, take two arrays for dp named <span class="maths katex-rendered">u</mi>p</mi></mrow><annotation encoding="application/x-tex">up</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi></mrow><annotation encoding="application/x-tex">down</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span></span></span></span></span>.</p>
Whenever we pick up any element of the array to be a part of the wiggle subsequence, that element could be a part of a rising wiggle or a falling wiggle depending upon which element we have taken prior to it.</p>

<span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">up[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> refers to the length of the longest wiggle subsequence obtained so far considering <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element as the last element of the wiggle subsequence and ending with a rising wiggle.</p>
Similarly, <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">down[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> refers to the length of the longest wiggle subsequence obtained so far considering <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element as the last element of the wiggle subsequence and ending with a falling wiggle.</p>

<span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">up[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> will be updated every time we find a rising wiggle ending with the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element. Now, to find <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">up[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, we need to consider the maximum out of all the previous wiggle subsequences ending with a falling wiggle i.e. <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">down[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, for every <span class="maths katex-rendered">j</mi>&lt;</mo>i</mi></mrow><annotation encoding="application/x-tex">j&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>&lt;</span><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>&gt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]&gt;nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&gt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Similarly, <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">down[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> will be updated.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> wiggleMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 2</span>)</span>
            return</span> nums</span>.</span>length</span>;</span>
        int</span>[]</span> up</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        int</span>[]</span> down</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            for</span>(</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> i</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>nums</span>[</span>i</span>]</span> &gt;</span> nums</span>[</span>j</span>])</span> {</span>
                    up</span>[</span>i</span>]</span> =</span> Math</span>.</span>max</span>(</span>up</span>[</span>i</span>],</span>down</span>[</span>j</span>]</span> +</span> 1</span>);</span>
                }</span> else</span> if</span> (</span>nums</span>[</span>i</span>]</span> &lt;</span> nums</span>[</span>j</span>])</span> {</span>
                    down</span>[</span>i</span>]</span> =</span> Math</span>.</span>max</span>(</span>down</span>[</span>i</span>],</span>up</span>[</span>j</span>]</span> +</span> 1</span>);</span>
                }</span>
            }</span>
        }</span>
        return</span> 1</span> +</span> Math</span>.</span>max</span>(</span>down</span>[</span>nums</span>.</span>length</span> -</span> 1</span>],</span> up</span>[</span>nums</span>.</span>length</span> -</span> 1</span>]);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Loop inside a loop.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Two arrays of the same length are used for dp.</li>
</ul>

<h4 id="approach-3-linear-dynamic-programming-accepted">Approach #3 Linear Dynamic Programming [Accepted]</h4>
Algorithm</strong></p>
Any element in the array could correspond to only one of the three possible states:</p>

up position, it means <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>&gt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i] &gt; nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&gt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>
</li>
down position, it means <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>&lt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i] &lt; nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&lt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>
</li>
equals to position, <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>=</mo>=</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i] == nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span>=</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>
</li>
</ol>
The updates are done as:</p>
If <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>&gt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i] &gt; nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&gt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, that means it wiggles up. The element before it must be a down position. So <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo>=</mo>d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">up[i] = down[i-1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>, <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">down[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> remains the same as <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">down[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>.
If <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>&lt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i] &lt; nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>&lt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, that means it wiggles down. The element before it must be a up position. So <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>]</mo>=</mo>u</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">down[i] = up[i-1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>, <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">up[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> remains the same as <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">up[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>.
If <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>=</mo>=</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i] == nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>=</span>=</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, that means it will not change anything becaue it didn't wiggle at all. So both <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">down[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> and <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">up[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> remain the same as <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">down[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">up[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>.</p>
At the end, we can find the larger out of <span class="maths katex-rendered">u</mi>p</mi>[</mo>l</mi>e</mi>n</mi>g</mi>t</mi>h</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">up[length-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">t</span><span class="mord mathit">h</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>l</mi>e</mi>n</mi>g</mi>t</mi>h</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">down[length-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">t</span><span class="mord mathit">h</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to find the max. wiggle subsequence length, where <span class="maths katex-rendered">l</mi>e</mi>n</mi>g</mi>t</mi>h</mi></mrow><annotation encoding="application/x-tex">length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">t</span><span class="mord mathit">h</span></span></span></span></span> refers to the number of elements in the given array.</p>
The process can be illustrated with the following example:</p>
<!--![Wiggle gif](https://leetcode.com/media/original_images/376_Wiggle_Subsequence.gif)-->

<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 12</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> wiggleMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 2</span>)</span>
            return</span> nums</span>.</span>length</span>;</span>
        int</span>[]</span> up</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        int</span>[]</span> down</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        up</span>[</span>0</span>]</span> =</span> down</span>[</span>0</span>]</span> =</span> 1</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>nums</span>[</span>i</span>]</span> &gt;</span> nums</span>[</span>i</span> -</span> 1</span>])</span> {</span>
                up</span>[</span>i</span>]</span> =</span> down</span>[</span>i</span> -</span> 1</span>]</span> +</span> 1</span>;</span>
                down</span>[</span>i</span>]</span> =</span> down</span>[</span>i</span> -</span> 1</span>];</span>
            }</span> else</span> if</span> (</span>nums</span>[</span>i</span>]</span> &lt;</span> nums</span>[</span>i</span> -</span> 1</span>])</span> {</span>
                down</span>[</span>i</span>]</span> =</span> up</span>[</span>i</span> -</span> 1</span>]</span> +</span> 1</span>;</span>
                up</span>[</span>i</span>]</span> =</span> up</span>[</span>i</span> -</span> 1</span>];</span>
            }</span> else</span> {</span>
                down</span>[</span>i</span>]</span> =</span> down</span>[</span>i</span> -</span> 1</span>];</span>
                up</span>[</span>i</span>]</span> =</span> up</span>[</span>i</span> -</span> 1</span>];</span>
            }</span>
        }</span>
        return</span> Math</span>.</span>max</span>(</span>down</span>[</span>nums</span>.</span>length</span> -</span> 1</span>],</span> up</span>[</span>nums</span>.</span>length</span> -</span> 1</span>]);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Only one pass over the array length.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Two arrays of the same length are used for dp.</li>
</ul>

<h4 id="approach-4-space-optimized-dynamic-programming-accepted">Approach #4 Space-Optimized Dynamic Programming [Accepted]</h4>
Algorithm</strong></p>
This approach relies on the same concept as <a href="https://leetcode.com/articles/wiggle-subsequence/#approach-3-linear-dynamic-programming-accepted">Approach #3</a>. But we can observe that in the DP approach, for updating elements <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">up[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">down[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, we need only the elements <span class="maths katex-rendered">u</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">up[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>o</mi>w</mi>n</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">down[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">n</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. Thus, we can save space by not using the whole array, but only the last elements.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> wiggleMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 2</span>)</span>
            return</span> nums</span>.</span>length</span>;</span>
        int</span> down</span> =</span> 1</span>,</span> up</span> =</span> 1</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>nums</span>[</span>i</span>]</span> &gt;</span> nums</span>[</span>i</span> -</span> 1</span>])</span>
                up</span> =</span> down</span> +</span> 1</span>;</span>
            else</span> if</span> (</span>nums</span>[</span>i</span>]</span> &lt;</span> nums</span>[</span>i</span> -</span> 1</span>])</span>
                down</span> =</span> up</span> +</span> 1</span>;</span>
        }</span>
        return</span> Math</span>.</span>max</span>(</span>down</span>,</span> up</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Only one pass over the array length.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</li>
</ul>

<h4 id="approach-5-greedy-approach-accepted">Approach #5 Greedy Approach [Accepted]</h4>
Algorithm</strong></p>
We need not necessarily need dp to solve this problem. This problem is equivalent to finding the number of alternating max. and min. peaks in the array. Since, if we choose any other intermediate number to be a part of the current wiggle subsequence, the maximum length of that wiggle subsequence will always be less than or equal to the one obtained by choosing only the consecutive max. and min. elements.</p>
This can be clarified by looking at the following figure:
<img alt="Wiggle Peaks" src="https://leetcode.com/media/original_images/376_Wiggle_Subsequence.PNG"></p>
From the above figure, we can see that if we choose C</strong> instead of D</strong> as the 2nd point in the wiggle subsequence, we can't include the point E</strong>. Thus, we won't obtain the maximum length wiggle subsequence.</p>
Thus, to solve this problem, we maintain a variable <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi>d</mi>i</mi>f</mi>f</mi></mtext></mrow><annotation encoding="application/x-tex">text{prevdiff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">prevdiff</span></span></span></span></span></span>, where <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi>d</mi>i</mi>f</mi>f</mi></mtext></mrow><annotation encoding="application/x-tex">text{prevdiff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">prevdiff</span></span></span></span></span></span> is used to indicate whether the current subsequence of numbers lies in an increasing or decreasing wiggle. If <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi>d</mi>i</mi>f</mi>f</mi></mtext>&gt;</mo>0</mn></mrow><annotation encoding="application/x-tex">text{prevdiff} &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">prevdiff</span></span>&gt;</span><span class="mord mathrm">0</span></span></span></span></span>, it indicates that we have found the increasing wiggle and are looking for a decreasing wiggle now. Thus, we update the length of the found subsequence when <span class="maths katex-rendered">d</mi>i</mi>f</mi>f</mi></mtext></mrow><annotation encoding="application/x-tex">text{diff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">diff</span></span></span></span></span></span> (<span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>−</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i]-nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>−</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>) becomes negative. Similarly, if <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi>d</mi>i</mi>f</mi>f</mi></mtext>&lt;</mo>0</mn></mrow><annotation encoding="application/x-tex">text{prevdiff} &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">prevdiff</span></span>&lt;</span><span class="mord mathrm">0</span></span></span></span></span>, we will update the count when <span class="maths katex-rendered">d</mi>i</mi>f</mi>f</mi></mtext></mrow><annotation encoding="application/x-tex">text{diff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">diff</span></span></span></span></span></span> (<span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>−</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i]-nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>−</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>) becomes positive.</p>
When the complete array has been traversed, we get the required count, which represents the length of the longest wiggle subsequence.</p>
java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> wiggleMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 2</span>)</span>
            return</span> nums</span>.</span>length</span>;</span>
        int</span> prevdiff</span> =</span> nums</span>[</span>1</span>]</span> -</span> nums</span>[</span>0</span>];</span>
        int</span> count</span> =</span> prevdiff</span> !=</span> 0</span> ?</span> 2</span> :</span> 1</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 2</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            int</span> diff</span> =</span> nums</span>[</span>i</span>]</span> -</span> nums</span>[</span>i</span> -</span> 1</span>];</span>
            if</span> ((</span>diff</span> &gt;</span> 0</span> &amp;&amp;</span> prevdiff</span> &lt;=</span> 0</span>)</span> ||</span> (</span>diff</span> &lt;</span> 0</span> &amp;&amp;</span> prevdiff</span> &gt;=</span> 0</span>))</span> {</span>
                count</span>++;</span>
                prevdiff</span> =</span> diff</span>;</span>
            }</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse the given array once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. No extra space is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>