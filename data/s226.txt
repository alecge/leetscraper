<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-recursive-accepted">Approach #1 (Recursive) [Accepted]</a></li>
<a href="#approach-2-iterative-accepted">Approach #2 (Iterative) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-recursive-accepted">Approach #1 (Recursive) [Accepted]</h4>
This is a classic tree problem that is best-suited for a recursive approach.</p>
Algorithm</strong></p>
The inverse of an empty tree is the empty tree. The inverse of a tree with root <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span>, and subtrees <span class="maths katex-rendered">mbox{right}</span><script type="math/tex">mbox{right}</script></span> and <span class="maths katex-rendered">(mbox{left})</span>, is a tree with root <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span>, whose right subtree is the inverse of <span class="maths katex-rendered">(mbox{left})</span>, and whose left subtree is the inverse of <span class="maths katex-rendered">(mbox{right})</span>.</p>
Java</strong></p>
</span>public</span> TreeNode</span> invertTree</span>(</span>TreeNode</span> root</span>)</span> {</span>
    if</span> (</span>root</span> ==</span> null</span>)</span> {</span>
        return</span> null</span>;</span>
    }</span>
    TreeNode</span> right</span> =</span> invertTree</span>(</span>root</span>.</span>right</span>);</span>
    TreeNode</span> left</span> =</span> invertTree</span>(</span>root</span>.</span>left</span>);</span>
    root</span>.</span>left</span> =</span> right</span>;</span>
    root</span>.</span>right</span> =</span> left</span>;</span>
    return</span> root</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>
Since each node in the tree is visited only once, the time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the number of nodes in the tree. We cannot do better than that, since at the very least we have to visit each node to invert it.</p>
Because of recursion, <span class="maths katex-rendered">O</mi>(</mo>h</mi>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">h</span>)</span></span></span></span></span> function calls will be placed on the stack in the worst case, where <span class="maths katex-rendered">h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span></span></span></span></span> is the height of the tree. Because <span class="maths katex-rendered">h</mi>∈</mo>O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">hin O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span>∈</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, the space complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>

<h4 id="approach-2-iterative-accepted">Approach #2 (Iterative) [Accepted]</h4>
Alternatively, we can solve the problem iteratively, in a manner similar to breadth-first search.</p>
Algorithm</strong></p>
The idea is that we need to swap the left and right child of all nodes in the tree. So we create a queue to store nodes whose left and right child have not been swapped yet. Initially, only the root is in the queue. As long as the queue is not empty, remove the next node from the queue, swap its children, and add the children to the queue. Null nodes are not added to the queue. Eventually, the queue will be empty and all the children swapped, and we return the original root.</p>
Java</strong></p>
</span>public</span> TreeNode</span> invertTree</span>(</span>TreeNode</span> root</span>)</span> {</span>
    if</span> (</span>root</span> ==</span> null</span>)</span> return</span> null</span>;</span>
    Queue</span>&lt;</span>TreeNode</span>&gt;</span> queue</span> =</span> new</span> LinkedList</span>&lt;</span>TreeNode</span>&gt;();</span>
    queue</span>.</span>add</span>(</span>root</span>);</span>
    while</span> (!</span>queue</span>.</span>isEmpty</span>())</span> {</span>
        TreeNode</span> current</span> =</span> queue</span>.</span>poll</span>();</span>
        TreeNode</span> temp</span> =</span> current</span>.</span>left</span>;</span>
        current</span>.</span>left</span> =</span> current</span>.</span>right</span>;</span>
        current</span>.</span>right</span> =</span> temp</span>;</span>
        if</span> (</span>current</span>.</span>left</span> !=</span> null</span>)</span> queue</span>.</span>add</span>(</span>current</span>.</span>left</span>);</span>
        if</span> (</span>current</span>.</span>right</span> !=</span> null</span>)</span> queue</span>.</span>add</span>(</span>current</span>.</span>right</span>);</span>
    }</span>
    return</span> root</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>
Since each node in the tree is visited / added to the queue only once, the time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the number of nodes in the tree.</p>
Space complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, since in the worst case, the queue will contain all nodes in one level of the binary tree. For a full binary tree, the leaf level has <span class="maths katex-rendered">⌈</mo>n</mi></mrow>2</mn></mrow></mfrac>⌉</mo>=</mo>O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">lceil frac{n}{2}rceil=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped">⌈</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>⌉</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> leaves.</p>
Analysis written by: @noran</p>