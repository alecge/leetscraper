Solution</h2>
Intuition</strong></p>
Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</p>
Algorithm</strong></p>
The solution is very intuitive. But it is not trivial to write a concise and bug-free code.</p>
A well-formed LinkedList</code> need two pointers head and tail to support operations at both ends. The variables head</code> and odd</code> are the head pointer and tail pointer of one LinkedList</code> we call oddList; the variables evenHead</code> and even</code> are the head pointer and tail pointer of another LinkedList</code> we call evenList. The algorithm traverses the original LinkedList and put the odd nodes into the oddList and the even nodes into the evenList. To traverse a LinkedList we need at least one pointer as an iterator for the current node. But here the pointers odd</code> and even</code> not only serve as the tail pointers but also act as the iterators of the original list.</p>
The best way of solving any linked list problem is to visualize it either in your mind or on a piece of paper. An illustration of our algorithm is following:</p>
<img alt="Illustration of odd even linked list" src="https://leetcode.com/media/documents/328_Odd_Even.svg" title="Odd Even Linked List" width="539px"></p>
Figure 1. Step by step example of the odd and even linked list.</em></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> ListNode</span> oddEvenList</span>(</span>ListNode</span> head</span>)</span> {</span>
        if</span> (</span>head</span> ==</span> null</span>)</span> return</span> null</span>;</span>
        ListNode</span> odd</span> =</span> head</span>,</span> even</span> =</span> head</span>.</span>next</span>,</span> evenHead</span> =</span> even</span>;</span>
        while</span> (</span>even</span> !=</span> null</span> &amp;&amp;</span> even</span>.</span>next</span> !=</span> null</span>)</span> {</span>
            odd</span>.</span>next</span> =</span> even</span>.</span>next</span>;</span>
            odd</span> =</span> odd</span>.</span>next</span>;</span>
            even</span>.</span>next</span> =</span> odd</span>.</span>next</span>;</span>
            even</span> =</span> even</span>.</span>next</span>;</span>
        }</span>
        odd</span>.</span>next</span> =</span> evenHead</span>;</span>
        return</span> head</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. There are total <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes and we visit each node once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. All we need is the four pointers.</p>
</li>
</ul>