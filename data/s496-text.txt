Solution
Approach #1 Brute Force [Time Limit Exceeded]
Algorithm
In brute force approach, we consider every possible number to be a divisor of the given number
num
num, by iterating over all the numbers lesser than
num
num. Then, we add up all the factors to check if the given number satisfies the Perfect Number property. This approach obviously fails if the number
num
num is very large.
Java
public class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num <= 0) {
            return false;
        }
        int sum = 0;
        for (int i = 1; i < num; i++) {
            if (num % i == 0) {
                sum += i;
            }

        }
        return sum == num;
    }
}
Complexity Analysis
Time complexity :
O(n)
O(n). We iterate over all the numbers lesser than
n
n.
Space complexity :
O(1)
O(1). Constant extra space is used.
Approach #2 Better Brute Force [Time Limit Exceeded]
Algorithm
We can little optimize the brute force by breaking the loop when the value of
sum
sum increase the value of
num
num. In that case, we can directly return
false
false.
Java
public class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num <= 0) {
            return false;
        }
        int sum = 0;
        for (int i = 1; i < num; i++) {
            if (num % i == 0) {
                sum += i;
            }
            if(sum>num) {
                return false;
            }
        }
        return sum == num;
    }
}
Complexity Analysis
Time complexity :
O(n)
O(n). In worst case, we iterate over all the numbers lesser than
n
n.
Space complexity :
O(1)
O(1). Constant extra space is used.
Approach #3 Optimal Solution [Accepted]
Algorithm
In this method, instead of iterating over all the integers to find the factors of
num
num, we only iterate upto the
\sqrt{n}
√
n
. The reasoning behind this can be understood as follows.
Consider the given number
num
num which can have
m
m distinct factors, namely
n_1, n_2,..., n_m
n
1
,n
2
,...,n
m
. Now, since the number
num
num is divisible by
n_i
n
i
, it is also divisible by
n_j=num/n_1
n
j
=num/n
1
i.e.
n_i*n_j=num
n
i
∗n
j
=num. Also, the largest number in such a pair can only be up to
\sqrt{num}
√
num
(because
\sqrt{num} \times \sqrt{num}=num
√
num
×√
num
=num). Thus, we can get a significant reduction in the run-time by iterating only upto
\sqrt{num}
√
num
and considering such
n_i
n
i
's and
n_j
n
j
's in a single pass directly.
Further, if
\sqrt{num}
√
num
is also a factor, we have to consider the factor only once while checking for the perfect number property.
We sum up all such factors and check if the given number is a Perfect Number or not. Another point to be observed is that while considering 1 as such a factor,
num
num will also be considered as the other factor. Thus, we need to subtract
num
num from the
sum
sum.
Java
    public boolean checkPerfectNumber(int num) {
        if (num <= 0) {
            return false;
        }
        int sum = 0;
        for (int i = 1; i * i <= num; i++) {
            if (num % i == 0) {
                sum += i;
                if (i * i != num) {
                    sum += num / i;
                }

            }
        }
        return sum - num == num;
    }
}
Complexity Analysis
Time complexity :
O(\sqrt{n})
O(√
n
). We iterate only over the range 1 < i ≤ \sqrt{num}.
Space complexity :
O(1)
O(1). Constant extra space is used.
Approach #4 Euclid-Euler Theorem [Accepted]
Algorithm
Euclid proved that \(2^{p−1}(2^p − 1)\) is an even perfect number whenever \(2^p − 1\) is prime, where
p
p is prime.
For example, the first four perfect numbers are generated by the formula \(2^{p−1}(2^p − 1)\), with
p
p a prime number, as follows:
for p = 2:   21(22 − 1) = 6
for p = 3:   22(23 − 1) = 28
for p = 5:   24(25 − 1) = 496
for p = 7:   26(27 − 1) = 8128.
Prime numbers of the form \(2^p − 1\) are known as Mersenne primes. For \(2^p − 1\) to be prime, it is necessary that
p
p itself be prime. However, not all numbers of the form \(2^p − 1\) with a prime
p
p are prime; for example, \(2^{11} − 1 = 2047 = 23 × 89\) is not a prime number.
You can see that for small value of
p
p, its related perfect number goes very high. So, we need to evaluate perfect numbers for some primes
(2, 3, 5, 7, 13, 17, 19, 31)
(2,3,5,7,13,17,19,31) only, as for bigger prime its perfect number will not fit in 64 bits.
Java
public class Solution {
    public int pn(int p) {
        return (1 << (p - 1)) * ((1 << p) - 1);
    }
    public boolean checkPerfectNumber(int num) {
        int[] primes=new int[]{2,3,5,7,13,17,19,31};
        for (int prime: primes) {
            if (pn(prime) == num)
                return true;
        }
        return false;
    }
}
Complexity Analysis
Time complexity :
O(\log{n})
O(logn). Number of primes will be in order
\log{num}
lognum.
Space complexity :
O(\log{n})
O(logn). Space used to store primes.
Analysis written by: @vinod23