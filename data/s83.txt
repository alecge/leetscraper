Solution</h2>

<h4 id="straight-forward-approach-accepted">Straight-Forward Approach [Accepted]</h4>
Algorithm</strong></p>
This is a simple problem that merely tests your ability to manipulate list node pointers. Because the input list is sorted, we can determine if a node is a duplicate by comparing its value to the node after</em> it in the list. If it is a duplicate, we change the next</code> pointer of the current node so that it skips the next node and points directly to the one after the next node.</p>
Java</strong></p>
</span>public</span> ListNode</span> deleteDuplicates</span>(</span>ListNode</span> head</span>)</span> {</span>
    ListNode</span> current</span> =</span> head</span>;</span>
    while</span> (</span>current</span> !=</span> null</span> &amp;&amp;</span> current</span>.</span>next</span> !=</span> null</span>)</span> {</span>
        if</span> (</span>current</span>.</span>next</span>.</span>val</span> ==</span> current</span>.</span>val</span>)</span> {</span>
            current</span>.</span>next</span> =</span> current</span>.</span>next</span>.</span>next</span>;</span>
        }</span> else</span> {</span>
            current</span> =</span> current</span>.</span>next</span>;</span>
        }</span>
    }</span>
    return</span> head</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>
Because each node in the list is checked exactly once to determine if it is a duplicate or not, the total run time is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the number of nodes in the list.</p>
Space complexity is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> since no additional space is used.</p>
Correctness</strong></p>
We can prove the correctness of this code by defining a loop invariant</em>. A loop invariant is condition that is true before and after every iteration of the loop. In this case, a loop invariant that helps us prove correctness is this:</p>

All nodes in the list up to the pointer current</code> do not contain duplicate elements.</p>
</blockquote>
We can prove that this condition is indeed a loop invariant by induction. Before going into the loop, current</code> points to the head of the list. Therefore, the part of the list up to current</code> contains only the head. And so it can not contain any duplicate elements. Now suppose current</code> is now pointing to some node in the list (but not the last element), and the part of the list up to current</code> contains no duplicate elements. After another loop iteration, one of two things happen.</p>


current.next</code> was a duplicate of current</code>. In this case, the duplicate node at current.next</code> is deleted, and current</code> stays pointing to the same node as before. Therefore, the condition still holds; there are still no duplicates up to current</code>.</p>
</li>

current.next</code> was not a duplicate of current</code> (and, because the list is sorted, current.next</code> is also not a duplicate of any other element appearing before</em> current</code>). In this case, current</code> moves forward one step to point to current.next</code>. Therefore, the condition still holds; there are no duplicates up to current</code>.</p>
</li>
</ol>
At the last iteration of the loop, current</code> must point to the last element, because afterwards, current.next = null</code>. Therefore, after the loop ends, all elements up to the last element do not contain duplicates.</p>
Analysis written by: @noran.</p>