<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-reduce-to-smaller-problem-accepted">Approach #2: Reduce to Smaller Problem [Accepted]</a></li>
<a href="#approach-3-locate-and-analyze-problem-index-accepted">Approach #3: Locate and Analyze Problem Index [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</h4>
Intuition</strong></p>
For the given array <span class="maths katex-rendered">A</mi></mtext></mrow><annotation encoding="application/x-tex">text{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A</span></span></span></span></span></span>, if we are changing at most one element <span class="maths katex-rendered">A</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i]</span></span></span></span></span></span>, we should change <span class="maths katex-rendered">A</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i]</span></span></span></span></span></span> to <span class="maths katex-rendered">A</mi>[</mi>i</mi>-</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i-1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i-1]</span></span></span></span></span></span>, as it would be guaranteed that <span class="maths katex-rendered">text{A[i-1]} ≤ text{A[i]}</span><script type="math/tex">text{A[i-1]} ≤ text{A[i]}</script></span>, and <span class="maths katex-rendered">A</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i]</span></span></span></span></span></span> would be the smallest possible to try and achieve <span class="maths katex-rendered">(text{A[i]} ≤ text{A[i+1]})</span>.</p>
Algorithm</strong></p>
For each possible change <span class="maths katex-rendered">A</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i]</span></span></span></span></span></span>, check if the sequence is monotone increasing.  We'll modify <span class="maths katex-rendered">n</mi>e</mi>w</mi></mtext></mrow><annotation encoding="application/x-tex">text{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">new</span></span></span></span></span></span>, a copy of the array <span class="maths katex-rendered">A</mi></mtext></mrow><annotation encoding="application/x-tex">text{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A</span></span></span></span></span></span>.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> checkPossibility</span>(</span>self</span>,</span> A</span>):</span>
        def</span> monotone_increasing</span>(</span>arr</span>):</span>
            for</span> i</span> in</span> range</span>(</span>len</span>(</span>arr</span>)</span> -</span> 1</span>):</span>
                if</span> arr</span>[</span>i</span>]</span> &gt;</span> arr</span>[</span>i</span>+</span>1</span>]:</span>
                    return</span> False</span>
            return</span> True</span>

        new</span> =</span> A</span>[:]</span>
        for</span> i</span> in</span> xrange</span>(</span>len</span>(</span>A</span>)):</span>
            old_ai</span> =</span> A</span>[</span>i</span>]</span>
            new</span>[</span>i</span>]</span> =</span> new</span>[</span>i</span>-</span>1</span>]</span> if</span> i</span> &gt;</span> 0</span> else</span> float</span>(</span>'-inf'</span>)</span>
            if</span> monotone_increasing</span>(</span>new</span>):</span>
                return</span> True</span>
            new</span>[</span>i</span>]</span> =</span> old_ai</span>

        return</span> False</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Let <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> be the length of the given array.  For each element <span class="maths katex-rendered">A</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i]</span></span></span></span></span></span>, we check if some sequence is monotone increasing, which takes <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> steps.  In total, this is a complexity of <span class="maths katex-rendered">O</mi>(</mo>N</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</p>
</li>

Space Complexity: To hold our array <span class="maths katex-rendered">n</mi>e</mi>w</mi></mtext></mrow><annotation encoding="application/x-tex">text{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">new</span></span></span></span></span></span>, we need <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> space.</p>
</li>
</ul>

<h4 id="approach-2-reduce-to-smaller-problem-accepted">Approach #2: Reduce to Smaller Problem [Accepted]</h4>
Intuition</strong></p>
If <span class="maths katex-rendered">(text{A[0]} ≤ text{A[1]} ≤ text{A[2]})</span>, then we may remove <span class="maths katex-rendered">A</mi>[</mi>0</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[0]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[0]</span></span></span></span></span></span> without changing the answer.  Similarly, if <span class="maths katex-rendered">(text{A}big[text{len(A)-3}big] ≤ text{A}big[text{len(A)-2}big] ≤ text{A}big[text{len(A)-1}big])</span>, we may remove <span class="maths katex-rendered">A</mi>[</mi>l</mi>e</mi>n</mi>(</mi>A</mi>)</mi>-</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[len(A)-1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[len(A)-1]</span></span></span></span></span></span> without changing the answer.</p>
If the problem is solvable, then after these removals, very few numbers will remain.</p>
Algorithm</strong></p>
Consider the interval <span class="maths katex-rendered">[</mi>i</mi>,</mi>&nbsp;</mtext>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[i, j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[i,&nbsp;j]</span></span></span></span></span></span> corresponding to the subarray <span class="maths katex-rendered">[</mo>A</mi>[</mi>i</mi>]</mi>,</mi>&nbsp;</mtext>A</mi>[</mi>i</mi>+</mi>1</mn>]</mi>,</mi>&nbsp;</mtext>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>A</mi>[</mi>j</mi>]</mi></mtext>]</mo></mrow><annotation encoding="application/x-tex">big[text{A[i], A[i+1], ..., A[j]}big]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">[</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i],&nbsp;A[i+1],&nbsp;...,&nbsp;A[j]</span></span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">]</span></span></span></span></span></span>.  When <span class="maths katex-rendered">(text{A[i]} ≤ text{A[i+1]} ≤ text{A[i+2]})</span>, we know we do not need to modify <span class="maths katex-rendered">A</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i]</span></span></span></span></span></span>, and we can consider solving the problem on the interval <span class="maths katex-rendered">[</mi>i</mi>+</mi>1</mn>,</mi>&nbsp;</mtext>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[i+1, j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[i+1,&nbsp;j]</span></span></span></span></span></span> instead.  We use a similar approach for <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>.</p>
Afterwards, with the length of the interval under consideration being <span class="maths katex-rendered">j</mi>&nbsp;</mtext>-</mi>&nbsp;</mtext>i</mi>&nbsp;</mtext>+</mi>&nbsp;</mtext>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{j - i + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.66786em;"></span><span class="strut bottom" style="height: 0.8623em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">j&nbsp;-&nbsp;i&nbsp;+&nbsp;1</span></span></span></span></span></span>, if the interval has size 2 or less, then we did not find any problem.  </p>
If our interval under consideration has 5 or more elements, then there are two disjoint problems that cannot be fixed with one replacement.  </p>
Otherwise, our problem size is now at most 4 elements, which we can easily brute force.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> checkPossibility</span>(</span>self</span>,</span> A</span>):</span>
        def</span> brute_force</span>(</span>A</span>):</span>
            #Same as in approach 1</span>

        i</span>,</span> j</span> =</span> 0</span>,</span> len</span>(</span>A</span>)</span> -</span> 1</span>
        while</span> i</span>+</span>2</span> &lt;</span> len</span>(</span>A</span>)</span> and</span> A</span>[</span>i</span>]</span> &lt;=</span> A</span>[</span>i</span>+</span>1</span>]</span> &lt;=</span> A</span>[</span>i</span>+</span>2</span>]:</span>
            i</span> +=</span> 1</span>
        while</span> j</span>-</span>2</span> &gt;=</span> 0</span> and</span> A</span>[</span>j</span>-</span>2</span>]</span> &lt;=</span> A</span>[</span>j</span>-</span>1</span>]</span> &lt;=</span> A</span>[</span>j</span>]:</span>
            j</span> -=</span> 1</span>

        if</span> j</span> -</span> i</span> +</span> 1</span> &lt;=</span> 2</span>:</span>
            return</span> True</span>
        if</span> j</span> -</span> i</span> +</span> 1</span> &gt;=</span> 5</span>:</span>
            return</span> False</span>

        return</span> brute_force</span>(</span>A</span>[</span>i</span>:</span> j</span>+</span>1</span>])</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Let <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> be the length of the given array.  Our pointers <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> move at most <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span> times.  Our brute force is constant time as there are at most 4 elements in the array.  Hence, the complexity is <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.</p>
</li>

Space Complexity:  The extra array <span class="maths katex-rendered">A</mi>[</mi>i</mi>:</mi>&nbsp;</mtext>j</mi>+</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[i: j+1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[i:&nbsp;j+1]</span></span></span></span></span></span> only has at most 4 elements, so it is constant space, and so is the space used by our auxillary brute force algorithm.  In total, the space complexity is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-3-locate-and-analyze-problem-index-accepted">Approach #3: Locate and Analyze Problem Index [Accepted]</h4>
Intuition</strong></p>
Consider all indices <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span> for which <span class="maths katex-rendered">A</mi>[</mi>p</mi>]</mi></mtext>&gt;</mo>A</mi>[</mi>p</mi>+</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p]} &gt; text{A[p+1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p]</span></span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p+1]</span></span></span></span></span></span>.  If there are zero, the answer is True</code>.  If there are 2 or more, the answer is False</code>, as more than one element of the array must be changed for <span class="maths katex-rendered">A</mi></mtext></mrow><annotation encoding="application/x-tex">text{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A</span></span></span></span></span></span> to be monotone increasing.</p>
At the problem index <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span>, we only care about the surrounding elements.  Thus, immediately the problem is reduced to a very small size that can be analyzed by casework.</p>
Algorithm</strong></p>
As before, let <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span> be the unique problem index for which <span class="maths katex-rendered">A</mi>[</mi>p</mi>]</mi></mtext>&gt;</mo>A</mi>[</mi>p</mi>+</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p]} &gt; text{A[p+1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p]</span></span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p+1]</span></span></span></span></span></span>.  If this is not unique or doesn't exist, the answer is False</code> or True</code> respectively.  We analyze the following cases:</p>

If <span class="maths katex-rendered">p</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>0</mn></mtext></mrow><annotation encoding="application/x-tex">text{p = 0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">p&nbsp;=&nbsp;0</span></span></span></span></span></span>, then we could make the array good by setting <span class="maths katex-rendered">A</mi>[</mi>p</mi>]</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>A</mi>[</mi>p</mi>+</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p] = A[p+1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p]&nbsp;=&nbsp;A[p+1]</span></span></span></span></span></span>.</li>
If <span class="maths katex-rendered">p</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>l</mi>e</mi>n</mi>(</mi>A</mi>)</mi>&nbsp;</mtext>-</mi>&nbsp;</mtext>2</mn></mtext></mrow><annotation encoding="application/x-tex">text{p = len(A) - 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">p&nbsp;=&nbsp;len(A)&nbsp;-&nbsp;2</span></span></span></span></span></span>, then we could make the array good by setting <span class="maths katex-rendered">A</mi>[</mi>p</mi>+</mi>1</mn>]</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>A</mi>[</mi>p</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p+1] = A[p]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p+1]&nbsp;=&nbsp;A[p]</span></span></span></span></span></span>.</li>
Otherwise, <span class="maths katex-rendered">A</mi>[</mi>p</mi>-</mi>1</mn>]</mi>,</mi>&nbsp;</mtext>A</mi>[</mi>p</mi>]</mi>,</mi>&nbsp;</mtext>A</mi>[</mi>p</mi>+</mi>1</mn>]</mi>,</mi>&nbsp;</mtext>A</mi>[</mi>p</mi>+</mi>2</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p-1], A[p], A[p+1], A[p+2]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p-1],&nbsp;A[p],&nbsp;A[p+1],&nbsp;A[p+2]</span></span></span></span></span></span> all exist, and:
We could change <span class="maths katex-rendered">A</mi>[</mi>p</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p]</span></span></span></span></span></span> to be between <span class="maths katex-rendered">A</mi>[</mi>p</mi>-</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p-1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p-1]</span></span></span></span></span></span> and <span class="maths katex-rendered">A</mi>[</mi>p</mi>+</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p+1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p+1]</span></span></span></span></span></span> if possible, or;</li>
We could change <span class="maths katex-rendered">A</mi>[</mi>p</mi>+</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p+1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p+1]</span></span></span></span></span></span> to be between <span class="maths katex-rendered">A</mi>[</mi>p</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p]</span></span></span></span></span></span> and <span class="maths katex-rendered">A</mi>[</mi>p</mi>+</mi>2</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[p+2]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[p+2]</span></span></span></span></span></span> if possible.</li>
</ul>
</li>
</ul>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> checkPossibility</span>(</span>self</span>,</span> A</span>):</span>
        p</span> =</span> None</span>
        for</span> i</span> in</span> xrange</span>(</span>len</span>(</span>A</span>)</span> -</span> 1</span>):</span>
            if</span> A</span>[</span>i</span>]</span> &gt;</span> A</span>[</span>i</span>+</span>1</span>]:</span>
                if</span> p</span> is</span> not</span> None</span>:</span>
                    return</span> False</span>
                p</span> =</span> i</span>

        return</span> (</span>p</span> is</span> None</span> or</span> p</span> ==</span> 0</span> or</span> p</span> ==</span> len</span>(</span>A</span>)</span>-</span>2</span> or</span>
                A</span>[</span>p</span>-</span>1</span>]</span> &lt;=</span> A</span>[</span>p</span>+</span>1</span>]</span> or</span> A</span>[</span>p</span>]</span> &lt;=</span> A</span>[</span>p</span>+</span>2</span>])</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Let <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> be the length of the given array.  We loop through the array once, so our time complexity is <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.</p>
</li>

Space Complexity:  We only use <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>, and the answer itself as the additional space.  The additional space complexity is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>