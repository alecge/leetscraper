Solution</h2>
<h4 id="approach-swap-with-next-node-accepted">Approach: Swap with Next Node [Accepted]</h4>
The usual way of deleting a node node</code> from a linked list is to modify the next</code> pointer of the node before</em> it, to point to the node after</em> it.</p>
<img src="https://leetcode.com/media/original_images/237_LinkedList.png" width="400"></p>
Since we do not have access to the node before</em> the one we want to delete, we cannot modify the next</code> pointer of that node in any way. Instead, we have to replace the value of the node we want to delete with the value in the node after it, and then delete the node after it.</p>
<img src="https://leetcode.com/media/original_images/237_LinkedList2.png" width="400"></p>
<img src="https://leetcode.com/media/original_images/237_LinkedList3.png" width="400"></p>
<img src="https://leetcode.com/media/original_images/237_LinkedList4.png" width="330"></p>
Because we know that the node we want to delete is not the tail of the list, we can guarantee that this approach is possible.</p>
Java</strong></p>
</span>public</span> void</span> deleteNode</span>(</span>ListNode</span> node</span>)</span> {</span>
    node</span>.</span>val</span> =</span> node</span>.</span>next</span>.</span>val</span>;</span>
    node</span>.</span>next</span> =</span> node</span>.</span>next</span>.</span>next</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>
Time and space complexity are both <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Analysis written by: @noran</p>