<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>
<a href="#approach-2-binary-search-tree-accepted">Approach #2 Binary Search Tree [Accepted]</a></li>
<a href="#approach-3-bit-accepted">Approach #3 BIT [Accepted]</a></li>
<a href="#approach-4-modified-merge-sort-accepted">Approach #4 Modified Merge Sort [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>
Intuition</strong></p>
Do as directed in the question. We can simply check all the pairs if they are important reverse pairs or not.</p>
Algorithm</strong></p>

Iterate over <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>i</mi>z</mi>e</mi></mtext>−</mo>1</mn></mrow><annotation encoding="application/x-tex">text{size} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.66786em;"></span><span class="strut bottom" style="height: 0.75119em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">size</span></span>−</span><span class="mord mathrm">1</span></span></span></span></span>

Iterate over <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span>

If <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mi>j</mi>]</mi></mtext>&gt;</mo>2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums[j]} &gt; 2 * text{nums[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[j]</span></span>&gt;</span><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span></span></span></span></span>, increment <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{count}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">count</span></span></span></span></span></span>
</li>
</ul>
</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>int</span> reversePairs</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    int</span> count</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> i</span>;</span> j</span>++</span>)</span> {</span>
            if</span> (</span>nums</span>[</span>j</span>]</span> &gt;</span> nums</span>[</span>i</span>]</span> *</span> 2LL</span>)</span>
                count</span>++</span>;</span>
        }</span>
    }</span>
    return</span> count</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>

We iterate over all the possible pairs wherein (<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>) in the array which is <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>
</li>
</ul>
</li>
Space complexity: <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> only constant extra space is required for <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> etc.</li>
</ul>
Trivia</strong></p>
The above code can be expressed as one-liner in Python:</p>
Python</em></p>
</span>def</span> reversePairs</span>(</span>self</span>,</span> nums</span>):</span>
  return</span> sum</span>([</span>nums</span>[</span>j</span>]</span> &gt;</span> 2</span> *</span> nums</span>[</span>i</span>]</span> for</span> i</span> in</span> range</span>(</span>len</span>(</span>nums</span>))</span> for</span> j</span> in</span> range</span>(</span>0</span> ,</span> i</span>)])</span>
</pre></div>


Herein, we iterate over all the pairs and store the boolean values for <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext>&gt;</mo>2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums[i]}&gt;2*text{nums[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span>&gt;</span><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[j]</span></span></span></span></span></span>. Finally, we count the number of <span class="maths katex-rendered">t</mi>r</mi>u</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{true}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">true</span></span></span></span></span></span> in the array and return the result.</p>

<h4 id="approach-2-binary-search-tree-accepted">Approach #2 Binary Search Tree [Accepted]</h4>
Intuition</strong></p>
In Approach #1, for each element <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>, we searched the subarray <span class="maths katex-rendered">[</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">[0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> for elements such that their value is greater than <span class="maths katex-rendered">2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">2*text{nums[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span></span></span></span></span>. In the previous approach, the search is linear. However, we need to make the process efficient. Maybe, memoization can help, but since, we need to compare the elements, we cannot find a linear DP solution.</p>
Observe that the indices of the elements in subarray <span class="maths katex-rendered">[</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">[0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> don't matter as we only require the count. So, we can sort the elements and perform binary search on the subarray. But, since the subarray keeps growing as we iterate to the next element, we need a data structure to store the previous result as well as to allow efficient searching(preferably <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>) - Binary Search Tree(BST) could be a good bet.   </p>
Refreshing BST</em></p>
BST is a rooted binary tree, wherein each node is associated with a value and has 2 distinguishable sub-trees namely <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> subtree. The left subtree contains only the nodes with lower values than the parent's value, while the right subtree conatins only the nodes with greater values than the parent's value.</p>
Voila!</em></p>
This is exactly what is required. So, if we store our elements in BST, then we can search the larger elements thus eliminating the search on smaller elements altogether.</p>
Algorithm</strong></p>
Define the <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{Node}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">Node</span></span></span></span></span></span> of BST that stores the <span class="maths katex-rendered">v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">val</span></span></span></span></span></span> and pointers to the <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">right</span></span></span></span></span></span>. We also need a count of elements(say <span class="maths katex-rendered">text{count_ge}</span><script type="math/tex">text{count_ge}</script></span>) in the subtree rooted at the current node that are greater than or equal to the current node's <span class="maths katex-rendered">v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">val</span></span></span></span></span></span>. <span class="maths katex-rendered">(text{count_ge})</span> is initialized to 1 for each node and <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span>, <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">right</span></span></span></span></span></span> pointers are set to <span class="maths katex-rendered">N</mi>U</mi>L</mi>L</mi></mtext></mrow><annotation encoding="application/x-tex">text{NULL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">NULL</span></span></span></span></span></span>.</p>
We define the <span class="maths katex-rendered">i</mi>n</mi>s</mi>e</mi>r</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{insert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.66786em;"></span><span class="strut bottom" style="height: 0.66786em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">insert</span></span></span></span></span></span> routine that recursively adds the given <span class="maths katex-rendered">v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">val</span></span></span></span></span></span> as an appropriate leaf node based on comparisons with the <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi>.</mi>v</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">Node.val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span>. Each time, the given <span class="maths katex-rendered">v</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> is smaller than <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi>.</mi>v</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">Node.val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span>, we increment the <span class="maths katex-rendered">(text{count_ge})</span> and move the <span class="maths katex-rendered">v</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> to the right subtree. While, if the <span class="maths katex-rendered">v</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> is equal to the current <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span></span>, we simply increment the <span class="maths katex-rendered">(text{count_ge})</span> and exit. While, we move to the left subtree in case <span class="maths katex-rendered">(</mo>v</mi>a</mi>l</mi></mtext>&lt;</mo>N</mi>o</mi>d</mi>e</mi>.</mi>v</mi>a</mi>l</mi></mtext>)</mo></mrow><annotation encoding="application/x-tex">(text{val}&lt;text{Node.val})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord text textstyle uncramped"><span class="mord mathrm">val</span></span>&lt;</span><span class="mord text textstyle uncramped"><span class="mord mathrm">Node.val</span></span>)</span></span></span></span></span>.</p>
We also require the <span class="maths katex-rendered">s</mi>e</mi>a</mi>r</mi>c</mi>h</mi></mrow><annotation encoding="application/x-tex">search</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">c</span><span class="mord mathit">h</span></span></span></span></span> routine that gives the count of number of elements greater than or equal to the <span class="maths katex-rendered">t</mi>a</mi>r</mi>g</mi>e</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">target</span></span></span></span></span></span>. In the <span class="maths katex-rendered">s</mi>e</mi>a</mi>r</mi>c</mi>h</mi></mtext></mrow><annotation encoding="application/x-tex">text{search}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">search</span></span></span></span></span></span> routine, if the <span class="maths katex-rendered">h</mi>e</mi>a</mi>d</mi></mrow><annotation encoding="application/x-tex">head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">d</span></span></span></span></span> is NULL, return 0. Otherwise, if <span class="maths katex-rendered">t</mi>a</mi>r</mi>g</mi>e</mi>t</mi></mtext>=</mo>=</mo>h</mi>e</mi>a</mi>d</mi>.</mi>v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{target}==text{head.val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">target</span></span>=</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">head.val</span></span></span></span></span></span>, we know the count of values greater than or equal to the <span class="maths katex-rendered">t</mi>a</mi>r</mi>g</mi>e</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">target</span></span></span></span></span></span>, hence simply return <span class="maths katex-rendered">(text{head.count_ge})</span>. In case, <span class="maths katex-rendered">t</mi>a</mi>r</mi>g</mi>e</mi>t</mi></mtext>&lt;</mo>h</mi>e</mi>a</mi>d</mi>.</mi>v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{target}&lt;text{head.val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">target</span></span>&lt;</span><span class="mord text textstyle uncramped"><span class="mord mathrm">head.val</span></span></span></span></span></span>, the ans is calculated by adding <span class="maths katex-rendered">(text{Node.count_ge})</span> and recursively calling the <span class="maths katex-rendered">s</mi>e</mi>a</mi>r</mi>c</mi>h</mi></mtext></mrow><annotation encoding="application/x-tex">text{search}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">search</span></span></span></span></span></span> routine with <span class="maths katex-rendered">h</mi>e</mi>a</mi>d</mi>.</mi>l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{head.left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">head.left</span></span></span></span></span></span>. And if <span class="maths katex-rendered">t</mi>a</mi>r</mi>g</mi>e</mi>t</mi></mtext>&gt;</mo>h</mi>e</mi>a</mi>d</mi>.</mi>v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{target}&gt;text{head.val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">target</span></span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathrm">head.val</span></span></span></span></span></span>, ans is obtained by recursively calling the <span class="maths katex-rendered">s</mi>e</mi>a</mi>r</mi>c</mi>h</mi></mtext></mrow><annotation encoding="application/x-tex">text{search}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">search</span></span></span></span></span></span> routine with <span class="maths katex-rendered">h</mi>e</mi>a</mi>d</mi>.</mi>r</mi>i</mi>g</mi>h</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{head.right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">head.right</span></span></span></span></span></span>.</p>
Now, we can get to our main logic:</p>

Iterate over <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">(</mo>s</mi>i</mi>z</mi>e</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(size-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.04398em;">z</span><span class="mord mathit">e</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span></span></span></span></span> :
Search the existing BST for <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext>∗</mo>2</mn>+</mo>1</mn></mrow><annotation encoding="application/x-tex">text{nums[i]} * 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span>∗</span><span class="mord mathrm">2</span>+</span><span class="mord mathrm">1</span></span></span></span></span> and add the result to <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{count}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">count</span></span></span></span></span></span>
</li>
Insert <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span></span></span></span></span> to the BST, hence updating the <span class="maths katex-rendered">(text{count_ge})</span> of the previous nodes</li>
</ul>
</li>
</ul>
<div class="diaporama" style="width: 1000px; height: 662px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 15</div></div></div>
C++</strong></p>
</span>class</span> Node</span> {</span>
public</span>:</span>
    Node</span> *</span>left</span>,</span> *</span>right</span>;</span>
    int</span> val</span>;</span>
    int</span> count_ge</span>;</span>
    Node</span>(</span>int</span> val</span>)</span>
    {</span>
        this</span>-&gt;</span>val</span> =</span> val</span>;</span>
        this</span>-&gt;</span>count_ge</span> =</span> 1</span>;</span>
        this</span>-&gt;</span>left</span> =</span> NULL</span>;</span>
        this</span>-&gt;</span>right</span> =</span> NULL</span>;</span>
    }</span>
};</span>

Node</span>*</span> insert</span>(</span>Node</span>*</span> head</span>,</span> int</span> val</span>)</span>
{</span>
    if</span> (</span>head</span> ==</span> NULL</span>)</span>
        return</span> new</span> Node</span>(</span>val</span>);</span>
    else</span> if</span> (</span>val</span> ==</span> head</span>-&gt;</span>val</span>)</span>
        head</span>-&gt;</span>count_ge</span>++</span>;</span>
    else</span> if</span> (</span>val</span> &lt;</span> head</span>-&gt;</span>val</span>)</span>
        head</span>-&gt;</span>left</span> =</span> insert</span>(</span>head</span>-&gt;</span>left</span>,</span> val</span>);</span>
    else</span> {</span>
        head</span>-&gt;</span>count_ge</span>++</span>;</span>
        head</span>-&gt;</span>right</span> =</span> insert</span>(</span>head</span>-&gt;</span>right</span>,</span> val</span>);</span>
    }</span>
    return</span> head</span>;</span>
}</span>

int</span> search</span>(</span>Node</span>*</span> head</span>,</span> long</span> long</span> target</span>)</span>
{</span>
    if</span> (</span>head</span> ==</span> NULL</span>)</span>
        return</span> 0</span>;</span>
    else</span> if</span> (</span>target</span> ==</span> head</span>-&gt;</span>val</span>)</span>
        return</span> head</span>-&gt;</span>count_ge</span>;</span>
    else</span> if</span> (</span>target</span> &lt;</span> head</span>-&gt;</span>val</span>)</span>
        return</span> head</span>-&gt;</span>count_ge</span> +</span> search</span>(</span>head</span>-&gt;</span>left</span>,</span> target</span>);</span>
    else</span>
        return</span> search</span>(</span>head</span>-&gt;</span>right</span>,</span> target</span>);</span>
}</span>

int</span> reversePairs</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    Node</span>*</span> head</span> =</span> NULL</span>;</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    int</span> count</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        count</span> +=</span> search</span>(</span>head</span>,</span> nums</span>[</span>i</span>]</span> *</span> 2LL</span> +</span> 1</span>);</span>
        head</span> =</span> insert</span>(</span>head</span>,</span> nums</span>[</span>i</span>]);</span>
    }</span>
    return</span> count</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>

The best case complexity for BST is <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> for search as well as insertion, wherein, the tree formed is complete binary tree</li>
Whereas, in case like [1,2,3,4,5,6,7,8,...], insertion as well as search for an element becomes <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> in time, since, the tree is skewed in only one direction, and hence, is no better than the array</li>
So, in worst case, for searching and insertion over n items, the complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>
</li>
</ul>
</li>
Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> extra space for storing the BST in <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{Node}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">Node</span></span></span></span></span></span> class.</li>
</ul>

<h4 id="approach-3-bit-accepted">Approach #3 BIT [Accepted]</h4>
Intuition</strong></p>
The problem with BST is that the tree can be skewed hence, making it <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> in complexity. So, need a data structure that remains balanced. We could either use a Red-black or AVL tree to make a balanced BST, but the implementation would be an overkill for the solution. We can use BIT (Binary Indexed Tree, also called Fenwick Tree) to ensure that the complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> with only 12-15 lines of code.</p>
BIT Overview:</em></p>
Fenwick Tree or BIT provides a way to represent an array of numbers in an array(can be visualized as tree), allowing prefix/suffix sums to be calculated efficiently(<span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>). BIT allows to update an element in <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> time.</p>
We recommend having a look at BIT from the following links before getting into details:</p>

<a href="https://www.youtube.com/watch?v=CWDQJGaN1gY">https://www.youtube.com/watch?v=CWDQJGaN1gY</a></li>
<a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/">https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/</a></li>
</ul>
So, BIT is very useful to accumulate information from front/back and hence, we can use it in the same way we used BST to get the count of elements that are greater than or equal to <span class="maths katex-rendered">2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext>+</mo>1</mn></mrow><annotation encoding="application/x-tex">2 * text{nums[i]} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span>+</span><span class="mord mathrm">1</span></span></span></span></span> in the existing tree and then adding the current element to the tree.</p>
Algorithm</strong></p>
First, lets review the BIT <span class="maths katex-rendered">q</mi>u</mi>e</mi>r</mi>y</mi></mtext></mrow><annotation encoding="application/x-tex">text{query}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">query</span></span></span></span></span></span> and <span class="maths katex-rendered">u</mi>p</mi>d</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{update}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">update</span></span></span></span></span></span> routines of BIT. According to the convention, <span class="maths katex-rendered">q</mi>u</mi>e</mi>r</mi>y</mi></mtext></mrow><annotation encoding="application/x-tex">text{query}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">query</span></span></span></span></span></span> routine goes from <span class="maths katex-rendered">i</mi>n</mi>d</mi>e</mi>x</mi></mtext></mrow><annotation encoding="application/x-tex">text{index}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">index</span></span></span></span></span></span> to <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span>, i.e., <span class="maths katex-rendered">B</mi>I</mi>T</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{BIT[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">BIT[i]</span></span></span></span></span></span> gives the sum for the range <span class="maths katex-rendered">[</mo>0</mn>,</mo>i</mi>n</mi>d</mi>e</mi>x</mi>]</mo></mrow><annotation encoding="application/x-tex">[0,index]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">x</span>]</span></span></span></span></span>, and <span class="maths katex-rendered">u</mi>p</mi>d</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{update}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">update</span></span></span></span></span></span> updates the values from current <span class="maths katex-rendered">i</mi>n</mi>d</mi>e</mi>x</mi></mtext></mrow><annotation encoding="application/x-tex">text{index}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">index</span></span></span></span></span></span> to the end of array. But, since, we require to find the numbers greater than the given index, as and when we update an index, we update all the ancestors of the node in the tree, and for <span class="maths katex-rendered">s</mi>e</mi>a</mi>r</mi>c</mi>h</mi></mtext></mrow><annotation encoding="application/x-tex">text{search}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">search</span></span></span></span></span></span>, we go from the node to the end.   </p>
The modified <span class="maths katex-rendered">u</mi>p</mi>d</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{update}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">update</span></span></span></span></span></span> algorithm is:</p>
</span>update(BIT,index, val):
  while(index&lt;0):
    BIT[index]+=val
    index-=(index&amp;(-index))
</pre></div>


Herein, we find get the next index using: <span class="maths katex-rendered">(text{index-=index&amp;(-index)})</span>, which is essentially subtracting the rightmost 1 from the <span class="maths katex-rendered">i</mi>n</mi>d</mi>e</mi>x</mi></mtext></mrow><annotation encoding="application/x-tex">text{index}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">index</span></span></span></span></span></span> binary representation. We update the previous indices since, if an element is greater than the index</p>
And the modified <span class="maths katex-rendered">q</mi>u</mi>e</mi>r</mi>y</mi></mtext></mrow><annotation encoding="application/x-tex">text{query}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">query</span></span></span></span></span></span> algorithm is:</p>
</span>query(BIT,index):
  sum=0
  while(index&lt;BIT.size):
    sum+=BIT[index]
    index+=(index&amp;(-index))
</pre></div>


Herein, we find get the next index using: <span class="maths katex-rendered">(text{index+=index&amp;(-index)})</span>. This gives the suffix sum from <span class="maths katex-rendered">i</mi>n</mi>d</mi>e</mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">x</span></span></span></span></span> to the end.</p>
So, the main idea is to count the number of elements greater than <span class="maths katex-rendered">2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">2*text{nums[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span></span></span></span></span> in range <span class="maths katex-rendered">[</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">[0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> as we iterate from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>i</mi>z</mi>e</mi>-</mi>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{size-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.66786em;"></span><span class="strut bottom" style="height: 0.66786em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">size-1</span></span></span></span></span></span>. The steps are as follows:</p>

Create a copy of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span></span></span></span></span>, say <span class="maths katex-rendered">(text{nums_copy})</span> ans sort <span class="maths katex-rendered">(text{nums_copy})</span>. This array is actually used for creating the Binary indexed tree</li>
Initialize <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mtext>=</mo>0</mn></mrow><annotation encoding="application/x-tex">text{count}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">count</span></span>=</span><span class="mord mathrm">0</span></span></span></span></span> and <span class="maths katex-rendered">B</mi>I</mi>T</mi></mtext></mrow><annotation encoding="application/x-tex">text{BIT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">BIT</span></span></span></span></span></span> array of size <span class="maths katex-rendered">s</mi>i</mi>z</mi>e</mi>(</mi>n</mi>u</mi>m</mi>s</mi>)</mi></mtext>+</mo>1</mn></mrow><annotation encoding="application/x-tex">text{size(nums)} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">size(nums)</span></span>+</span><span class="mord mathrm">1</span></span></span></span></span> to store the BIT</li>
Iterate over <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>i</mi>z</mi>e</mi>(</mi>n</mi>u</mi>m</mi>s</mi>)</mi></mtext>−</mo>1</mn></mrow><annotation encoding="application/x-tex">text{size(nums)}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">size(nums)</span></span>−</span><span class="mord mathrm">1</span></span></span></span></span> :
Search the index of element not less than <span class="maths katex-rendered">2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext>+</mo>1</mn></mrow><annotation encoding="application/x-tex">2*text{nums[i]}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span>+</span><span class="mord mathrm">1</span></span></span></span></span> in <span class="maths katex-rendered">(text{nums_copy})</span> array. <span class="maths katex-rendered">q</mi>u</mi>e</mi>r</mi>y</mi></mtext></mrow><annotation encoding="application/x-tex">text{query}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">query</span></span></span></span></span></span> the obtained index+1 in the <span class="maths katex-rendered">B</mi>I</mi>T</mi></mtext></mrow><annotation encoding="application/x-tex">text{BIT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">BIT</span></span></span></span></span></span>, and add the result to <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{count}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">count</span></span></span></span></span></span>
</li>
Search for the index of element not less than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> in <span class="maths katex-rendered">(text{nums_copy})</span>. We need to <span class="maths katex-rendered">u</mi>p</mi>d</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{update}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">update</span></span></span></span></span></span> the BIT for this index by 1. This essentially means that 1 is added to this index(or number of elements greater than this index is incremented). The effect of adding <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> to the index is passed to the ancestors as shown in <span class="maths katex-rendered">u</mi>p</mi>d</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{update}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">update</span></span></span></span></span></span> algorithm</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>void</span> update</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> BIT</span>,</span> int</span> index</span>,</span> int</span> val</span>)</span>
{</span>
    while</span> (</span>index</span> &gt;</span> 0</span>)</span> {</span>
        BIT</span>[</span>index</span>]</span> +=</span> val</span>;</span>
        index</span> -=</span> index</span> &amp;</span> (</span>-</span>index</span>);</span>
    }</span>
}</span>

int</span> query</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> BIT</span>,</span> int</span> index</span>)</span>
{</span>
    int</span> sum</span> =</span> 0</span>;</span>
    while</span> (</span>index</span> &lt;</span> BIT</span>.</span>size</span>())</span> {</span>
        sum</span> +=</span> BIT</span>[</span>index</span>];</span>
        index</span> +=</span> index</span> &amp;</span> (</span>-</span>index</span>);</span>
    }</span>
    return</span> sum</span>;</span>
}</span>
int</span> reversePairs</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    vector</span>&lt;</span>int</span>&gt;</span> nums_copy</span>(</span>nums</span>);</span>

    sort</span>(</span>nums_copy</span>.</span>begin</span>(),</span> nums_copy</span>.</span>end</span>());</span>

    vector</span>&lt;</span>int</span>&gt;</span> BITS</span>(</span>n</span> +</span> 1</span>,</span> 0</span>);</span>
    int</span> count</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        count</span> +=</span> query</span>(</span>BITS</span>,</span> lower_bound</span>(</span>nums_copy</span>.</span>begin</span>(),</span> nums_copy</span>.</span>end</span>(),</span> 2LL</span> *</span> nums</span>[</span>i</span>]</span> +</span> 1</span>)</span> -</span> nums_copy</span>.</span>begin</span>()</span> +</span> 1</span>);</span>
        update</span>(</span>BITS</span>,</span> lower_bound</span>(</span>nums_copy</span>.</span>begin</span>(),</span> nums_copy</span>.</span>end</span>(),</span> nums</span>[</span>i</span>])</span> -</span> nums_copy</span>.</span>begin</span>()</span> +</span> 1</span>,</span> 1</span>);</span>
    }</span>
    return</span> count</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>

In <span class="maths katex-rendered">q</mi>u</mi>e</mi>r</mi>y</mi></mtext></mrow><annotation encoding="application/x-tex">text{query}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">query</span></span></span></span></span></span> and <span class="maths katex-rendered">u</mi>p</mi>d</mi>a</mi>t</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{update}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">update</span></span></span></span></span></span> operations, we see that the loop iterates at most the number of bits in <span class="maths katex-rendered">i</mi>n</mi>d</mi>e</mi>x</mi></mtext></mrow><annotation encoding="application/x-tex">text{index}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">index</span></span></span></span></span></span> which can be at most <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Hence, the complexity of both the operations is <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>(Number of bits in <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is <span class="maths katex-rendered">l</mi>o</mi>g</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>)</li>
The in-built operation <span class="maths katex-rendered">(text{lower_bound})</span> is binary search hence <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</li>
We perform the operations for <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements, hence the total complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</li>
</ul>
</li>
Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Additional space for <span class="maths katex-rendered">B</mi>I</mi>T</mi>S</mi></mtext></mrow><annotation encoding="application/x-tex">text{BITS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">BITS</span></span></span></span></span></span> array</li>
</ul>

<h4 id="approach-4-modified-merge-sort-accepted">Approach #4 Modified Merge Sort [Accepted]</h4>
Intuition</strong></p>
In BIT and BST, we iterate over the array, dividing the array into 3 sections: already visited and hence added to the tree, current node and section to be visited. Another approach could be divide the problem into smaller subproblems, solving them and combining these problems to get the final result - Divide and conquer. We see that the problem has a great resemblance to the merge sort routine. The question is to find the inversions such that <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext>&gt;</mo>2</mn>∗</mo>n</mi>u</mi>m</mi>s</mi>[</mi>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums[i]}&gt;2 * text{nums[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[i]</span></span>&gt;</span><span class="mord mathrm">2</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[j]</span></span></span></span></span></span> and <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>. So, we can easily modify the merge sort to count the inversions as required.</p>
Mergesort</em></p>
Mergesort is a divide-and-conquer based sorting technique that operates in <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> time. The basic idea to divide the array into several sub-arrays until each sub-array is single element long and merging these sublists recursively that results in the final sorted array.</p>
Algorithm</strong></p>
We define <span class="maths katex-rendered">(text{mergesort_and_count})</span> routine that takes parameters an array say <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">start</span></span></span></span></span></span> and <span class="maths katex-rendered">e</mi>n</mi>d</mi></mtext></mrow><annotation encoding="application/x-tex">text{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">end</span></span></span></span></span></span> indices:</p>

If <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">start</span></span></span></span></span></span>&gt;=<span class="maths katex-rendered">e</mi>n</mi>d</mi></mtext></mrow><annotation encoding="application/x-tex">text{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">end</span></span></span></span></span></span> this implies that elements can no longer be broken further and hence we return 0</li>
Otherwise, set <span class="maths katex-rendered">m</mi>i</mi>d</mi></mtext>=</mo>(</mo>s</mi>t</mi>a</mi>r</mi>t</mi></mtext>+</mo>e</mi>n</mi>d</mi></mtext>)</mo>/</mi>2</mn></mrow><annotation encoding="application/x-tex">text{mid}=(text{start} + text{end})/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">mid</span></span>=</span>(</span><span class="mord text textstyle uncramped"><span class="mord mathrm">start</span></span>+</span><span class="mord text textstyle uncramped"><span class="mord mathrm">end</span></span>)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span>
</li>
Store <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> by recursively calling <span class="maths katex-rendered">(text{mergesort_and_count})</span> on range <span class="maths katex-rendered">[</mi>s</mi>t</mi>a</mi>r</mi>t</mi>,</mi>m</mi>i</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[start,mid]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[start,mid]</span></span></span></span></span></span> and <span class="maths katex-rendered">[</mi>m</mi>i</mi>d</mi>+</mi>1</mn>,</mi>e</mi>n</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[mid+1,end]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[mid+1,end]</span></span></span></span></span></span> and adding the results. This is the divide step on our routine, breaking it into the 2 ranges, and finding the results for each range separately</li>
Now, we that we have separately calculated the results for ranges <span class="maths katex-rendered">[</mi>s</mi>t</mi>a</mi>r</mi>t</mi>,</mi>m</mi>i</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[start,mid]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[start,mid]</span></span></span></span></span></span> and <span class="maths katex-rendered">[</mi>m</mi>i</mi>d</mi>+</mi>1</mn>,</mi>e</mi>n</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[mid+1,end]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[mid+1,end]</span></span></span></span></span></span>, but we still have to count the elements in <span class="maths katex-rendered">[</mi>s</mi>t</mi>a</mi>r</mi>t</mi>,</mi>m</mi>i</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[start,mid]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[start,mid]</span></span></span></span></span></span> that are greater than 2 * elements in <span class="maths katex-rendered">[</mi>m</mi>i</mi>d</mi>+</mi>1</mn>,</mi>e</mi>n</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[mid+1,end]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[mid+1,end]</span></span></span></span></span></span>. Count all such elements and add the result to <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{count}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">count</span></span></span></span></span></span>
</li>
Finally, <span class="maths katex-rendered">m</mi>e</mi>r</mi>g</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{merge}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">merge</span></span></span></span></span></span> the array from <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">start</span></span></span></span></span></span> to <span class="maths katex-rendered">e</mi>n</mi>d</mi></mtext></mrow><annotation encoding="application/x-tex">text{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">end</span></span></span></span></span></span>

Make 2 array : <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> from elements in range <span class="maths katex-rendered">[</mi>s</mi>t</mi>a</mi>r</mi>t</mi>,</mi>m</mi>i</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[start,mid]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[start,mid]</span></span></span></span></span></span> and <span class="maths katex-rendered">R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.00773em;">R</span></span></span></span></span> from elements in range <span class="maths katex-rendered">R</mi>[</mi>m</mi>i</mi>d</mi>+</mi>1</mn>,</mi>e</mi>n</mi>d</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{R[mid+1,end]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">R[mid+1,end]</span></span></span></span></span></span>
</li>
Keep pointers <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> to <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> and <span class="maths katex-rendered">R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.00773em;">R</span></span></span></span></span> respectively both initialized to start to the arrays</li>
Iterate over <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> from <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">start</span></span></span></span></span></span> to <span class="maths katex-rendered">e</mi>n</mi>d</mi></mtext></mrow><annotation encoding="application/x-tex">text{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">end</span></span></span></span></span></span> and set <span class="maths katex-rendered">A</mi>[</mi>k</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{A[k]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A[k]</span></span></span></span></span></span> to the smaller of <span class="maths katex-rendered">L</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{L[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">L[i]</span></span></span></span></span></span> or <span class="maths katex-rendered">R</mi>[</mi>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{R[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">R[j]</span></span></span></span></span></span> and increment the respective index</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>void</span> merge</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> A</span>,</span> int</span> start</span>,</span> int</span> mid</span>,</span> int</span> end</span>)</span>
{</span>
    int</span> n1</span> =</span> (</span>mid</span> -</span> start</span> +</span> 1</span>);</span>
    int</span> n2</span> =</span> (</span>end</span> -</span> mid</span>);</span>
    int</span> L</span>[</span>n1</span>],</span> R</span>[</span>n2</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n1</span>;</span> i</span>++</span>)</span>
        L</span>[</span>i</span>]</span> =</span> A</span>[</span>start</span> +</span> i</span>];</span>
    for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> n2</span>;</span> j</span>++</span>)</span>
        R</span>[</span>j</span>]</span> =</span> A</span>[</span>mid</span> +</span> 1</span> +</span> j</span>];</span>
    int</span> i</span> =</span> 0</span>,</span> j</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> k</span> =</span> start</span>;</span> k</span> &lt;=</span> end</span>;</span> k</span>++</span>)</span> {</span>
        if</span> (</span>j</span> &gt;=</span> n2</span> ||</span> (</span>i</span> &lt;</span> n1</span> &amp;&amp;</span> L</span>[</span>i</span>]</span> &lt;=</span> R</span>[</span>j</span>]))</span>
            A</span>[</span>k</span>]</span> =</span> L</span>[</span>i</span>++</span>];</span>
        else</span>
            A</span>[</span>k</span>]</span> =</span> R</span>[</span>j</span>++</span>];</span>
    }</span>
}</span>

int</span> mergesort_and_count</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> A</span>,</span> int</span> start</span>,</span> int</span> end</span>)</span>
{</span>
    if</span> (</span>start</span> &lt;</span> end</span>)</span> {</span>
        int</span> mid</span> =</span> (</span>start</span> +</span> end</span>)</span> /</span> 2</span>;</span>
        int</span> count</span> =</span> mergesort_and_count</span>(</span>A</span>,</span> start</span>,</span> mid</span>)</span> +</span> mergesort_and_count</span>(</span>A</span>,</span> mid</span> +</span> 1</span>,</span> end</span>);</span>
        int</span> j</span> =</span> mid</span> +</span> 1</span>;</span>
        for</span> (</span>int</span> i</span> =</span> start</span>;</span> i</span> &lt;=</span> mid</span>;</span> i</span>++</span>)</span> {</span>
            while</span> (</span>j</span> &lt;=</span> end</span> &amp;&amp;</span> A</span>[</span>i</span>]</span> &gt;</span> A</span>[</span>j</span>]</span> *</span> 2LL</span>)</span>
                j</span>++</span>;</span>
            count</span> +=</span> j</span> -</span> (</span>mid</span> +</span> 1</span>);</span>
        }</span>
        merge</span>(</span>A</span>,</span> start</span>,</span> mid</span>,</span> end</span>);</span>
        return</span> count</span>;</span>
    }</span>
    else</span>
        return</span> 0</span>;</span>
}</span>

int</span> reversePairs</span>(</span>vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    return</span> mergesort_and_count</span>(</span>nums</span>,</span> 0</span>,</span> nums</span>.</span>size</span>()</span> -</span> 1</span>);</span>
}</span>
</pre></div>


Complexity analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>

In each step we divide the array into 2 sub-arrays, and hence, the maximum times we need to divide is equal to <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</li>
Additional <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> work needs to be done to count the inversions and to merge the 2 sub-arrays after sorting. Hence total time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(n * log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</li>
</ul>
</li>
Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Additional space for storing <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> and <span class="maths katex-rendered">R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.00773em;">R</span></span></span></span></span> arrays</li>
</ul>

Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>
Shoutout to <a href="https://discuss.leetcode.com/user/fun4leetcode">@FUN4LEETCODE</a> for the brilliant post!</p>