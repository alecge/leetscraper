<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-horizontal-scanning">Approach #1 (Horizontal scanning)</a></li>
<a href="#approach-2-vertical-scanning">Approach #2 (Vertical scanning)</a></li>
<a href="#approach-3-divide-and-conquer">Approach #3 (Divide and conquer)</a></li>
<a href="#approach-4-binary-search">Approach #4  (Binary search)</a></li>
</ul>
</li>
<a href="#further-thoughts-follow-up">Further Thoughts / Follow up</a></li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-horizontal-scanning">Approach #1 (Horizontal scanning)</h4>
Intuition</strong></p>
For a start we will describe a simple way of finding the longest prefix shared by a set of strings <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1  ldots  S_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.
We will use the observation that :</p>

<span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>)</mo>=</mo>L</mi>C</mi>P</mi>(</mo>L</mi>C</mi>P</mi>(</mo>L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>,</mo>S</mi>2</mn></msub>)</mo>,</mo>S</mi>3</mn></msub>)</mo>,</mo>…</mo>S</mi>n</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1 ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),ldots S_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span>=</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span>,</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span>,</span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>
</p>
Algorithm</strong></p>
To employ this idea, the algorithm iterates through the strings <span class="maths katex-rendered">[</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>]</mo></mrow><annotation encoding="application/x-tex">[S_1  ldots  S_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>]</span></span></span></span></span>, finding at each iteration <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> the longest common prefix of strings <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>i</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1  ldots  S_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> When <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>i</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1  ldots  S_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> is an empty string, the algorithm ends. Otherwise after <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> iterations, the algorithm returns <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1  ldots  S_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</p>
<img alt="Finding the longest common prefix" src="https://leetcode.com/media/original_images/14_basic.png" width="539px"></p>
Figure 1. Finding the longest common prefix (Horizontal scanning)</em></p>
Java</strong></p>
</span>public</span> String</span> longestCommonPrefix</span>(</span>String</span>[]</span> strs</span>)</span> {</span>
    if</span> (</span>strs</span>.</span>length</span> ==</span> 0</span>)</span> return</span> ""</span>;</span>
    String</span> prefix</span> =</span> strs</span>[</span>0</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> strs</span>.</span>length</span>;</span> i</span>++)</span>
        while</span> (</span>strs</span>[</span>i</span>].</span>indexOf</span>(</span>prefix</span>)</span> !=</span> 0</span>)</span> {</span>
            prefix</span> =</span> prefix</span>.</span>substring</span>(</span>0</span>,</span> prefix</span>.</span>length</span>()</span> -</span> 1</span>);</span>
            if</span> (</span>prefix</span>.</span>isEmpty</span>())</span> return</span> ""</span>;</span>
        }</span>        
    return</span> prefix</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span> , where S is the sum of all characters in all strings.</li>
</ul>
In the worst case all <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> strings are the same. The algorithm compares the string <span class="maths katex-rendered">S</mi>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mord mathrm">1</span></span></span></span></span> with the other strings <span class="maths katex-rendered">[</mo>S</mi>2</mn></msub>…</mo>S</mi>n</mi></msub>]</mo></mrow><annotation encoding="application/x-tex">[S_2 ldots S_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>]</span></span></span></span></span> There are <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> character comparisons, where <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> is the sum of all characters in the input array.</p>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
We only used constant extra space.</li>
</ul>

<h4 id="approach-2-vertical-scanning">Approach #2 (Vertical scanning)</h4>
Algorithm</strong></p>
Imagine a very short string is at the end of the array. The above approach will still do <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.</p>
Java</strong></p>
</span>public</span> String</span> longestCommonPrefix</span>(</span>String</span>[]</span> strs</span>)</span> {</span>
    if</span> (</span>strs</span> ==</span> null</span> ||</span> strs</span>.</span>length</span> ==</span> 0</span>)</span> return</span> ""</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> strs</span>[</span>0</span>].</span>length</span>()</span> ;</span> i</span>++){</span>
        char</span> c</span> =</span> strs</span>[</span>0</span>].</span>charAt</span>(</span>i</span>);</span>
        for</span> (</span>int</span> j</span> =</span> 1</span>;</span> j</span> &lt;</span> strs</span>.</span>length</span>;</span> j</span> ++)</span> {</span>
            if</span> (</span>i</span> ==</span> strs</span>[</span>j</span>].</span>length</span>()</span> ||</span> strs</span>[</span>j</span>].</span>charAt</span>(</span>i</span>)</span> !=</span> c</span>)</span>
                return</span> strs</span>[</span>0</span>].</span>substring</span>(</span>0</span>,</span> i</span>);</span>             
        }</span>
    }</span>
    return</span> strs</span>[</span>0</span>];</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span> , where S is the sum of all characters in all strings.
In the worst case there will be <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> equal strings with length <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> and the algorithm performs  <span class="maths katex-rendered">S</mi>=</mo>m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">S = m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span>=</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> character comparisons.
Even though the worst case is still the same as Approach #1, in the best case there are at most <span class="maths katex-rendered">n</mi>∗</mo>m</mi>i</mi>n</mi>L</mi>e</mi>n</mi></mrow><annotation encoding="application/x-tex">n*minLen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>∗</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">L</span><span class="mord mathit">e</span><span class="mord mathit">n</span></span></span></span></span> comparisons where <span class="maths katex-rendered">m</mi>i</mi>n</mi>L</mi>e</mi>n</mi></mrow><annotation encoding="application/x-tex">minLen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">L</span><span class="mord mathit">e</span><span class="mord mathit">n</span></span></span></span></span> is the length of the shortest string in the array.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
We only used constant extra space.</li>
</ul>

<h4 id="approach-3-divide-and-conquer">Approach #3 (Divide and conquer)</h4>
Intuition</strong></p>
The idea of the algorithm comes from the associative property of LCP operation. We notice that :
<span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>)</mo>=</mo>L</mi>C</mi>P</mi>(</mo>L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>k</mi></msub>)</mo>,</mo>L</mi>C</mi>P</mi>(</mo>S</mi>k</mi>+</mo>1</mn></mrow></msub>…</mo>S</mi>n</mi></msub>)</mo>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1 ldots S_n) = LCP(LCP(S_1 ldots S_k), LCP (S_{k+1} ldots S_n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span>=</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span>,</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span>)</span></span></span></span></span>
, where <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_1 ldots S_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> is the longest common prefix in set of strings <span class="maths katex-rendered">[</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>]</mo></mrow><annotation encoding="application/x-tex">[S_1 ldots S_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>]</span></span></span></span></span> , <span class="maths katex-rendered">1</mn>&lt;</mo>k</mi>&lt;</mo>n</mi></mrow><annotation encoding="application/x-tex">1 &lt; k &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span>&lt;</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>&lt;</span><span class="mord mathit">n</span></span></span></span></span>
</p>
Algorithm</strong></p>
To apply the observation above, we use divide and conquer technique, where we split the <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>i</mi></msub>…</mo>S</mi>j</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_i ldots S_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> problem into two subproblems <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>i</mi></msub>…</mo>S</mi>m</mi>i</mi>d</mi></mrow></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_i ldots S_{mid})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">d</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>   and <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>m</mi>i</mi>d</mi>+</mo>1</mn></mrow></msub>…</mo>S</mi>j</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_{mid+1} ldots S_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">d</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>, where mid</code> is <span class="maths katex-rendered">i</mi>+</mo>j</mi></mrow>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">frac{i + j}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.907772em;"></span><span class="strut bottom" style="height: 1.25277em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span>. We use their solutions lcpLeft</code> and lcpRight</code> to construct the solution of the main problem <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>i</mi></msub>…</mo>S</mi>j</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_i ldots S_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. To accomplish this we compare one by one the characters of lcpLeft</code> and lcpRight</code> till there is no character match. The found common prefix of lcpLeft</code> and lcpRight</code> is the solution of the  <span class="maths katex-rendered">L</mi>C</mi>P</mi>(</mo>S</mi>i</mi></msub>…</mo>S</mi>j</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">LCP(S_i ldots S_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</p>
<img alt="Finding the longest common prefix" src="https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png" width="539px"></p>
Figure 2. Finding the longest common prefix of strings using divide and conquer technique</em></p>
Java</strong>  </p>
</span>public</span> String</span> longestCommonPrefix</span>(</span>String</span>[]</span> strs</span>)</span> {</span>
    if</span> (</span>strs</span> ==</span> null</span> ||</span> strs</span>.</span>length</span> ==</span> 0</span>)</span> return</span> ""</span>;</span>    
        return</span> longestCommonPrefix</span>(</span>strs</span>,</span> 0</span> ,</span> strs</span>.</span>length</span> -</span> 1</span>);</span>
}</span>

private</span> String</span> longestCommonPrefix</span>(</span>String</span>[]</span> strs</span>,</span> int</span> l</span>,</span> int</span> r</span>)</span> {</span>
    if</span> (</span>l</span> ==</span> r</span>)</span> {</span>
        return</span> strs</span>[</span>l</span>];</span>
    }</span>
    else</span> {</span>
        int</span> mid</span> =</span> (</span>l</span> +</span> r</span>)/</span>2</span>;</span>
        String</span> lcpLeft</span> =</span>   longestCommonPrefix</span>(</span>strs</span>,</span> l</span> ,</span> mid</span>);</span>
        String</span> lcpRight</span> =</span>  longestCommonPrefix</span>(</span>strs</span>,</span> mid</span> +</span> 1</span>,</span>r</span>);</span>
        return</span> commonPrefix</span>(</span>lcpLeft</span>,</span> lcpRight</span>);</span>
   }</span>
}</span>

String</span> commonPrefix</span>(</span>String</span> left</span>,</span>String</span> right</span>)</span> {</span>
    int</span> min</span> =</span> Math</span>.</span>min</span>(</span>left</span>.</span>length</span>(),</span> right</span>.</span>length</span>());</span>       
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> min</span>;</span> i</span>++)</span> {</span>
        if</span> (</span> left</span>.</span>charAt</span>(</span>i</span>)</span> !=</span> right</span>.</span>charAt</span>(</span>i</span>)</span> )</span>
            return</span> left</span>.</span>substring</span>(</span>0</span>,</span> i</span>);</span>
    }</span>
    return</span> left</span>.</span>substring</span>(</span>0</span>,</span> min</span>);</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>
In the worst case we have <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> equal strings with length <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>
</p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> is the number of all characters in the array, <span class="maths katex-rendered">S</mi>=</mo>m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">S = m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span>=</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span>
 Time complexity is <span class="maths katex-rendered">T</mi>(</mo>n</mi>)</mo>=</mo>2</mn>T</mi>(</mo>n</mi></mrow>2</mn></mrow></mfrac>)</mo>+</mo>O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">T(n) = 2 T(frac{n}{2}) + O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span>(</span><span class="mord mathit">n</span>)</span>=</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>(</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>)</span>+</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span>. Therefore time complexity is <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span>.
  In the best case this algorithm performs  <span class="maths katex-rendered">O</mi>(</mo>m</mi>i</mi>n</mi>L</mi>e</mi>n</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(minLen*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">L</span><span class="mord mathit">e</span><span class="mord mathit">n</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span> comparisons, where  <span class="maths katex-rendered">m</mi>i</mi>n</mi>L</mi>e</mi>n</mi></mrow><annotation encoding="application/x-tex">minLen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">L</span><span class="mord mathit">e</span><span class="mord mathit">n</span></span></span></span></span> is the shortest string of the array</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(m*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</p>
</li>
</ul>
There is a memory overhead since we store recursive calls in the execution stack. There are <span class="maths katex-rendered">l</mi>o</mi>g</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> recursive calls, each store need <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> space to store the result,  so space complexity is <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(m*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</p>

<h4 id="approach-4-binary-search">Approach #4  (Binary search)</h4>
The idea is to apply binary search method to find the string with maximum value L</code>, which is common prefix of all of the strings. The algorithm searches space is the interval <span class="maths katex-rendered">(</mo>0</mn>…</mo>m</mi>i</mi>n</mi>L</mi>e</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">(0 ldots minLen)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>…</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">L</span><span class="mord mathit">e</span><span class="mord mathit">n</span>)</span></span></span></span></span>, where minLen</code> is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:
 S[1...mid]</code> is not a common string. This means that for each j &gt; i S[1..j]</code> is not a common string and we discard the second half of the  search space.
</em> S[1...mid]</code> is common string. This means that for for each i &lt; j S[1..i]</code> is a common string and we discard the first half of the search space, because we try to find longer common prefix.</p>
<img alt="Finding the longest common prefix" src="https://leetcode.com/media/original_images/14_lcp_binary_search.png" width="539px"></p>
Figure 3. Finding the longest common prefix of strings using binary search technique</em></p>
Java</strong></p>
</span>public</span> String</span> longestCommonPrefix</span>(</span>String</span>[]</span> strs</span>)</span> {</span>
    if</span> (</span>strs</span> ==</span> null</span> ||</span> strs</span>.</span>length</span> ==</span> 0</span>)</span>
        return</span> ""</span>;</span>
    int</span> minLen</span> =</span> Integer</span>.</span>MAX_VALUE</span>;</span>
    for</span> (</span>String</span> str</span> :</span> strs</span>)</span>
        minLen</span> =</span> Math</span>.</span>min</span>(</span>minLen</span>,</span> str</span>.</span>length</span>());</span>
    int</span> low</span> =</span> 1</span>;</span>
    int</span> high</span> =</span> minLen</span>;</span>
    while</span> (</span>low</span> &lt;=</span> high</span>)</span> {</span>
        int</span> middle</span> =</span> (</span>low</span> +</span> high</span>)</span> /</span> 2</span>;</span>
        if</span> (</span>isCommonPrefix</span>(</span>strs</span>,</span> middle</span>))</span>
            low</span> =</span> middle</span> +</span> 1</span>;</span>
        else</span>
            high</span> =</span> middle</span> -</span> 1</span>;</span>
    }</span>
    return</span> strs</span>[</span>0</span>].</span>substring</span>(</span>0</span>,</span> (</span>low</span> +</span> high</span>)</span> /</span> 2</span>);</span>
}</span>

private</span> boolean</span> isCommonPrefix</span>(</span>String</span>[]</span> strs</span>,</span> int</span> len</span>){</span>
    String</span> str1</span> =</span> strs</span>[</span>0</span>].</span>substring</span>(</span>0</span>,</span>len</span>);</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> strs</span>.</span>length</span>;</span> i</span>++)</span>
        if</span> (!</span>strs</span>[</span>i</span>].</span>startsWith</span>(</span>str1</span>))</span>
            return</span> false</span>;</span>
    return</span> true</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>
In the worst case we have <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> equal strings with length <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>
</p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(S*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> is the sum of all characters in all strings.</li>
</ul>
The algorithm makes <span class="maths katex-rendered">l</mi>o</mi>g</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> iterations, for each of them there are <span class="maths katex-rendered">S</mi>=</mo>m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">S =  m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span>=</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> comparisons, which gives in total <span class="maths katex-rendered">O</mi>(</mo>S</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(S*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> time complexity.</p>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
</ul>
We only used constant extra space.</p>
<h2 id="further-thoughts-follow-up">Further Thoughts / Follow up</h2>
Let's take a look at a slightly different problem:</p>

Given a set of keys S = <span class="maths katex-rendered">[</mo>S</mi>1</mn></msub>,</mo>S</mi>2</mn></msub>…</mo>S</mi>n</mi></msub>]</mo></mrow><annotation encoding="application/x-tex">[S_1,S_2 ldots S_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>]</span></span></span></span></span>, find the longest common prefix among a string q</code> and S. This LCP query will be called frequently.</p>
</blockquote>
We could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article <a href="https://leetcode.com/articles/implement-trie-prefix-tree/">Implement a trie (Prefix trie)</a>. In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string q</code> and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:
 it is prefix of query string q</code>
</em> each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.
* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.</p>
Algorithm</strong></p>
The only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from <span class="maths katex-rendered">[</mo>S</mi>1</mn></msub>…</mo>S</mi>n</mi></msub>]</mo></mrow><annotation encoding="application/x-tex">[S_1 ldots   S_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>]</span></span></span></span></span> strings. Then find the prefix of query string q</code> in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.</p>
<img alt="Finding the longest common prefix using Trie" src="https://leetcode.com/media/original_images/14_lcp_trie.png" width="539px"></p>
Figure 4. Finding the longest common prefix of strings using Trie</em></p>
Java</strong></p>
</span>public</span> String</span> longestCommonPrefix</span>(</span>String</span> q</span>,</span> String</span>[]</span> strs</span>)</span> {</span>
    if</span> (</span>strs</span> ==</span> null</span> ||</span> strs</span>.</span>length</span> ==</span> 0</span>)</span>
         return</span> ""</span>;</span>  
    if</span> (</span>strs</span>.</span>length</span> ==</span> 1</span>)</span>
         return</span> strs</span>[</span>0</span>];</span>
    Trie</span> trie</span> =</span> new</span> Trie</span>();</span>      
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> strs</span>.</span>length</span> ;</span> i</span>++)</span> {</span>
        trie</span>.</span>insert</span>(</span>strs</span>[</span>i</span>]);</span>
    }</span>
    return</span> trie</span>.</span>searchLongestPrefix</span>(</span>q</span>);</span>
}</span>

class</span> TrieNode</span> {</span>

    // R links to node children</span>
    private</span> TrieNode</span>[]</span> links</span>;</span>

    private</span> final</span> int</span> R</span> =</span> 26</span>;</span>

    private</span> boolean</span> isEnd</span>;</span>

    // number of children non null links</span>
    private</span> int</span> size</span>;</span>    
    public</span> void</span> put</span>(</span>char</span> ch</span>,</span> TrieNode</span> node</span>)</span> {</span>
        links</span>[</span>ch</span> -</span>'a'</span>]</span> =</span> node</span>;</span>
        size</span>++;</span>
    }</span>

    public</span> int</span> getLinks</span>()</span> {</span>
        return</span> size</span>;</span>
    }</span>
    //assume methods containsKey, isEnd, get, put are implemented as it is described</span>
   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)</span>
}</span>

public</span> class</span> Trie</span> {</span>

    private</span> TrieNode</span> root</span>;</span>

    public</span> Trie</span>()</span> {</span>
        root</span> =</span> new</span> TrieNode</span>();</span>
    }</span>

//assume methods insert, search, searchPrefix are implemented as it is described</span>
//in  https://leetcode.com/articles/implement-trie-prefix-tree/)</span>
    private</span> String</span> searchLongestPrefix</span>(</span>String</span> word</span>)</span> {</span>
        TrieNode</span> node</span> =</span> root</span>;</span>
        StringBuilder</span> prefix</span> =</span> new</span> StringBuilder</span>();</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> word</span>.</span>length</span>();</span> i</span>++)</span> {</span>
            char</span> curLetter</span> =</span> word</span>.</span>charAt</span>(</span>i</span>);</span>
            if</span> (</span>node</span>.</span>containsKey</span>(</span>curLetter</span>)</span> &amp;&amp;</span> (</span>node</span>.</span>getLinks</span>()</span> ==</span> 1</span>)</span> &amp;&amp;</span> (!</span>node</span>.</span>isEnd</span>()))</span> {</span>
                prefix</span>.</span>append</span>(</span>curLetter</span>);</span>
                node</span> =</span> node</span>.</span>get</span>(</span>curLetter</span>);</span>
            }</span>
            else</span>
                return</span> prefix</span>.</span>toString</span>();</span>

         }</span>
         return</span> prefix</span>.</span>toString</span>();</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong>
In the worst case query <span class="maths katex-rendered">q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span></span></span> has length <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> and it is equal to all <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> strings of the array.</p>

Time complexity : preprocessing <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> is the number of all characters in the array, LCP query <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span>
</li>
</ul>
Trie build has <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span> time complexity. To find the common prefix of <span class="maths katex-rendered">q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span></span></span> in the Trie takes in the worst case <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span>.</p>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span>
</li>
</ul>
We only used additional  <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> extra space for the Trie.</p>
Analysis written by: @elmirap.</p>