Solution
Approach #1 Brute force [Accepted]
Intuition
According to the question, we are allowed to insert the characters only at the beginning of the string. Hence, we can find the largest segment from the beginning that is a palindrome, and we can then easily reverse the remaining segment and append to the beginning. This must be the required answer as no shorter palindrome could be found than this by just appending at the beginning.
For example: Take the string
\text{"abcbabcab"}
"abcbabcab". Here, the largest palindrome segment from beginning is
\text{"abcba"}
"abcba", and the remaining segment is
\text{"bcab"}
"bcab". Hence the required string is reverse of
\text{"bcab"}
"bcab"( =
\text{"bacb"}
"bacb") + original string( =
\text{"abcbabcab"}
"abcbabcab") =
\text{"bacbabcbabcab"}
"bacbabcbabcab".
Algorithm
Create the reverse of the original string
s
s, say
\text{rev}
rev. This is used for comparison to find the largest palindrome segment from the front.
Iterate over the variable
i
i from 0 to the
\text{size(s)}-1
size(s)−1:
If
s[0:n-i] == rev[i:]
s[0:n−i]==rev[i:] (i.e. substring of
s
s from
0
0 to
n-i
n−i is equal to the substring of
\text{rev}
rev from
i
i to the end of string). This essentially means that that substring from
0
0 to
n-i
n−i is a palindrome, as
\text{rev}
rev is the reverse of
s
s.
Since, we find the larger palindromes first, we can return reverse of largest palindrome +
s
s as soon as we get it.
C++
string shortestPalindrome(string s)
{
    int n = s.size();
    string rev(s);
    reverse(rev.begin(), rev.end());
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (s.substr(0, n - i) == rev.substr(i))
            return rev.substr(0, i) + s;
    }
    return "";
}
Complexity Analysis
Time complexity:
O(n^2)
O(n
2
).
We iterate over the entire length of string
s
s.
In each iteration, we compare the substrings which is linear in size of substrings to be compared.
Hence, the total time complexity is
O(n*n) = O(n^2)
O(n∗n)=O(n
2
).
Space complexity:
O(n)
O(n) extra space for the reverse string
\text{rev}
rev.
Approach #2 Two pointers and recursion [Accepted]
Intuition
In Approach #1, we found the largest palindrome substring from the string using substring matching which is
O(n)
O(n) in length of substring. We could make the process more efficient if we could reduce the size of string to search for the substring without checking the complete substring each time.
Lets take a string
\text{"abcbabcaba"}
"abcbabcaba". Let us consider 2 pointers
i
i and
j
j. Initialize
i = 0
i=0. Iterate over
j
j from
n-1
n−1 to
0
0, incrementing
i
i each time
\text{s[i]==s[j]}
s[i]==s[j]. Now, we just need to search in range
\text[0,i)
[0,i). This way, we have reduced the size of string to search for the largest palindrome substring from the beginning. The range
\text{[0,i)}
[0,i) must always contain the largest palindrome substring. The proof of correction is that: Say the string was a perfect palindrome,
i
i would be incremented
n
n times. Had there been other characters at the end,
i
i would still be incremented by the size of the palindrome. Hence, even though there is a chance that the range
\text{[0,i)}
[0,i) is not always tight, it is ensured that it will always contain the longest palindrome from the beginning.
The best case for the algorithm is when the entire string is palindrome and the worst case is string like
\text{"aababababababa"}
"aababababababa", wherein
i
i first becomes
12
12(check by doing on paper), and we need to recheck in [0,12) corresponding to string
\text{"aabababababa"}
"aabababababa". Again continuing in the same way, we get
{i=10}
i=10. In such a case, the string is reduced only by as few as 2 elements at each step. Hence, the number of steps in such cases is linear(
n/2
n/2).
This reduction of length could be easily done with the help of a recursive routine, as shown in the algorithm section.
Algorithm
The routine
\text{shortestPalindrome}
shortestPalindrome is recursive and takes string
s
s as parameter:
Initialize
i=0
i=0
Iterate over
j
j from
n-1
n−1 to
0
0:
If
\text{s[i]==s[j]}
s[i]==s[j], increase
i
i by
1
1
If
i
i equals the size of
s
s, the entire string is palindrome, and hence return the entire string
s
s.
Else:
Return reverse of remaining substring after
i
i to the end of string +
\text{shortestPalindrome}
shortestPalindrome routine on substring from start to index
i-1
i−1 + remaining substring after
i
i to the end of string.
C++
string shortestPalindrome(string s)
{
    int n = s.size();
    int i = 0;
    for (int j = n - 1; j >= 0; j--) {
        if (s[i] == s[j])
            i++;
    }
    if (i == n)
        return s;
    string remain_rev = s.substr(i, n);
    reverse(remain_rev.begin(), remain_rev.end());
    return remain_rev + shortestPalindrome(s.substr(0, i)) + s.substr(i);
}
Complexity analysis
Time complexity:
O(n^2)
O(n
2
).
Each iteration of
\text{shortestPalindrome}
shortestPalindrome is linear in size of substring and the maximum number of recursive calls can be
n/2
n/2 times as shown in the Intuition section.
Let the time complexity of the algorithm be T(n). Since, at the each step for the worst case, the string can be divide into 2 parts and we require only one part for further computation. Hence, the time complexity for the worst case can be represented as :
T(n)=T(n-2)+O(n)
T(n)=T(n−2)+O(n). So,
T(n) = O(n) + O(n-2) + O(n-4) + ... + O(1)
T(n)=O(n)+O(n−2)+O(n−4)+...+O(1) which is
O(n^2)
O(n
2
).
Thanks @CONOVER for the time complexity analysis.
Space complexity:
O(n)
O(n) extra space for \text{remain_rev} string.
Approach #3 KMP [Accepted]
Intuition
We have seen that the question boils down to finding the largest palindrome substring from the beginning.
The people familiar with KMP(Knuth–Morris–Pratt) algorithm may wonder that the task at hand can be easily be compared with the concept of the lookup table in KMP.
KMP Overview:
KMP is a string matching algorithm that runs in
O(n+m)
O(n+m) times, where
n
n and
m
m are sizes of the text and string to be searched respectively. The key component of KMP is the failure function lookup table,say
f(s)
f(s). The purpose of the lookup table is to store the length of the proper prefix of the string
b_{1}b_{2}...b_{s}
b
1
b
2
...b
s
that is also a suffix of
b_{1}b_{2}...b_{s}
b
1
b
2
...b
s
. This table is important because if we are trying to match a text string for
b_{1}b_{2}...b_{n}
b
1
b
2
...b
n
, and we have matched the first
s
s positions, but when we fail, then the value of lookup table for
s
s is the longest prefix of
b_{1}b_{2}...b_{n}
b
1
b
2
...b
n
that could possibly match the text string upto the point we are at. Thus, we don't need to start all over again, and can resume searching from the matching prefix.
The algorithm to generate the lookup table is easy and inutitive, as given below:
f(0) = 0
for(i = 1; i < n; i++)
{
    t = f(i-1)
    while(t > 0 && b[i] != b[t])
        t = f(t-1)
    if(b[i] == b[t]){
        ++t
    f(i) = t
}
Here, we first set f(0)=0 since, no proper prefix is available.
Next, iterate over
i
i from
1
1 to
n-1
n−1:
Set
t=f(i-1)
t=f(i−1)
While t>0 and char at
i
i doesn't match the char at
t
t position, set
t=f(t)
t=f(t), which essentially means that we have problem matching and must consider a shorter prefix, which will be
b_{f(t-1)}
b
f(t−1)
, until we find a match or t becomes 0.
If
b_{i}==b_{t}
b
i
==b
t
, add 1 to t
Set
f(i)=t
f(i)=t
The lookup table generation is as illustrated below:
Wait! I get it!!
In Approach #1, we reserved the original string
s
s and stored it as
\text{rev}
rev. We iterate over
i
i from
0
0 to
n-1
n−1 and check for
s[0:n-i] == rev[i:]
s[0:n−i]==rev[i:]. Pondering over this statement, had the
\text{rev}
rev been concatenated to
s
s, this statement is just finding the longest prefix that is equal to the suffix. Voila!
Algorithm
We use the KMP lookup table generation
Create \(\text{new_s}\) as \(s + \text{"#"} + \text{reverse(s)}\) and use the string in the lookup-generation algorithm
The "#" in the middle is required, since without the #, the 2 strings could mix with each ther, producing wrong answer. For example, take the string
\text{"aaaa"}
"aaaa". Had we not inserted "#" in the middle, the new string would be
\text{"aaaaaaaa"}
"aaaaaaaa" and the largest prefix size would be 7 corresponding to "aaaaaaa" which would be obviously wrong. Hence, a delimiter is required at the middle.
Return reversed string after the largest palindrome from beginning length(given by \(n-\text{f[n_new-1]}\)) + original string
s
s
C++
string shortestPalindrome(string s)
{
    int n = s.size();
    string rev(s);
    reverse(rev.begin(), rev.end());
    string s_new = s + "#" + rev;
    int n_new = s_new.size();
    vector<int> f(n_new, 0);
    for (int i = 1; i < n_new; i++) {
        int t = f[i - 1];
        while (t > 0 && s_new[i] != s_new[t])
            t = f[t - 1];
        if (s_new[i] == s_new[t])
            ++t;
        f[i] = t;
    }
    return rev.substr(0, n - f[n_new - 1]) + s;
}
Complexity analysis
Time complexity:
O(n)
O(n).
In every iteration of the inner while loop,
t
t decreases until it reaches 0 or until it matches. After that, it is incremented by one. Therefore, in the worst case,
t
t can only be decreased up to
n
n times and increased up to
n
n times.
Hence, the algorithm is linear with maximum
(2 * n) * 2
(2∗n)∗2 iterations.
Space complexity:
O(n)
O(n). Additional space for the reverse string and the concatenated string.
Analysis written by @abhinavbansal0.