<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>
<a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
In the brute force approach, we try to take one step in every direction and decrement the number of pending moves for each step taken. Whenever we reach out of the boundary while taking the steps, we deduce that one extra path is available to take the ball out. </p>
In order to implement the same, we make use of a recursive function findPaths(m,n,N,i,j)</code> which takes the current number of moves(<span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span>) along with the current position(<span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> as some of the parameters and returns the number of moves possible to take the ball out with the current pending moves from the current position. Now, we take a step in every direction and update the corresponding indices involved along with the current number of pending moves. </p>
Further, if we run out of moves at any moment, we return a 0 indicating that the current set of moves doesn't take the ball out of boundary.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findPaths</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> N</span>,</span> int</span> i</span>,</span> int</span> j</span>)</span> {</span>
        if</span>(</span>i</span>==</span>m</span> ||</span> j</span>==</span>n</span> ||</span> i</span>&lt;</span>0</span> ||</span>j</span>&lt;</span>0</span>)</span>
            return</span> 1</span>;</span>
        if</span>(</span>N</span>==</span>0</span>)</span>
            return</span> 0</span>;</span>
        return</span> findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>-</span>1</span>,</span>j</span>)+</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>+</span>1</span>,</span>j</span>)+</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>,</span>j</span>-</span>1</span>)+</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>,</span>j</span>+</span>1</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>4</mn>n</mi></msup>)</mo></mrow><annotation encoding="application/x-tex">O(4^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">4</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Size of recursion tree will be <span class="maths katex-rendered">4</mn>n</mi></msup></mrow><annotation encoding="application/x-tex">4^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.664392em;"></span><span class="strut bottom" style="height: 0.664392em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the number of moves allowed.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>
Algorithm</strong></p>
In the brute force approach, while going through the various branches of the recursion tree, we could reach the same position with the same number of moves left. </p>
Thus, a lot of redundant function calls are made with the same set of parameters leading to a useless increase in runtime. We can remove this redundancy by making use of a memoization array, <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">memo[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> is used to store the number of possible moves leading to a path out of the boundary if the current position is given by the indices <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> and number of moves left is <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. </p>
Thus, now if a function call with some parameters is repeated, the <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array will already contain valid values corresponding to that function call resulting in pruning of the search space.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> M</span>=</span>1000000007</span>;</span>
    public</span> int</span> findPaths</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> N</span>,</span> int</span> i</span>,</span> int</span> j</span>)</span> {</span>
        int</span>[][][]</span> memo</span>=</span>new</span> int</span>[</span>m</span>][</span>n</span>][</span>N</span>+</span>1</span>];</span>
        for</span>(</span>int</span>[][]</span> l</span>:</span>memo</span>)</span>
            for</span>(</span>int</span>[]</span> sl</span>:</span>l</span>)</span>
                Arrays</span>.</span>fill</span>(</span>sl</span>,-</span>1</span>);</span>
        return</span> findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>,</span>i</span>,</span>j</span>,</span>memo</span>);</span>
    }</span>
    public</span> int</span> findPaths</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> N</span>,</span> int</span> i</span>,</span> int</span> j</span>,</span>int</span>[][][]</span> memo</span>)</span> {</span>
        if</span>(</span>i</span>==</span>m</span> ||</span> j</span>==</span>n</span> ||</span> i</span>&lt;</span>0</span> ||</span>j</span>&lt;</span>0</span>)</span>
            return</span> 1</span>;</span>
        if</span>(</span>N</span>==</span>0</span>)</span>
            return</span> 0</span>;</span>
        if</span>(</span>memo</span>[</span>i</span>][</span>j</span>][</span>N</span>]&gt;=</span>0</span>)</span>
            return</span> memo</span>[</span>i</span>][</span>j</span>][</span>N</span>];</span>
        memo</span>[</span>i</span>][</span>j</span>][</span>N</span>]=((</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>-</span>1</span>,</span>j</span>,</span>memo</span>)+</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>+</span>1</span>,</span>j</span>,</span>memo</span>))%</span>M</span>+(</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>,</span>j</span>-</span>1</span>,</span>memo</span>)+</span>findPaths</span>(</span>m</span>,</span>n</span>,</span>N</span>-</span>1</span>,</span>i</span>,</span>j</span>+</span>1</span>,</span>memo</span>))%</span>M</span>)%</span>M</span>;</span>
        return</span> memo</span>[</span>i</span>][</span>j</span>][</span>N</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>∗</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n*N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>. We need to fill the <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array once with dimensions <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span>. Here, <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refer to the number of rows and columns of the given grid respectively. <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> refers to the total number of allowed moves.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>∗</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n*N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi>∗</mo>N</mi></mrow><annotation encoding="application/x-tex">m*n*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</h4>
Algorithm</strong></p>
The idea behind this approach is that if we can reach some position in <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves, we can reach all its adjacent positions in <span class="maths katex-rendered">x</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>+</span><span class="mord mathrm">1</span></span></span></span></span> moves. Based on this idea, we make use of a 2-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array to store the number of ways in which a particular position can be reached. <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> refers to the number of ways the position corresponding to the indices <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> can be reached given some particular number of moves.</p>
Now, if the current <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array stores the number of ways the various positions can be reached by making use of <span class="maths katex-rendered">x</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>−</span><span class="mord mathrm">1</span></span></span></span></span> moves, in order to determine the number of ways the position <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> can be reached by making use of <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves, we need to update the corresponding <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> entry as <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo>=</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo>+</mo>d</mi>p</mi>[</mo>i</mi>+</mo>1</mn>]</mo>[</mo>j</mi>]</mo>+</mo>d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>−</mo>1</mn>]</mo>+</mo>d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1][j] + dp[i+1][j] + dp[i][j-1] + dp[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> taking care of boundary conditions. This happens because we can reach the index <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> from any of the four adjacent positions and the total number of ways of reaching the index <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> in <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves is the sum of the ways of reaching the adjacent positions in <span class="maths katex-rendered">x</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>−</span><span class="mord mathrm">1</span></span></span></span></span> moves. </p>
But, if we alter the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array, now some of the entries will correspond to <span class="maths katex-rendered">x</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>−</span><span class="mord mathrm">1</span></span></span></span></span> moves and the updated ones will correspond to <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves. Thus, we need to find a way to tackle this issue. So, instead of updating the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array for the current(<span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>) moves, we make use of a temporary 2-D array <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> to store the updated results for <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves, making use of the results obtained for <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array corresponding to <span class="maths katex-rendered">x</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>−</span><span class="mord mathrm">1</span></span></span></span></span> moves. After all the entries for all the positions have been considered for <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves, we update the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array based on <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span>. Thus, <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> now contains the entries corresponding to <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> moves.</p>
Thus, we start off by considering zero move available for which we make an initial entry of <span class="maths katex-rendered">d</mi>p</mi>[</mo>x</mi>]</mo>[</mo>y</mi>]</mo>=</mo>1</mn></mrow><annotation encoding="application/x-tex">dp[x][y] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">x</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span>=</span><span class="mord mathrm">1</span></span></span></span></span>(<span class="maths katex-rendered">(</mo>x</mi>,</mo>y</mi>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">x</span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>)</span></span></span></span></span> is the initial position), since we can reach only this position in zero move. Then, we increase the number of moves to 1 and update all the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> entries appropriately. We do so for all the moves possible from 1 to N. </p>
In order to update <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span>, which indicates the total number of possible moves which lead an out of boundary path, we need to perform the update only when we reach the boundary. We update the count as <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>=</mo>c</mi>o</mi>u</mi>n</mi>t</mi>+</mo>d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">count = count + dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>=</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, where <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> corresponds to one of the boundaries. But, if <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> is simultaneously a part of multiple boundaries, we need to add the <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> factor multiple times(same as the number of boundaries to which <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> belongs).</p>
After we are done with all the <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> moves, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> gives the required result.</p>
The following animation illustrates the process:</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 7</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findPaths</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> N</span>,</span> int</span> x</span>,</span> int</span> y</span>)</span> {</span>
        int</span> M</span> =</span> 1000000000</span> +</span> 7</span>;</span>
        int</span> dp</span>[][]</span> =</span> new</span> int</span>[</span>m</span>][</span>n</span>];</span>
        dp</span>[</span>x</span>][</span>y</span>]</span> =</span> 1</span>;</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> moves</span> =</span> 1</span>;</span> moves</span> &lt;=</span> N</span>;</span> moves</span>++)</span> {</span>
            int</span>[][]</span> temp</span> =</span> new</span> int</span>[</span>m</span>][</span>n</span>];</span>
            for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> m</span>;</span> i</span>++)</span> {</span>
                for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> n</span>;</span> j</span>++)</span> {</span>
                    if</span> (</span>i</span> ==</span> m</span> -</span> 1</span>)</span>
                        count</span> =</span> (</span>count</span> +</span> dp</span>[</span>i</span>][</span>j</span>])</span> %</span> M</span>;</span>
                    if</span> (</span>j</span> ==</span> n</span> -</span> 1</span>)</span>
                        count</span> =</span> (</span>count</span> +</span> dp</span>[</span>i</span>][</span>j</span>])</span> %</span> M</span>;</span>
                    if</span> (</span>i</span> ==</span> 0</span>)</span>
                        count</span> =</span> (</span>count</span> +</span> dp</span>[</span>i</span>][</span>j</span>])</span> %</span> M</span>;</span>
                    if</span> (</span>j</span> ==</span> 0</span>)</span>
                        count</span> =</span> (</span>count</span> +</span> dp</span>[</span>i</span>][</span>j</span>])</span> %</span> M</span>;</span>
                    temp</span>[</span>i</span>][</span>j</span>]</span> =</span> (((</span>i</span> &gt;</span> 0</span> ?</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span>]</span> :</span> 0</span>)</span> +</span> (</span>i</span> &lt;</span> m</span> -</span> 1</span> ?</span> dp</span>[</span>i</span> +</span> 1</span>][</span>j</span>]</span> :</span> 0</span>))</span> %</span> M</span> +</span> ((</span>j</span> &gt;</span> 0</span> ?</span> dp</span>[</span>i</span>][</span>j</span> -</span> 1</span>]</span> :</span> 0</span>)</span> +</span> (</span>j</span> &lt;</span> n</span> -</span> 1</span> ?</span> dp</span>[</span>i</span>][</span>j</span> +</span> 1</span>]</span> :</span> 0</span>))</span> %</span> M</span>)</span> %</span> M</span>;</span>
                }</span>
            }</span>
            dp</span> =</span> temp</span>;</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>N</mi>∗</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N*m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>∗</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We need to fill the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span>$ array with dimensions <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>
<span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> times. Here <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the size of the grid and <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> refers to the number of moves available.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> are used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>