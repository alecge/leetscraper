<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-sliding-window-accepted">Approach #2 Sliding Window [Accepted]</a></li>
<a href="#approach-3-sliding-window-optimized-accepted">Approach #3 Sliding Window Optimized [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Intuition</strong></p>
Check all the substring one by one to see if it has no duplicate character.</p>
Algorithm</strong></p>
Suppose we have a function boolean allUnique(String substring)</code> which will return true if the characters in the substring are all unique, otherwise false. We can iterate through all the possible substrings of the given string s</code> and call the function allUnique</code>. If it turns out to be true, then we update our answer of the maximum length of substring without duplicate characters.</p>
Now let's fill the missing parts:</p>


To enumerate all substrings of a given string, we enumerate the start and end indices of them. Suppose the start and end indices are <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>, respectively. Then we have <span class="maths katex-rendered">0</mn>≤</mo>i</mi>&lt;</mo>j</mi>≤</mo>n</mi></mrow><annotation encoding="application/x-tex">0 leq i lt j leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span>≤</span><span class="mord mathit">i</span>&lt;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>≤</span><span class="mord mathit">n</span></span></span></span></span> (here end index <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> is exclusive by convention). Thus, using two nested loops with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from 0 to <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> from <span class="maths katex-rendered">i</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, we can enumerate all the substrings of s</code>.</p>
</li>

To check if one string has duplicate characters, we can use a set. We iterate through all the characters in the string and put them into the set</code> one by one. Before putting one character, we check if the set already contains it. If so, we return false</code>. After the loop, we return true</code>.</p>
</li>
</ol>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> lengthOfLongestSubstring</span>(</span>String</span> s</span>)</span> {</span>
        int</span> n</span> =</span> s</span>.</span>length</span>();</span>
        int</span> ans</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++)</span>
            for</span> (</span>int</span> j</span> =</span> i</span> +</span> 1</span>;</span> j</span> &lt;=</span> n</span>;</span> j</span>++)</span>
                if</span> (</span>allUnique</span>(</span>s</span>,</span> i</span>,</span> j</span>))</span> ans</span> =</span> Math</span>.</span>max</span>(</span>ans</span>,</span> j</span> -</span> i</span>);</span>
        return</span> ans</span>;</span>
    }</span>

    public</span> boolean</span> allUnique</span>(</span>String</span> s</span>,</span> int</span> start</span>,</span> int</span> end</span>)</span> {</span>
        Set</span>&lt;</span>Character</span>&gt;</span> set</span> =</span> new</span> HashSet</span>&lt;&gt;();</span>
        for</span> (</span>int</span> i</span> =</span> start</span>;</span> i</span> &lt;</span> end</span>;</span> i</span>++)</span> {</span>
            Character</span> ch</span> =</span> s</span>.</span>charAt</span>(</span>i</span>);</span>
            if</span> (</span>set</span>.</span>contains</span>(</span>ch</span>))</span> return</span> false</span>;</span>
            set</span>.</span>add</span>(</span>ch</span>);</span>
        }</span>
        return</span> true</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</li>
</ul>
To verify if characters within index range <span class="maths katex-rendered">[</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> are all unique, we need to scan all of them. Thus, it costs <span class="maths katex-rendered">O</mi>(</mo>j</mi>−</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">O(j - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>)</span></span></span></span></span> time.</p>
For a given i</code>, the sum of time costed by each <span class="maths katex-rendered">j</mi>∈</mo>[</mo>i</mi>+</mo>1</mn>,</mo>n</mi>]</mo></mrow><annotation encoding="application/x-tex">j in [i+1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>∈</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">n</span>]</span></span></span></span></span> is</p>

<p class="maths katex-rendered">∑</mo>i</mi>+</mo>1</mn></mrow>n</mi></mrow></msubsup>O</mi>(</mo>j</mi>−</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">
sum_{i+1}^{n}O(j - i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.6514em;"></span><span class="strut bottom" style="height: 2.9874em; vertical-align: -1.336em;"></span><span class="base displaystyle textstyle uncramped"><span class="mop op-limits"><span class="" style="top: 1.17767em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="" style="top: -5e-06em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -1.25001em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>)</span></span></span></span></span></p>
</p>
Thus, the sum of all the time consumption is:</p>

<p class="maths katex-rendered">O</mi>(</mo>∑</mo>i</mi>=</mo>0</mn></mrow>n</mi>−</mo>1</mn></mrow></msubsup>(</mo>∑</mo>j</mi>=</mo>i</mi>+</mo>1</mn></mrow>n</mi></mrow></msubsup>(</mo>j</mi>−</mo>i</mi>)</mo>)</mo></mrow>)</mo></mrow>=</mo>O</mi>(</mo>∑</mo>i</mi>=</mo>0</mn></mrow>n</mi>−</mo>1</mn></mrow></msubsup>(</mo>1</mn>+</mo>n</mi>−</mo>i</mi>)</mo>(</mo>n</mi>−</mo>i</mi>)</mo></mrow>2</mn></mrow></mfrac>)</mo></mrow>=</mo>O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">
Oleft(sum_{i = 0}^{n - 1}left(sum_{j = i + 1}^{n}(j - i)right)right) =
Oleft(sum_{i = 0}^{n - 1}frac{(1 + n - i)(n - i)}{2}right) =
O(n^3)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.80111em;"></span><span class="strut bottom" style="height: 3.21489em; vertical-align: -1.41378em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="minner displaystyle textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="" style="top: 1.17767em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -5e-06em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -1.25001em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="minner displaystyle textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="" style="top: 1.17767em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="" style="top: -5e-06em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -1.25001em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>)</span><span class="mclose style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size4">)</span></span></span><span class="mclose style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size4">)</span></span></span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="minner displaystyle textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="" style="top: 1.17767em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -5e-06em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -1.25001em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped">(</span><span class="mord mathrm">1</span>+</span><span class="mord mathit">n</span>−</span><span class="mord mathit">i</span>)</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathit">i</span>)</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size4">)</span></span></span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.413em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span></p>
</p>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>i</mi>n</mi>(</mo>n</mi>,</mo>m</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(min(n, m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>(</span><span class="mord mathit">n</span>,</span><span class="mord mathit">m</span>)</span>)</span></span></span></span></span>. We need <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> space for checking a substring has no duplicate characters, where <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is the size of the Set</code>. The size of the Set is upper bounded by the size of the string <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> and the size of the charset/alphabet <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>.</li>
</ul>

<h4 id="approach-2-sliding-window-accepted">Approach #2 Sliding Window [Accepted]</h4>
Algorithm</strong></p>
The naive approach is very straightforward. But it is too slow. So how can we optimize it?</p>
In the naive approaches, we repeatedly check a substring to see if it has duplicate character. But it is unnecessary. If a substring <span class="maths katex-rendered">s</mi>i</mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> from index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to <span class="maths katex-rendered">j</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">j - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span></span></span></span></span> is already checked to have no duplicate characters. We only need to check if <span class="maths katex-rendered">s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">s[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> is already in the substring <span class="maths katex-rendered">s</mi>i</mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>.</p>
To check if a character is already in the substring, we can scan the substring, which leads to an <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> algorithm. But we can do better.</p>
By using HashSet as a sliding window, checking if a character in the current can be done in <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices, i.e. <span class="maths katex-rendered">[</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> (left-closed, right-open). A sliding window is a window "slides" its two boundaries to the certain direction. For example, if we slide <span class="maths katex-rendered">[</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> to the right by <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> element, then it becomes <span class="maths katex-rendered">[</mo>i</mi>+</mo>1</mn>,</mo>j</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">[i+1, j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> (left-closed, right-open).</p>
Back to our problem. We use HashSet to store the characters in current window <span class="maths katex-rendered">[</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> (<span class="maths katex-rendered">j</mi>=</mo>i</mi></mrow><annotation encoding="application/x-tex">j = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>=</span><span class="mord mathit">i</span></span></span></span></span> initially). Then we slide the index <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> to the right. If it is not in the HashSet, we slide <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> further. Doing so until s[j] is already in the HashSet. At this point, we found the maximum size of substrings without duplicate characters start with index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>. If we do this for all <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>, we get our answer.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> lengthOfLongestSubstring</span>(</span>String</span> s</span>)</span> {</span>
        int</span> n</span> =</span> s</span>.</span>length</span>();</span>
        Set</span>&lt;</span>Character</span>&gt;</span> set</span> =</span> new</span> HashSet</span>&lt;&gt;();</span>
        int</span> ans</span> =</span> 0</span>,</span> i</span> =</span> 0</span>,</span> j</span> =</span> 0</span>;</span>
        while</span> (</span>i</span> &lt;</span> n</span> &amp;&amp;</span> j</span> &lt;</span> n</span>)</span> {</span>
            // try to extend the range [i, j]</span>
            if</span> (!</span>set</span>.</span>contains</span>(</span>s</span>.</span>charAt</span>(</span>j</span>))){</span>
                set</span>.</span>add</span>(</span>s</span>.</span>charAt</span>(</span>j</span>++));</span>
                ans</span> =</span> Math</span>.</span>max</span>(</span>ans</span>,</span> j</span> -</span> i</span>);</span>
            }</span>
            else</span> {</span>
                set</span>.</span>remove</span>(</span>s</span>.</span>charAt</span>(</span>i</span>++));</span>
            }</span>
        }</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>2</mn>n</mi>)</mo>=</mo>O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(2n) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. In the worst case each character will be visited twice by <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>i</mi>n</mi>(</mo>m</mi>,</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>(</span><span class="mord mathit">m</span>,</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>. Same as the previous approach. We need <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> space for the sliding window, where <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is the size of the Set</code>. The size of the Set is upper bounded by the size of the string <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> and the size of the charset/alphabet <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-3-sliding-window-optimized-accepted">Approach #3 Sliding Window Optimized [Accepted]</h4>
The above solution requires at most 2n steps. In fact, it could be optimized to require only n steps. Instead of using a set to tell if a character exists or not, we could define a mapping of the characters to its index. Then we can skip the characters immediately when we found a repeated character.</p>
The reason is that if <span class="maths katex-rendered">s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">s[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> have a duplicate in the range <span class="maths katex-rendered">[</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> with index <span class="maths katex-rendered">j</mi>′</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.751892em;"></span><span class="strut bottom" style="height: 0.946332em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, we don't need to increase <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> little by little. We can skip all the elements in the range <span class="maths katex-rendered">[</mo>i</mi>,</mo>j</mi>′</mi></mrow></msup>]</mo></mrow><annotation encoding="application/x-tex">[i, j']</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.751892em;"></span><span class="strut bottom" style="height: 1.00189em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>]</span></span></span></span></span> and let <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to be <span class="maths katex-rendered">j</mi>′</mi></mrow></msup>+</mo>1</mn></mrow><annotation encoding="application/x-tex">j' + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.751892em;"></span><span class="strut bottom" style="height: 0.946332em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>+</span><span class="mord mathrm">1</span></span></span></span></span> directly.</p>
Java (Using HashMap)</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> lengthOfLongestSubstring</span>(</span>String</span> s</span>)</span> {</span>
        int</span> n</span> =</span> s</span>.</span>length</span>(),</span> ans</span> =</span> 0</span>;</span>
        Map</span>&lt;</span>Character</span>,</span> Integer</span>&gt;</span> map</span> =</span> new</span> HashMap</span>&lt;&gt;();</span> // current index of character</span>
        // try to extend the range [i, j]</span>
        for</span> (</span>int</span> j</span> =</span> 0</span>,</span> i</span> =</span> 0</span>;</span> j</span> &lt;</span> n</span>;</span> j</span>++)</span> {</span>
            if</span> (</span>map</span>.</span>containsKey</span>(</span>s</span>.</span>charAt</span>(</span>j</span>)))</span> {</span>
                i</span> =</span> Math</span>.</span>max</span>(</span>map</span>.</span>get</span>(</span>s</span>.</span>charAt</span>(</span>j</span>)),</span> i</span>);</span>
            }</span>
            ans</span> =</span> Math</span>.</span>max</span>(</span>ans</span>,</span> j</span> -</span> i</span> +</span> 1</span>);</span>
            map</span>.</span>put</span>(</span>s</span>.</span>charAt</span>(</span>j</span>),</span> j</span> +</span> 1</span>);</span>
        }</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Java (Assuming ASCII 128)</strong></p>
The previous implements all have no assumption on the charset of the string s</code>.</p>
If we know that the charset is rather small, we can replace the Map</code> with an integer array as direct access table.</p>
Commonly used tables are:</p>

int[26]</code> for Letters 'a' - 'z' or 'A' - 'Z'</li>
int[128]</code> for ASCII</li>
int[256]</code> for Extended ASCII</li>
</ul>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> lengthOfLongestSubstring</span>(</span>String</span> s</span>)</span> {</span>
        int</span> n</span> =</span> s</span>.</span>length</span>(),</span> ans</span> =</span> 0</span>;</span>
        int</span>[]</span> index</span> =</span> new</span> int</span>[</span>128</span>];</span> // current index of character</span>
        // try to extend the range [i, j]</span>
        for</span> (</span>int</span> j</span> =</span> 0</span>,</span> i</span> =</span> 0</span>;</span> j</span> &lt;</span> n</span>;</span> j</span>++)</span> {</span>
            i</span> =</span> Math</span>.</span>max</span>(</span>index</span>[</span>s</span>.</span>charAt</span>(</span>j</span>)],</span> i</span>);</span>
            ans</span> =</span> Math</span>.</span>max</span>(</span>ans</span>,</span> j</span> -</span> i</span> +</span> 1</span>);</span>
            index</span>[</span>s</span>.</span>charAt</span>(</span>j</span>)]</span> =</span> j</span> +</span> 1</span>;</span>
        }</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Index <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> will iterate <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> times.</p>
</li>

Space complexity (HashMap) : <span class="maths katex-rendered">O</mi>(</mo>m</mi>i</mi>n</mi>(</mo>m</mi>,</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>(</span><span class="mord mathit">m</span>,</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>. Same as the previous approach.</p>
</li>

Space complexity (Table): <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> is the size of the charset.</p>
</li>
</ul>