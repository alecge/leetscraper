<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-accepted">Approach #1 Brute force [Accepted]</a></li>
<a href="#approach-2-two-pointers-and-recursion-accepted">Approach #2 Two pointers and recursion [Accepted]</a></li>
<a href="#approach-3-kmp-accepted">Approach #3 KMP [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-accepted">Approach #1 Brute force [Accepted]</h4>
Intuition</strong></p>
According to the question, we are allowed to insert the characters only at the beginning of the string. Hence, we can find the largest segment from the beginning that is a palindrome, and we can then easily reverse the remaining segment and append to the beginning. This must be the required answer as no shorter palindrome could be found than this by just appending at the beginning.</p>
For example: Take the string <span class="maths katex-rendered">"</mi>a</mi>b</mi>c</mi>b</mi>a</mi>b</mi>c</mi>a</mi>b</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"abcbabcab"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"abcbabcab"</span></span></span></span></span></span>. Here, the largest palindrome segment from beginning is <span class="maths katex-rendered">"</mi>a</mi>b</mi>c</mi>b</mi>a</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"abcba"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"abcba"</span></span></span></span></span></span>, and the remaining segment is <span class="maths katex-rendered">"</mi>b</mi>c</mi>a</mi>b</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"bcab"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"bcab"</span></span></span></span></span></span>. Hence the required string is reverse of <span class="maths katex-rendered">"</mi>b</mi>c</mi>a</mi>b</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"bcab"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"bcab"</span></span></span></span></span></span>( = <span class="maths katex-rendered">"</mi>b</mi>a</mi>c</mi>b</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"bacb"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"bacb"</span></span></span></span></span></span>) + original string( = <span class="maths katex-rendered">"</mi>a</mi>b</mi>c</mi>b</mi>a</mi>b</mi>c</mi>a</mi>b</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"abcbabcab"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"abcbabcab"</span></span></span></span></span></span>) = <span class="maths katex-rendered">"</mi>b</mi>a</mi>c</mi>b</mi>a</mi>b</mi>c</mi>b</mi>a</mi>b</mi>c</mi>a</mi>b</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"bacbabcbabcab"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"bacbabcbabcab"</span></span></span></span></span></span>.</p>
Algorithm</strong></p>

Create the reverse of the original string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, say <span class="maths katex-rendered">r</mi>e</mi>v</mi></mtext></mrow><annotation encoding="application/x-tex">text{rev}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">rev</span></span></span></span></span></span>. This is used for comparison to find the largest palindrome segment from the front.</li>
Iterate over the variable <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from 0 to the <span class="maths katex-rendered">s</mi>i</mi>z</mi>e</mi>(</mi>s</mi>)</mi></mtext>−</mo>1</mn></mrow><annotation encoding="application/x-tex">text{size(s)}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">size(s)</span></span>−</span><span class="mord mathrm">1</span></span></span></span></span>:
If <span class="maths katex-rendered">s</mi>[</mo>0</mn>:</mo>n</mi>−</mo>i</mi>]</mo>=</mo>=</mo>r</mi>e</mi>v</mi>[</mo>i</mi>:</mo>]</mo></mrow><annotation encoding="application/x-tex">s[0:n-i] == rev[i:]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>[</span><span class="mord mathrm">0</span>:</span><span class="mord mathit">n</span>−</span><span class="mord mathit">i</span>]</span>=</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span>[</span><span class="mord mathit">i</span>:</span>]</span></span></span></span></span> (i.e. substring of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">n</mi>−</mo>i</mi></mrow><annotation encoding="application/x-tex">n-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathit">i</span></span></span></span></span> is equal to the substring of <span class="maths katex-rendered">r</mi>e</mi>v</mi></mtext></mrow><annotation encoding="application/x-tex">text{rev}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">rev</span></span></span></span></span></span> from <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to the end of string). This essentially means that that substring from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">n</mi>−</mo>i</mi></mrow><annotation encoding="application/x-tex">n-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathit">i</span></span></span></span></span> is a palindrome, as <span class="maths katex-rendered">r</mi>e</mi>v</mi></mtext></mrow><annotation encoding="application/x-tex">text{rev}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">rev</span></span></span></span></span></span> is the reverse of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>.</li>
Since, we find the larger palindromes first, we can return reverse of largest palindrome + <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> as soon as we get it.</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>string</span> shortestPalindrome</span>(</span>string</span> s</span>)</span>
{</span>
    int</span> n</span> =</span> s</span>.</span>size</span>();</span>
    string</span> rev</span>(</span>s</span>);</span>
    reverse</span>(</span>rev</span>.</span>begin</span>(),</span> rev</span>.</span>end</span>());</span>
    int</span> j</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        if</span> (</span>s</span>.</span>substr</span>(</span>0</span>,</span> n</span> -</span> i</span>)</span> ==</span> rev</span>.</span>substr</span>(</span>i</span>))</span>
            return</span> rev</span>.</span>substr</span>(</span>0</span>,</span> i</span>)</span> +</span> s</span>;</span>
    }</span>
    return</span> ""</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</p>

We iterate over the entire length of string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>.</li>
In each iteration, we compare the substrings which is linear in size of substrings to be compared.</li>
Hence, the total time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>n</mi>)</mo>=</mo>O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n*n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit">n</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</li>
</ul>
</li>

Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> extra space for the reverse string <span class="maths katex-rendered">r</mi>e</mi>v</mi></mtext></mrow><annotation encoding="application/x-tex">text{rev}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">rev</span></span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-two-pointers-and-recursion-accepted">Approach #2 Two pointers and recursion [Accepted]</h4>
Intuition</strong></p>
In Approach #1, we found the largest palindrome substring from the string using substring matching which is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> in length of substring. We could make the process more efficient if we could reduce the size of string to search for the substring without checking the complete substring each time.</p>
Lets take a string <span class="maths katex-rendered">"</mi>a</mi>b</mi>c</mi>b</mi>a</mi>b</mi>c</mi>a</mi>b</mi>a</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"abcbabcaba"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"abcbabcaba"</span></span></span></span></span></span>. Let us consider 2 pointers <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>.
Initialize <span class="maths katex-rendered">i</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>=</span><span class="mord mathrm">0</span></span></span></span></span>. Iterate over <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> from <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span>, incrementing <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> each time <span class="maths katex-rendered">s</mi>[</mi>i</mi>]</mi>=</mi>=</mi>s</mi>[</mi>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{s[i]==s[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">s[i]==s[j]</span></span></span></span></span></span>. Now, we just need to search in range <span class="maths katex-rendered">[</mi></mtext>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">text[0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[</span></span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span>. This way, we have reduced the size of string to search for the largest palindrome substring from the beginning. The range <span class="maths katex-rendered">[</mi>0</mn>,</mi>i</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{[0,i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[0,i)</span></span></span></span></span></span> must always contain the largest palindrome substring. The proof of correction is that: Say the string was a perfect palindrome, <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> would be incremented <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> times. Had there been other characters at the end, <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> would still be incremented by the size of the palindrome. Hence, even though there is a chance that the range <span class="maths katex-rendered">[</mi>0</mn>,</mi>i</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{[0,i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[0,i)</span></span></span></span></span></span> is not always tight, it is ensured that it will always contain the longest palindrome from the beginning.  </p>
The best case for the algorithm is when the entire string is palindrome and the worst case is string like <span class="maths katex-rendered">"</mi>a</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"aababababababa"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"aababababababa"</span></span></span></span></span></span>, wherein <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> first becomes <span class="maths katex-rendered">1</mn>2</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span></span></span>(check by doing on paper), and we need to recheck in [0,12) corresponding to string <span class="maths katex-rendered">"</mi>a</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>b</mi>a</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"aabababababa"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"aabababababa"</span></span></span></span></span></span>. Again continuing in the same way, we get <span class="maths katex-rendered">i</mi>=</mo>1</mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">{i=10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">i</span>=</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span></span></span>.  In such a case, the string is reduced only by as few as 2 elements at each step. Hence, the number of steps in such cases is linear(<span class="maths katex-rendered">n</mi>/</mi>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span>).</p>
This reduction of length could be easily done with the help of a recursive routine, as shown in the algorithm section.</p>
Algorithm</strong></p>
The routine <span class="maths katex-rendered">s</mi>h</mi>o</mi>r</mi>t</mi>e</mi>s</mi>t</mi>P</mi>a</mi>l</mi>i</mi>n</mi>d</mi>r</mi>o</mi>m</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{shortestPalindrome}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">shortestPalindrome</span></span></span></span></span></span> is recursive and takes string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> as parameter:</p>

Initialize <span class="maths katex-rendered">i</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>=</span><span class="mord mathrm">0</span></span></span></span></span>
</li>
Iterate over <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> from <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span>:
If <span class="maths katex-rendered">s</mi>[</mi>i</mi>]</mi>=</mi>=</mi>s</mi>[</mi>j</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{s[i]==s[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">s[i]==s[j]</span></span></span></span></span></span>, increase <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> by <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span>
</li>
</ul>
</li>
If <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> equals the size of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, the entire string is palindrome, and hence return the entire string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>.</li>
Else:
Return reverse of remaining substring after <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to the end of string + <span class="maths katex-rendered">s</mi>h</mi>o</mi>r</mi>t</mi>e</mi>s</mi>t</mi>P</mi>a</mi>l</mi>i</mi>n</mi>d</mi>r</mi>o</mi>m</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{shortestPalindrome}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">shortestPalindrome</span></span></span></span></span></span> routine on substring from start to index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span> + remaining substring after <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to the end of string.</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>string</span> shortestPalindrome</span>(</span>string</span> s</span>)</span>
{</span>
    int</span> n</span> =</span> s</span>.</span>size</span>();</span>
    int</span> i</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> j</span> =</span> n</span> -</span> 1</span>;</span> j</span> &gt;=</span> 0</span>;</span> j</span>--</span>)</span> {</span>
        if</span> (</span>s</span>[</span>i</span>]</span> ==</span> s</span>[</span>j</span>])</span>
            i</span>++</span>;</span>
    }</span>
    if</span> (</span>i</span> ==</span> n</span>)</span>
        return</span> s</span>;</span>
    string</span> remain_rev</span> =</span> s</span>.</span>substr</span>(</span>i</span>,</span> n</span>);</span>
    reverse</span>(</span>remain_rev</span>.</span>begin</span>(),</span> remain_rev</span>.</span>end</span>());</span>
    return</span> remain_rev</span> +</span> shortestPalindrome</span>(</span>s</span>.</span>substr</span>(</span>0</span>,</span> i</span>))</span> +</span> s</span>.</span>substr</span>(</span>i</span>);</span>
}</span>
</pre></div>


Complexity analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.
Each iteration of <span class="maths katex-rendered">s</mi>h</mi>o</mi>r</mi>t</mi>e</mi>s</mi>t</mi>P</mi>a</mi>l</mi>i</mi>n</mi>d</mi>r</mi>o</mi>m</mi>e</mi></mtext></mrow><annotation encoding="application/x-tex">text{shortestPalindrome}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">shortestPalindrome</span></span></span></span></span></span> is linear in size of substring and the maximum number of recursive calls can be <span class="maths katex-rendered">n</mi>/</mi>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> times as shown in the Intuition section.</li>
Let the time complexity of the algorithm be T(n). Since, at the each step for the worst case, the string can be divide into 2 parts and we require only one part for further computation. Hence, the time complexity for the worst case can be represented as : <span class="maths katex-rendered">T</mi>(</mo>n</mi>)</mo>=</mo>T</mi>(</mo>n</mi>−</mo>2</mn>)</mo>+</mo>O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">T(n)=T(n-2)+O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span>(</span><span class="mord mathit">n</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span>)</span>+</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. So, <span class="maths katex-rendered">T</mi>(</mo>n</mi>)</mo>=</mo>O</mi>(</mo>n</mi>)</mo>+</mo>O</mi>(</mo>n</mi>−</mo>2</mn>)</mo>+</mo>O</mi>(</mo>n</mi>−</mo>4</mn>)</mo>+</mo>.</mi>.</mi>.</mi>+</mo>O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(n) + O(n-2) + O(n-4) + ... + O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span>(</span><span class="mord mathit">n</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span>+</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span>)</span>+</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">4</span>)</span>+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>+</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> which is  <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</li>
</ul>
</li>
</ul>
Thanks @CONOVER for the time complexity analysis.</p>

Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> extra space for <span class="maths katex-rendered">text{remain_rev}</span><script type="math/tex">text{remain_rev}</script></span> string.</li>
</ul>

<h4 id="approach-3-kmp-accepted">Approach #3 KMP [Accepted]</h4>
Intuition</strong></p>
We have seen that the question boils down to  finding the largest palindrome substring from the beginning.</p>
The people familiar with KMP(Knuth–Morris–Pratt) algorithm may wonder that the task at hand can be easily be compared with the concept of the lookup table in KMP.</p>
KMP Overview:</em></p>
KMP is a string matching algorithm that runs in <span class="maths katex-rendered">O</mi>(</mo>n</mi>+</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>+</span><span class="mord mathit">m</span>)</span></span></span></span></span> times, where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> and <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> are sizes of the text and string to be searched respectively. The key component of KMP is the failure function lookup table,say <span class="maths katex-rendered">f</mi>(</mo>s</mi>)</mo></mrow><annotation encoding="application/x-tex">f(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>(</span><span class="mord mathit">s</span>)</span></span></span></span></span>. The purpose of the lookup table is to store the length of the proper prefix of the string <span class="maths katex-rendered">b</mi>1</mn></mrow></msub>b</mi>2</mn></mrow></msub>.</mi>.</mi>.</mi>b</mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">b_{1}b_{2}...b_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">s</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> that is also a suffix of <span class="maths katex-rendered">b</mi>1</mn></mrow></msub>b</mi>2</mn></mrow></msub>.</mi>.</mi>.</mi>b</mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">b_{1}b_{2}...b_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">s</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>. This table is important because if we are trying to match a text string for <span class="maths katex-rendered">b</mi>1</mn></mrow></msub>b</mi>2</mn></mrow></msub>.</mi>.</mi>.</mi>b</mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">b_{1}b_{2}...b_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, and we have matched the first <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> positions, but when we fail, then the value of lookup table for <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> is the longest prefix of <span class="maths katex-rendered">b</mi>1</mn></mrow></msub>b</mi>2</mn></mrow></msub>.</mi>.</mi>.</mi>b</mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">b_{1}b_{2}...b_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> that could possibly match the text string upto the point we are at. Thus, we don't need to start all over again, and can resume searching from the matching prefix.</p>
The algorithm to generate the lookup table is easy and inutitive, as given below:</p>
</span>f(0) = 0
for(i = 1; i &lt; n; i++)
{
    t = f(i-1)
    while(t &gt; 0 &amp;&amp; b[i] != b[t])
        t = f(t-1)
    if(b[i] == b[t]){
        ++t
    f(i) = t
}
</pre></div>



Here, we first set f(0)=0 since, no proper prefix is available.</li>
Next, iterate over <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span>:
Set <span class="maths katex-rendered">t</mi>=</mo>f</mi>(</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">t=f(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span>=</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>
</li>
While t&gt;0 and char at <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> doesn't match the char at <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> position, set <span class="maths katex-rendered">t</mi>=</mo>f</mi>(</mo>t</mi>)</mo></mrow><annotation encoding="application/x-tex">t=f(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span>=</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>(</span><span class="mord mathit">t</span>)</span></span></span></span></span>, which essentially means that we have problem matching and must consider a shorter prefix, which will be <span class="maths katex-rendered">b</mi>f</mi>(</mo>t</mi>−</mo>1</mn>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">b_{f(t-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.04964em; vertical-align: -0.3552em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathit mtight">t</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span><span class="mclose mtight">)</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, until we find a match or t becomes 0.</li>
If <span class="maths katex-rendered">b</mi>i</mi></mrow></msub>=</mo>=</mo>b</mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">b_{i}==b_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>=</span>=</span><span class="mord mathit">b</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">t</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, add 1 to t</li>
Set <span class="maths katex-rendered">f</mi>(</mo>i</mi>)</mo>=</mo>t</mi></mrow><annotation encoding="application/x-tex">f(i)=t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>(</span><span class="mord mathit">i</span>)</span>=</span><span class="mord mathit">t</span></span></span></span></span>
</li>
</ul>
</li>
</ul>
The lookup table generation is as illustrated below:</p>
<img alt="KMP" src="../Figures/214/shortest_palindrome.png" width="600px"></p>
Wait! I get it!!</em></p>
In Approach #1, we reserved the original string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and stored it as <span class="maths katex-rendered">r</mi>e</mi>v</mi></mtext></mrow><annotation encoding="application/x-tex">text{rev}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">rev</span></span></span></span></span></span>. We iterate over <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> and check for <span class="maths katex-rendered">s</mi>[</mo>0</mn>:</mo>n</mi>−</mo>i</mi>]</mo>=</mo>=</mo>r</mi>e</mi>v</mi>[</mo>i</mi>:</mo>]</mo></mrow><annotation encoding="application/x-tex">s[0:n-i] == rev[i:]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>[</span><span class="mord mathrm">0</span>:</span><span class="mord mathit">n</span>−</span><span class="mord mathit">i</span>]</span>=</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span>[</span><span class="mord mathit">i</span>:</span>]</span></span></span></span></span>.
Pondering over this statement, had the <span class="maths katex-rendered">r</mi>e</mi>v</mi></mtext></mrow><annotation encoding="application/x-tex">text{rev}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">rev</span></span></span></span></span></span> been concatenated to <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, this statement is just finding the longest prefix that is equal to the suffix. Voila!</p>
Algorithm</strong></p>

We use the KMP lookup table generation</li>
Create <span class="maths katex-rendered">(text{new_s})</span> as <span class="maths katex-rendered">(s + text{"#"} + text{reverse(s)})</span> and use the string in the lookup-generation algorithm
The "#" in the middle is required, since without the #, the  2 strings could mix with each ther, producing wrong answer. For example, take the string <span class="maths katex-rendered">"</mi>a</mi>a</mi>a</mi>a</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"aaaa"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"aaaa"</span></span></span></span></span></span>. Had we not inserted "#" in the middle, the new string would be <span class="maths katex-rendered">"</mi>a</mi>a</mi>a</mi>a</mi>a</mi>a</mi>a</mi>a</mi>"</mi></mtext></mrow><annotation encoding="application/x-tex">text{"aaaaaaaa"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">"aaaaaaaa"</span></span></span></span></span></span> and the largest prefix size would be 7 corresponding to "aaaaaaa" which would be obviously wrong. Hence, a delimiter is required at the middle.</li>
</ul>
</li>
Return reversed string after the largest palindrome from beginning length(given by <span class="maths katex-rendered">(n-text{f[n_new-1]})</span>) + original string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>
</li>
</ul>
C++</strong></p>
</span>string</span> shortestPalindrome</span>(</span>string</span> s</span>)</span>
{</span>
    int</span> n</span> =</span> s</span>.</span>size</span>();</span>
    string</span> rev</span>(</span>s</span>);</span>
    reverse</span>(</span>rev</span>.</span>begin</span>(),</span> rev</span>.</span>end</span>());</span>
    string</span> s_new</span> =</span> s</span> +</span> "#"</span> +</span> rev</span>;</span>
    int</span> n_new</span> =</span> s_new</span>.</span>size</span>();</span>
    vector</span>&lt;</span>int</span>&gt;</span> f</span>(</span>n_new</span>,</span> 0</span>);</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> n_new</span>;</span> i</span>++</span>)</span> {</span>
        int</span> t</span> =</span> f</span>[</span>i</span> -</span> 1</span>];</span>
        while</span> (</span>t</span> &gt;</span> 0</span> &amp;&amp;</span> s_new</span>[</span>i</span>]</span> !=</span> s_new</span>[</span>t</span>])</span>
            t</span> =</span> f</span>[</span>t</span> -</span> 1</span>];</span>
        if</span> (</span>s_new</span>[</span>i</span>]</span> ==</span> s_new</span>[</span>t</span>])</span>
            ++</span>t</span>;</span>
        f</span>[</span>i</span>]</span> =</span> t</span>;</span>
    }</span>
    return</span> rev</span>.</span>substr</span>(</span>0</span>,</span> n</span> -</span> f</span>[</span>n_new</span> -</span> 1</span>])</span> +</span> s</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>


Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>

In every iteration of the inner while loop, <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> decreases until it reaches 0 or until it matches. After that, it is incremented by one. Therefore, in the worst case, <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> can only be decreased up to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> times and increased up to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> times.</li>
Hence, the algorithm is linear with maximum <span class="maths katex-rendered">(</mo>2</mn>∗</mo>n</mi>)</mo>∗</mo>2</mn></mrow><annotation encoding="application/x-tex">(2 * n) * 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">2</span>∗</span><span class="mord mathit">n</span>)</span>∗</span><span class="mord mathrm">2</span></span></span></span></span> iterations.</li>
</ul>
</li>

Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Additional space for the reverse string and the concatenated string.</p>
</li>
</ul>

Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>