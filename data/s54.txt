<div class="toc hide">

<a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>
<a href="#approach-2-layer-by-layer-accepted">Approach #2: Layer-by-Layer [Accepted]</a></li>
</ul>
</div>
<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>
Intuition</strong></p>
Draw the path that the spiral makes.  We know that the path should turn clockwise whenever it would go out of bounds or into a cell that was previously visited.</p>
Algorithm</strong></p>
Let the array have <span class="maths katex-rendered">R</mi></mtext></mrow><annotation encoding="application/x-tex">text{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">R</span></span></span></span></span></span> rows and <span class="maths katex-rendered">C</mi></mtext></mrow><annotation encoding="application/x-tex">text{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">C</span></span></span></span></span></span> columns.  <span class="maths katex-rendered">s</mi>e</mi>e</mi>n</mi>[</mi>r</mi>]</mi>[</mi>c</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{seen[r][c]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">seen[r][c]</span></span></span></span></span></span> denotes that the cell on the<span class="maths katex-rendered">r</mi></mtext></mrow><annotation encoding="application/x-tex">text{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">r</span></span></span></span></span></span>-th row and <span class="maths katex-rendered">c</mi></mtext></mrow><annotation encoding="application/x-tex">text{c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">c</span></span></span></span></span></span>-th column was previously visited.  Our current position is <span class="maths katex-rendered">(</mi>r</mi>,</mi>&nbsp;</mtext>c</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(r, c)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(r,&nbsp;c)</span></span></span></span></span></span>, facing direction <span class="maths katex-rendered">d</mi>i</mi></mtext></mrow><annotation encoding="application/x-tex">text{di}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">di</span></span></span></span></span></span>, and we want to visit <span class="maths katex-rendered">R</mi></mtext></mrow><annotation encoding="application/x-tex">text{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">R</span></span></span></span></span></span> x <span class="maths katex-rendered">C</mi></mtext></mrow><annotation encoding="application/x-tex">text{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">C</span></span></span></span></span></span> total cells.</p>
As we move through the matrix, our candidate next position is <span class="maths katex-rendered">(</mi>c</mi>r</mi>,</mi>&nbsp;</mtext>c</mi>c</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(cr, cc)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(cr,&nbsp;cc)</span></span></span></span></span></span>.  If the candidate is in the bounds of the matrix and unseen, then it becomes our next position; otherwise, our next position is the one after performing a clockwise turn.</p>
Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> List</span>&lt;</span>Integer</span>&gt;</span> spiralOrder</span>(</span>int</span>[][]</span> matrix</span>)</span> {</span>
        List</span> ans</span> =</span> new</span> ArrayList</span>();</span>
        if</span> (</span>matrix</span>.</span>length</span> ==</span> 0</span>)</span> return</span> ans</span>;</span>
        int</span> R</span> =</span> matrix</span>.</span>length</span>,</span> C</span> =</span> matrix</span>[</span>0</span>].</span>length</span>;</span>
        boolean</span>[][]</span> seen</span> =</span> new</span> boolean</span>[</span>R</span>][</span>C</span>];</span>
        int</span>[]</span> dr</span> =</span> {</span>0</span>,</span> 1</span>,</span> 0</span>,</span> -</span>1</span>};</span>
        int</span>[]</span> dc</span> =</span> {</span>1</span>,</span> 0</span>,</span> -</span>1</span>,</span> 0</span>};</span>
        int</span> r</span> =</span> 0</span>,</span> c</span> =</span> 0</span>,</span> di</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> R</span> *</span> C</span>;</span> i</span>++)</span> {</span>
            ans</span>.</span>add</span>(</span>matrix</span>[</span>r</span>][</span>c</span>]);</span>
            seen</span>[</span>r</span>][</span>c</span>]</span> =</span> true</span>;</span>
            int</span> cr</span> =</span> r</span> +</span> dr</span>[</span>di</span>];</span>
            int</span> cc</span> =</span> c</span> +</span> dc</span>[</span>di</span>];</span>
            if</span> (</span>0</span> &lt;=</span> cr</span> &amp;&amp;</span> cr</span> &lt;</span> R</span> &amp;&amp;</span> 0</span> &lt;=</span> cc</span> &amp;&amp;</span> cc</span> &lt;</span> C</span> &amp;&amp;</span> !</span>seen</span>[</span>cr</span>][</span>cc</span>]){</span>
                r</span> =</span> cr</span>;</span>
                c</span> =</span> cc</span>;</span>
            }</span> else</span> {</span>
                di</span> =</span> (</span>di</span> +</span> 1</span>)</span> %</span> 4</span>;</span>
                r</span> +=</span> dr</span>[</span>di</span>];</span>
                c</span> +=</span> dc</span>[</span>di</span>];</span>
            }</span>
        }</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> spiralOrder</span>(</span>self</span>,</span> matrix</span>):</span>
        if</span> not</span> matrix</span>:</span> return</span> []</span>
        R</span>,</span> C</span> =</span> len</span>(</span>matrix</span>),</span> len</span>(</span>matrix</span>[</span>0</span>])</span>
        seen</span> =</span> [[</span>False</span>]</span> *</span> C</span> for</span> _</span> in</span> matrix</span>]</span>
        ans</span> =</span> []</span>
        dr</span> =</span> [</span>0</span>,</span> 1</span>,</span> 0</span>,</span> -</span>1</span>]</span>
        dc</span> =</span> [</span>1</span>,</span> 0</span>,</span> -</span>1</span>,</span> 0</span>]</span>
        r</span> =</span> c</span> =</span> di</span> =</span> 0</span>
        for</span> _</span> in</span> range</span>(</span>R</span> *</span> C</span>):</span>
            ans</span>.</span>append</span>(</span>matrix</span>[</span>r</span>][</span>c</span>])</span>
            seen</span>[</span>r</span>][</span>c</span>]</span> =</span> True</span>
            cr</span>,</span> cc</span> =</span> r</span> +</span> dr</span>[</span>di</span>],</span> c</span> +</span> dc</span>[</span>di</span>]</span>
            if</span> 0</span> &lt;=</span> cr</span> &lt;</span> R</span> and</span> 0</span> &lt;=</span> cc</span> &lt;</span> C</span> and</span> not</span> seen</span>[</span>cr</span>][</span>cc</span>]:</span>
                r</span>,</span> c</span> =</span> cr</span>,</span> cc</span>
            else</span>:</span>
                di</span> =</span> (</span>di</span> +</span> 1</span>)</span> %</span> 4</span>
                r</span>,</span> c</span> =</span> r</span> +</span> dr</span>[</span>di</span>],</span> c</span> +</span> dc</span>[</span>di</span>]</span>
        return</span> ans</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the total number of elements in the input matrix.  We add every element in the matrix to our final answer.</p>
</li>

Space Complexity: <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>, the information stored in seen</code> and in ans</code>.</p>
</li>
</ul>

<h4 id="approach-2-layer-by-layer-accepted">Approach #2: Layer-by-Layer [Accepted]</h4>
Intuition</strong></p>
The answer will be all the elements in clockwise order from the first-outer layer, followed by the elements from the second-outer layer, and so on.</p>
Algorithm</strong></p>
We define the <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span>-th outer layer of a matrix as all elements that have minimum distance to some border equal to <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span>.  For example, the following matrix has all elements in the first-outer layer equal to 1, all elements in the second-outer layer equal to 2, and all elements in the third-outer layer equal to 3.</p>
</span>[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
</pre></div>


For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner.  Suppose the current outer layer has top-left coordinates <span class="maths katex-rendered">(</mi>r</mi>1</mn>,</mi>&nbsp;</mtext>c</mi>1</mn>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(r1, c1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(r1,&nbsp;c1)</span></span></span></span></span></span> and bottom-right coordinates <span class="maths katex-rendered">(</mi>r</mi>2</mn>,</mi>&nbsp;</mtext>c</mi>2</mn>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(r2, c2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(r2,&nbsp;c2)</span></span></span></span></span></span>.</p>
Then, the top row is the set of elements <span class="maths katex-rendered">(</mi>r</mi>1</mn>,</mi>&nbsp;</mtext>c</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(r1, c)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(r1,&nbsp;c)</span></span></span></span></span></span> for <span class="maths katex-rendered">c</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>c</mi>1</mn>,</mi>.</mi>.</mi>.</mi>,</mi>c</mi>2</mn></mtext></mrow><annotation encoding="application/x-tex">text{c = c1,...,c2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">c&nbsp;=&nbsp;c1,...,c2</span></span></span></span></span></span>, in that order.  The rest of the right side is the set of elements <span class="maths katex-rendered">(</mi>r</mi>,</mi>&nbsp;</mtext>c</mi>2</mn>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(r, c2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(r,&nbsp;c2)</span></span></span></span></span></span> for <span class="maths katex-rendered">r</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>r</mi>1</mn>+</mi>1</mn>,</mi>.</mi>.</mi>.</mi>,</mi>r</mi>2</mn></mtext></mrow><annotation encoding="application/x-tex">text{r = r1+1,...,r2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">r&nbsp;=&nbsp;r1+1,...,r2</span></span></span></span></span></span>, in that order.  Then, if there are four sides to this layer (ie., <span class="maths katex-rendered">text{r1 &lt; r2}</span><script type="math/tex">text{r1 < r2}</script></span> and <span class="maths katex-rendered">(text{c1 &lt; c2})</span>), we iterate through the bottom side and left side as shown in the solutions below.</p>
<img alt="SpiralMatrix" src="../Figures/54_spiralmatrix.png"></p>
Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> List</span> &lt;</span> Integer</span> &gt;</span> spiralOrder</span>(</span>int</span>[][]</span> matrix</span>)</span> {</span>
        List</span> ans</span> =</span> new</span> ArrayList</span>();</span>
        if</span> (</span>matrix</span>.</span>length</span> ==</span> 0</span>)</span>
            return</span> ans</span>;</span>
        int</span> r1</span> =</span> 0</span>,</span> r2</span> =</span> matrix</span>.</span>length</span> -</span> 1</span>;</span>
        int</span> c1</span> =</span> 0</span>,</span> c2</span> =</span> matrix</span>[</span>0</span>].</span>length</span> -</span> 1</span>;</span>
        while</span> (</span>r1</span> &lt;=</span> r2</span> &amp;&amp;</span> c1</span> &lt;=</span> c2</span>)</span> {</span>
            for</span> (</span>int</span> c</span> =</span> c1</span>;</span> c</span> &lt;=</span> c2</span>;</span> c</span>++)</span> ans</span>.</span>add</span>(</span>matrix</span>[</span>r1</span>][</span>c</span>]);</span>
            for</span> (</span>int</span> r</span> =</span> r1</span> +</span> 1</span>;</span> r</span> &lt;=</span> r2</span>;</span> r</span>++)</span> ans</span>.</span>add</span>(</span>matrix</span>[</span>r</span>][</span>c2</span>]);</span>
            if</span> (</span>r1</span> &lt;</span> r2</span> &amp;&amp;</span> c1</span> &lt;</span> c2</span>)</span> {</span>
                for</span> (</span>int</span> c</span> =</span> c2</span> -</span> 1</span>;</span> c</span> &gt;</span> c1</span>;</span> c</span>--)</span> ans</span>.</span>add</span>(</span>matrix</span>[</span>r2</span>][</span>c</span>]);</span>
                for</span> (</span>int</span> r</span> =</span> r2</span>;</span> r</span> &gt;</span> r1</span>;</span> r</span>--)</span> ans</span>.</span>add</span>(</span>matrix</span>[</span>r</span>][</span>c1</span>]);</span>
            }</span>
            r1</span>++;</span>
            r2</span>--;</span>
            c1</span>++;</span>
            c2</span>--;</span>
        }</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> spiralOrder</span>(</span>self</span>,</span> matrix</span>):</span>
        def</span> spiral_coords</span>(</span>r1</span>,</span> c1</span>,</span> r2</span>,</span> c2</span>):</span>
            for</span> c</span> in</span> range</span>(</span>c1</span>,</span> c2</span> +</span> 1</span>):</span>
                yield</span> r1</span>,</span> c</span>
            for</span> r</span> in</span> range</span>(</span>r1</span> +</span> 1</span>,</span> r2</span> +</span> 1</span>):</span>
                yield</span> r</span>,</span> c2</span>
            if</span> r1</span> &lt;</span> r2</span> and</span> c1</span> &lt;</span> c2</span>:</span>
                for</span> c</span> in</span> range</span>(</span>c2</span> -</span> 1</span>,</span> c1</span>,</span> -</span>1</span>):</span>
                    yield</span> r2</span>,</span> c</span>
                for</span> r</span> in</span> range</span>(</span>r2</span>,</span> r1</span>,</span> -</span>1</span>):</span>
                    yield</span> r</span>,</span> c1</span>

        if</span> not</span> matrix</span>:</span> return</span> []</span>
        ans</span> =</span> []</span>
        r1</span>,</span> r2</span> =</span> 0</span>,</span> len</span>(</span>matrix</span>)</span> -</span> 1</span>
        c1</span>,</span> c2</span> =</span> 0</span>,</span> len</span>(</span>matrix</span>[</span>0</span>])</span> -</span> 1</span>
        while</span> r1</span> &lt;=</span> r2</span> and</span> c1</span> &lt;=</span> c2</span>:</span>
            for</span> r</span>,</span> c</span> in</span> spiral_coords</span>(</span>r1</span>,</span> c1</span>,</span> r2</span>,</span> c2</span>):</span>
                ans</span>.</span>append</span>(</span>matrix</span>[</span>r</span>][</span>c</span>])</span>
            r1</span> +=</span> 1</span>;</span> r2</span> -=</span> 1</span>
            c1</span> +=</span> 1</span>;</span> c2</span> -=</span> 1</span>
        return</span> ans</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the total number of elements in the input matrix.  We add every element in the matrix to our final answer.</p>
</li>

Space Complexity: <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>, the information stored in ans</code>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>