<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>
<a href="#approach-3-searching-intervals-accepted">Approach #3 Searching Intervals [Accepted]</a></li>
<a href="#approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</a></li>
<a href="#approach-5-using-binary-search-accepted">Approach #5 Using Binary Search [Accepted]:</a></li>
<a href="#approach-6-using-array-as-a-stackaccepted">Approach #6 Using Array as a stack[Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
The simplest solution is to consider every triplet <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>,</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">(i, j, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> and check if the corresponding numbers satisfy the 132 criteria. If any such triplet is found, we can return a True value. If no such triplet is found, we need to return a False value.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> find132pattern</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span> -</span> 2</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> i</span> +</span> 1</span>;</span> j</span> &lt;</span> nums</span>.</span>length</span> -</span> 1</span>;</span> j</span>++)</span> {</span>
                for</span> (</span>int</span> k</span> =</span> j</span> +</span> 1</span>;</span> k</span> &lt;</span> nums</span>.</span>length</span>;</span> k</span>++)</span> {</span>
                    if</span> (</span>nums</span>[</span>k</span>]</span> &gt;</span> nums</span>[</span>i</span>]</span> &amp;&amp;</span> nums</span>[</span>j</span>]</span> &gt;</span> nums</span>[</span>k</span>])</span>
                        return</span> true</span>;</span>
                }</span>
            }</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Three loops are used to consider every possible triplet. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the size of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant extra space is used.</p>
</li>
</ul>

<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>
Algorithm</strong></p>
We can improve the last approach to some extent, if we make use of some observations. We can note that for a particular number <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> chosen as 2nd element in the 132 pattern, if we don't consider <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>(the 3rd element) for the time being, our job is to find out the first element, <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>(<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>) which is lesser than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. </p>
Now, assume that we have somehow found a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> pair. Our task now reduces to finding out a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>(<span class="maths katex-rendered">K</mi>k</mi>&gt;</mo>j</mi>&gt;</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">Kk&gt;j&gt;i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">K</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>&gt;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>&gt;</span><span class="mord mathit">i</span>)</span></span></span></span></span>, which falls in the range <span class="maths katex-rendered">(</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>)</mo></mrow><annotation encoding="application/x-tex">(nums[i], nums[j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>)</span></span></span></span></span>. Now, to maximize the likelihood of a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> falling in this range, we need to increase this range as much as possible. </p>
Since, we started off by fixing a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, the only option in our hand is to choose a minimum value of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> given a particular <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Once, this pair <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, has been found out, we simply need to traverse beyond the index <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> to find if a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> exists for this pair satisfying the 132 criteria.</p>
Based on the above observations, while traversing over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array choosing various values of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, we simultaneously keep a track of the minimum element found so far(excluding <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>). This minimum element always serves as the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> for the current <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Thus, we only need to traverse beyond the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index to check the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>'s to determine if any of them satisfies the 132 criteria.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> find132pattern</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> min_i</span> =</span> Integer</span>.</span>MAX_VALUE</span>;</span>
        for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> nums</span>.</span>length</span> -</span> 1</span>;</span> j</span>++)</span> {</span>
            min_i</span> =</span> Math</span>.</span>min</span>(</span>min_i</span>,</span> nums</span>[</span>j</span>]);</span>
            for</span> (</span>int</span> k</span> =</span> j</span> +</span> 1</span>;</span> k</span> &lt;</span> nums</span>.</span>length</span>;</span> k</span>++)</span> {</span>
                if</span> (</span>nums</span>[</span>k</span>]</span> &lt;</span> nums</span>[</span>j</span>]</span> &amp;&amp;</span> min_i</span> &lt;</span> nums</span>[</span>k</span>])</span>
                    return</span> true</span>;</span>
            }</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Two loops are used to find the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j],nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> pairs. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the size of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant extra space is used.</p>
</li>
</ul>

<h4 id="approach-3-searching-intervals-accepted">Approach #3 Searching Intervals [Accepted]</h4>
Algorithm</strong></p>
As discussed in the last approach, once we've fixed a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> pair, we just need to determine a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> which falls in the range <span class="maths katex-rendered">(</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>)</mo></mrow><annotation encoding="application/x-tex">(nums[i],nums[j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>)</span></span></span></span></span>. Further, to maximize the likelihood of any arbitrary <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> falling in this range, we need to try to keep this range as much as possible. But, in the last approach, we tried to work only on <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>. But, it'll be a better choice, if we can somehow work out on <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> as well.</p>
To do so, we can look at the given <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array in the form of a graph, as shown below:</p>
<img alt="Graph" src="../Figures/456/456_132_Pattern.PNG"></p>
From the above graph, which consists of rising and falling slopes, we know, the best qualifiers to act as the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> pair,  as discussed above, to maximize the range <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i], nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, at any instant, while traversing the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array, will be the points at the endpoints of a local rising slope. Thus, once we've found such points, we can traverse over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array to find a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> satisfying the given 132 criteria. </p>
To find these points at the ends of a local rising slope, we can traverse over the given <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array. While traversing, we can keep a track of the minimum point found after the last peak(<span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>s</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">s</span>]</span></span></span></span></span>). </p>
Now, whenever we encounter a falling slope, say, at index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>, we know, that <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> was the endpoint of the last rising slope found. Thus, we can scan over the <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> indices(k&gt;i), to find a 132 pattern.</p>
But, instead of traversing over <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> to find a <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> satisfying the 132 pattern for every such rising slope, we can store this range <span class="maths katex-rendered">(</mo>n</mi>u</mi>m</mi>s</mi>[</mo>s</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>−</mo>1</mn>]</mo>)</mo></mrow><annotation encoding="application/x-tex">(nums[s], nums[i-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">s</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>)</span></span></span></span></span>(acting as <span class="maths katex-rendered">(</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>)</mo></mrow><annotation encoding="application/x-tex">(nums[i], nums[j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>)</span></span></span></span></span>) in, say an <span class="maths katex-rendered">i</mi>n</mi>t</mi>e</mi>r</mi>v</mi>a</mi>l</mi>s</mi></mrow><annotation encoding="application/x-tex">intervals</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span></span></span></span></span> array. </p>
While traversing over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array to check the rising/falling slopes, whenever we find any rising slope, we can keep adding the endpoint pairs to this <span class="maths katex-rendered">i</mi>n</mi>t</mi>e</mi>r</mi>v</mi>a</mi>l</mi>s</mi></mrow><annotation encoding="application/x-tex">intervals</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span></span></span></span></span> array. At the same time, we can also check if the current element falls in any of the ranges found so far. If so, this element satisfies the 132 criteria for that range. </p>
If no such element is found till the end, we need to return a False value.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> find132pattern</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        List</span> &lt;</span> int</span>[]</span> &gt;</span> intervals</span> =</span> new</span> ArrayList</span> &lt;</span> &gt;</span> ();</span>
        int</span> i</span> =</span> 1</span>,</span> s</span> =</span> 0</span>;</span>
        while</span> (</span>i</span> &lt;</span> nums</span>.</span>length</span>)</span> {</span>
            if</span> (</span>nums</span>[</span>i</span>]</span> &lt;=</span> nums</span>[</span>i</span> -</span> 1</span>])</span> {</span>
                if</span> (</span>s</span> &lt;</span> i</span> -</span> 1</span>)</span>
                    intervals</span>.</span>add</span>(</span>new</span> int</span>[]</span> {</span>nums</span>[</span>s</span>],</span> nums</span>[</span>i</span> -</span> 1</span>]});</span>
                s</span> =</span> i</span>;</span>
            }</span>
            for</span> (</span>int</span>[]</span> a</span>:</span> intervals</span>)</span>
                if</span> (</span>nums</span>[</span>i</span>]</span> &gt;</span> a</span>[</span>0</span>]</span> &amp;&amp;</span> nums</span>[</span>i</span>]</span> &lt;</span> a</span>[</span>1</span>])</span>
                    return</span> true</span>;</span>
            i</span>++;</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. We traverse over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> once to find the slopes. But for every element, we also need to traverse over the <span class="maths katex-rendered">i</mi>n</mi>t</mi>e</mi>r</mi>v</mi>a</mi>l</mi>s</mi></mrow><annotation encoding="application/x-tex">intervals</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span></span></span></span></span> to check if any element falls in any range found so far. This array can contain atmost <span class="maths katex-rendered">(</mo>n</mi>/</mi>2</mn>)</mo></mrow><annotation encoding="application/x-tex">(n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span>)</span></span></span></span></span> pairs, in the case of an alternate increasing-decreasing sequence(worst case e.g.[5 6 4 7 3 8 2 9]</code>). </p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">i</mi>n</mi>t</mi>e</mi>r</mi>v</mi>a</mi>l</mi>s</mi></mrow><annotation encoding="application/x-tex">intervals</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span></span></span></span></span> array can contain atmost <span class="maths katex-rendered">n</mi>/</mi>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> pairs, in the worst case(alternate increasing-decreasing sequence).</p>
</li>
</ul>

<h4 id="approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</h4>
Algorithm</strong></p>
In Approach 2, we found out <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> corresponding to a particular <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> directly without having to consider every pair possible in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> to find this <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> pair. If we do some preprocessing, we can make the process of finding a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> corresponding to this <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> pair also easy.</p>
The preprocessing required is to just find the best <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> value corresponding to every <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> value. This is done in the same manner as in the second approach i.e. we find the minimum element found till the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element which acts as the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> for the current <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. We maintain thes values in a <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array. Thus, <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> now refers to the best <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> value for a particular <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. </p>
Now, we traverse back from the end of the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array to find the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>'s. Suppose, we keep a track of the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> values which can potentially satisfy the 132 criteria for the current <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. We know, one of the conditions to be satisfied by such a <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> is that it must be greater than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>. Or in other words, we can also say that it must be greater than <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> for a particular <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> chosen. </p>
Once it is ensured that the elements left for competing for the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> are all greater than <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>(or <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>), our only task is to ensure that it should be lesser than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Now, the best element from among the competitors, for satisfying this condition will be the minimum one from out of these elements. </p>
If this element, <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>m</mi>i</mi>n</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[min]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>]</span></span></span></span></span> satisfies <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>m</mi>i</mi>n</mi>]</mo>&lt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[min] &lt; nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>]</span>&lt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, we've found a 132 pattern. If not, no other element will satisfy this criteria, since they are all greater than or equal to <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>m</mi>i</mi>n</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[min]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>]</span></span></span></span></span>$ and thus greater than or equal to <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> as well.</p>
To keep a track of these potential <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> values for a particular <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i],nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> considered currently, we maintain a <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> on which these potential <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>'s satisfying the 132 criteria lie in a descending order(minimum element on the top). We need not sort these elements on the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, but they'll be sorted automatically as we'll discuss along with the process.</p>
After creating a <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array, we start traversing the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> array in a backward manner. Let's say, we are currently at the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element and let's also assume that the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is sorted right now. Now, firstly, we check if <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>&gt;</mo>m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j] &gt; min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>&gt;</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. If not, we continue with the <span class="maths katex-rendered">(</mo>j</mi>−</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(j-1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element and the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> remains sorted. If not, we keep on popping the elements from the top of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> till we find an element, <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi>[</mo>t</mi>o</mi>p</mi>]</mo></mrow><annotation encoding="application/x-tex">stack[top]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>[</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">p</span>]</span></span></span></span></span> such that, <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi>[</mo>t</mi>o</mi>p</mi>]</mo>&gt;</mo>m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">stack[top] &gt; min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>[</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">p</span>]</span>&gt;</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>(or <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi>[</mo>t</mi>o</mi>p</mi>]</mo>&gt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">stack[top] &gt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>[</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">p</span>]</span>&gt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>). </p>
Once the popping is done, we're sure that all the elements pending on the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> are greater than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> and are thus, the potential candidates for <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> satisfying the 132 criteria. We can also note that the elements which have been popped from the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, all satisfy <span class="maths katex-rendered">stack[top] ≤ min[j]</span><script type="math/tex">stack[top] ≤ min[j]</script></span>. </p>
Since, in the <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array, <span class="maths katex-rendered">(min[p] ≤ min[q])</span>, for every <span class="maths katex-rendered">p</mi>&gt;</mo>q</mi></mrow><annotation encoding="application/x-tex">p &gt; q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.5391em;"></span><span class="strut bottom" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span>&gt;</span><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span></span></span>, these popped elements also satisfy <span class="maths katex-rendered">(stack[top] ≤ min[k])</span>, for all <span class="maths katex-rendered">(0 ≤ k &lt; j)</span>. Thus, they are not the potential <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> candidates for even the preceding elements. Even after  doing the popping, the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> remains sorted.</p>
After the popping is done, we've got the minimum element from amongst all the potential <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>'s on the top of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>(as per the assumption). We can check if it is greater than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> to satisfy the 132 criteria(we've already checked <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi>[</mo>t</mi>o</mi>p</mi>]</mo>&gt;</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">stack[top] &gt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>[</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">p</span>]</span>&gt;</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>). If this element satisfies the 132 criteria, we can return a True value. If not, we know that for the current <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>, <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>&gt;</mo>m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j] &gt; min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>&gt;</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Thus, the element <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> could be a potential <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> value, for the preceding <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>′</mi></mrow></msup>s</mi></mrow><annotation encoding="application/x-tex">nums[i]'s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.751892em;"></span><span class="strut bottom" style="height: 1.00189em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">s</span></span></span></span></span>. </p>
Thus, we push it over the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. We can note that, we need to push this element <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> on the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> only when it didn't satisfy <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi>[</mo>t</mi>o</mi>p</mi>]</mo></mrow><annotation encoding="application/x-tex">stack[top]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>[</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">p</span>]</span></span></span></span></span>. Thus, <span class="maths katex-rendered">(nums[j] ≤ stack[top])</span>. Thus, even after pushing this element on the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> remains sorted. Thus, we've seen by induction, that the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> always remains sorted.</p>
Also, note that in case <span class="maths katex-rendered">(nums[j] ≤ min[j])</span>, we don't push <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. This is because this <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> isn't greater than even the minimum element lying towards its left and thus can't act as <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> in the future.</p>
If no element is found satisfying the 132 criteria till reaching the first element, we return a False value.</p>
The following animation better illustrates the process.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 10</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> find132pattern</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 3</span>)</span>
            return</span> false</span>;</span>
        Stack</span> &lt;</span> Integer</span> &gt;</span> stack</span> =</span> new</span> Stack</span> &lt;</span> &gt;</span> ();</span>
        int</span>[]</span> min</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        min</span>[</span>0</span>]</span> =</span> nums</span>[</span>0</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span>
            min</span>[</span>i</span>]</span> =</span> Math</span>.</span>min</span>(</span>min</span>[</span>i</span> -</span> 1</span>],</span> nums</span>[</span>i</span>]);</span>
        for</span> (</span>int</span> j</span> =</span> nums</span>.</span>length</span> -</span> 1</span>;</span> j</span> &gt;=</span> 0</span>;</span> j</span>--)</span> {</span>
            if</span> (</span>nums</span>[</span>j</span>]</span> &gt;</span> min</span>[</span>j</span>])</span> {</span>
                while</span> (!</span>stack</span>.</span>isEmpty</span>()</span> &amp;&amp;</span> stack</span>.</span>peek</span>()</span> &lt;=</span> min</span>[</span>j</span>])</span>
                    stack</span>.</span>pop</span>();</span>
                if</span> (!</span>stack</span>.</span>isEmpty</span>()</span> &amp;&amp;</span> stack</span>.</span>peek</span>()</span> &lt;</span> nums</span>[</span>j</span>])</span>
                    return</span> true</span>;</span>
                stack</span>.</span>push</span>(</span>nums</span>[</span>j</span>]);</span>
            }</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We travesre over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> once to fill the <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array. After this, we traverse over <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> to find the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>. During this process, we also push and pop the elements on the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. But, we can note that atmost <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements can be pushed and popped off the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> in total. Thus, the second traversal requires only <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> can grow upto a maximum depth of <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Furhter, <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-5-using-binary-search-accepted">Approach #5 Using Binary Search [Accepted]:</h4>
Algorithm</strong></p>
In the last approach, we've made use of a separate <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> to push and pop the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>'s. But, we can also note that when we reach the index <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> while scanning backwards for finding <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>, the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> can contain atmost <span class="maths katex-rendered">n</mi>−</mo>j</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span></span></span></span></span> elements. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the number of elements in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array. </p>
We can also note that this is the same number of elements which lie beyond the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array. We also know that these elements lying beyond the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index won't be needed in the future ever again. Thus, we can make use of this space in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array instead of using a separate <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. The rest of the process can be carried on in the same manner as discussed in the last approach.</p>
We can try to go for another optimization here. Since, we've got an array for storing the potential <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> values now, we need not do the popping process for a <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> to find an element just larger than <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> from amongst these potential values. </p>
Instead, we can make use of Binary Search to directly find an element, which is just larger than <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> in the required interval, if it exists. If such an element is found, we can compare it with <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> to check the 132 criteria. Otherwise, we continue the process as in the last approach.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> find132pattern</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 3</span>)</span>
            return</span> false</span>;</span>
        int</span>[]</span> min</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        min</span>[</span>0</span>]</span> =</span> nums</span>[</span>0</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span>
            min</span>[</span>i</span>]</span> =</span> Math</span>.</span>min</span>(</span>min</span>[</span>i</span> -</span> 1</span>],</span> nums</span>[</span>i</span>]);</span>
        for</span> (</span>int</span> j</span> =</span> nums</span>.</span>length</span> -</span> 1</span>,</span> k</span> =</span> nums</span>.</span>length</span>;</span> j</span> &gt;=</span> 0</span>;</span> j</span>--)</span> {</span>
            if</span> (</span>nums</span>[</span>j</span>]</span> &gt;</span> min</span>[</span>j</span>])</span> {</span>
                k</span> =</span> Arrays</span>.</span>binarySearch</span>(</span>nums</span>,</span> k</span>,</span> nums</span>.</span>length</span>,</span> min</span>[</span>j</span>]</span> +</span> 1</span>);</span>
                if</span> (</span>k</span> &lt;</span> 0</span>)</span>
                    k</span> =</span> -</span>1</span> -</span> k</span>;</span>
                if</span> (</span>k</span> &lt;</span> nums</span>.</span>length</span> &amp;&amp;</span> nums</span>[</span>k</span>]</span> &lt;</span> nums</span>[</span>j</span>])</span>
                    return</span> true</span>;</span>
                nums</span>[--</span>k</span>]</span> =</span> nums</span>[</span>j</span>];</span>
            }</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">Obig(nlog(n)big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span>. Filling <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array requires <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time. The second traversal is done over the whole <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array of length <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. For every current <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> we need to do the Binary Search, which requires <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">Obig(log(n)big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span>. In the worst case, this Binary Search will be done for all the <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements, and the required element won't be found in any case, leading to a complexity of <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">Obig(nlog(n)big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-6-using-array-as-a-stackaccepted">Approach #6 Using Array as a stack[Accepted]:</h4>
Algorithm</strong></p>
In the last approach, we've seen that in the worst case, the required element won't be found for all the <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements and thus Binary Search is done at every step increasing the time complexity. </p>
To remove this problem, we can follow the same steps as in Approach 4 i.e. We can remove those elements(update the index <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>) which aren't greater than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>(<span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>). Thus, in case no element is larger than <span class="maths katex-rendered">m</mi>i</mi>n</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">min[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> the index <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> reaches the last element. </p>
Now, at every step, only <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> will be added and removed from consideration in the next step, improving the time complexity in the worst case. The rest of the method remains the same as in Approach 4.</p>
This approach is inspired by <a href="https://leetcode.com/fun4leetcode/">@fun4leetcode</a></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> find132pattern</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        if</span> (</span>nums</span>.</span>length</span> &lt;</span> 3</span>)</span>
            return</span> false</span>;</span>
        int</span>[]</span> min</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        min</span>[</span>0</span>]</span> =</span> nums</span>[</span>0</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span>
            min</span>[</span>i</span>]</span> =</span> Math</span>.</span>min</span>(</span>min</span>[</span>i</span> -</span> 1</span>],</span> nums</span>[</span>i</span>]);</span>
        for</span> (</span>int</span> j</span> =</span> nums</span>.</span>length</span> -</span> 1</span>,</span> k</span> =</span> nums</span>.</span>length</span>;</span> j</span> &gt;=</span> 0</span>;</span> j</span>--)</span> {</span>
            if</span> (</span>nums</span>[</span>j</span>]</span> &gt;</span> min</span>[</span>j</span>])</span> {</span>
                while</span> (</span>k</span> &lt;</span> nums</span>.</span>length</span> &amp;&amp;</span> nums</span>[</span>k</span>]</span> &lt;=</span> min</span>[</span>j</span>])</span>
                    k</span>++;</span>
                if</span> (</span>k</span> &lt;</span> nums</span>.</span>length</span> &amp;&amp;</span> nums</span>[</span>k</span>]</span> &lt;</span> nums</span>[</span>j</span>])</span>
                    return</span> true</span>;</span>
                nums</span>[--</span>k</span>]</span> =</span> nums</span>[</span>j</span>];</span>
            }</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We travesre over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> once to fill the <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array. After this, we traverse over <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> to find the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>. Atmost <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements can be put in and out of the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array in total. Thus, the second traversal requires only <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>