<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-using-recursion-with-memoization-time-limit-exceeded">Approach #2 Using Recursion with memoization [Time Limit Exceeded]</a></li>
<a href="#approach-3-dynamic-programming-time-limit-exceeded">Approach #3 Dynamic Programming [Time Limit Exceeded]</a></li>
<a href="#approach-4-dynamic-programming-with-cumulative-sumaccepted">Approach #4 Dynamic Programming with Cumulative Sum[Accepted]:</a></li>
<a href="#approach-5-another-optimized-dynamic-programming-approachaccepted">Approach #5 Another Optimized Dynamic Programming Approach[Accepted]:</a></li>
<a href="#approach-6-once-again-memoization-accepted">Approach #6 Once Again Memoization [Accepted]:</a></li>
<a href="#approach-7-1-d-dynamic-programmming-accepted">Approach #7 1-D dynamic Programmming [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>
<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
The most naive solution is to generate every permutation of the array consisting of numbers from <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Then, we can find out the number of inverse pairs in every array to determine if it is equal to 1. We can find out the count of permutations with the required number of inverse pairs. But, this solution is very terrible in terms of time complexity. Thus, we move on to the better approaches directly.</p>
Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>!</mo>∗</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">Obig(n!*nlog(n)big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord mathit">n</span>!</span>∗</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span>. A total of <span class="maths katex-rendered">n</mi>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>!</span></span></span></span></span> permutations will be generated. We need <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">Obig(nlog(n)big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span> time to find the number of inverse pairs in every such permutation, by making use of merge sort. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the given integer <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Each array generated during the permutations will require <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> space.</p>
</li>
</ul>

<h4 id="approach-2-using-recursion-with-memoization-time-limit-exceeded">Approach #2 Using Recursion with memoization [Time Limit Exceeded]</h4>
Before we discuss the solution, let's look at the idea behind it. Let's say, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> represents the given number defining the upper limit of the elements in the arrays being considered and <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> represents the number of inverse pairs in the current array.</p>
Let's start with a simple example with <span class="maths katex-rendered">n</mi>=</mo>4</mn></mrow><annotation encoding="application/x-tex">n=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>=</span><span class="mord mathrm">4</span></span></span></span></span>, no <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is defined right now. Now, for <span class="maths katex-rendered">k</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>=</span><span class="mord mathrm">0</span></span></span></span></span>, the only possible arrangement for the given array <span class="maths katex-rendered">a</mi>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> will be [1,2,3,4]</code>, since all the greater elements lie after the smaller elements. Now, in order to generate an arrangement with any arbitrary <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> value, we need to shift, an arbitrary number of elements(let's say <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> elements) in the array <span class="maths katex-rendered">a</mi>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> towards the left, with each displacement(shift) being <span class="maths katex-rendered">s</mi>1</mn></msub>,</mo>s</mi>2</mn></msub>,</mo>.</mi>.</mi>.</mi>.</mi>,</mo>s</mi>x</mi></msub></mrow><annotation encoding="application/x-tex">s_1, s_2, ...., s_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>,</span><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">x</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, such that the sum of these shifts equals <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>.</p>
To see what we mean by the above statement, let's look at the case for [1,2,4,3]</code>. The number of inverse pairs in this array is 1. This array is obtained by shifting the number 4 by one position towards the left. </p>
Similarly, consider the case for [2,4,1,3]</code>. This array can be obtained from <span class="maths katex-rendered">a</mi>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> by shifting 2 by one position towards the left first and then shifting 4 by 2 positions towards the left. Thus, the total number of displacements is 3, which is equal to the number of inverse pairs in the new array. </p>
This rule of displacements holds true because, whenever a number is shifted <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> times towards the left starting from the array <span class="maths katex-rendered">a</mi>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, after the shift, <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> numbers smaller than it lie towards its right, giving a total of <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> inverse pairs. </p>
Now, let's say, we start with the one of the arrangements <span class="maths katex-rendered">a</mi>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>
[2,4,1,3]</code>, with <span class="maths katex-rendered">k</mi>=</mo>3</mn></mrow><annotation encoding="application/x-tex">k=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>=</span><span class="mord mathrm">3</span></span></span></span></span>. Now, if we want to add a new number 5 to this array to consider an array with <span class="maths katex-rendered">n</mi>=</mo>5</mn></mrow><annotation encoding="application/x-tex">n=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>=</span><span class="mord mathrm">5</span></span></span></span></span>, let's say, initially, we append it to the end of <span class="maths katex-rendered">a</mi>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>. Now, the new array will be [2,4,1,3,5]</code>. Since, the largest number is added at the end, the new number 5 doesn't add any new inverse pair to the total set of inverse pairs relative to the ones in <span class="maths katex-rendered">a</mi>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>(3). </p>
Now, all the numbers in <span class="maths katex-rendered">a</mi>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> are smaller than 5. Thus, if we add 5 at a position <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> steps from the right, <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> smaller numbers will lie towards its right. Thus, a total of <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> inverse pairs will exist with 5 being one of the elements in these pairs. </p>
Thus, adding 5 at <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> steps from the right adds a total of <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> inverse pairs to the total set of inverse pairs in <span class="maths katex-rendered">a</mi>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> giving a total of <span class="maths katex-rendered">3</mn>+</mo>y</mi></mrow><annotation encoding="application/x-tex">3+y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span>+</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> inverse pairs now.</p>
Looking at the same statement from another point of view, we can say that, if we know the number of inverse pairs(say <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>) in any arbitrary array <span class="maths katex-rendered">b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span></span> with some <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, we can add a new element <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> to this array <span class="maths katex-rendered">b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span></span> at a position <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span> steps from the right, such that <span class="maths katex-rendered">x</mi>+</mo>p</mi>=</mo>k</mi></mrow><annotation encoding="application/x-tex">x+p=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>+</span><span class="mord mathit">p</span>=</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> to generate an array with a total of <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> inverse pairs. </p>
Extending this idea further, suppose we know the number of arrangements of an array with <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> elements, with the number of inverse pairs being <span class="maths katex-rendered">0</mn>,</mo>1</mn>,</mo>2</mn>,</mo>.</mi>.</mi>.</mi>,</mo>k</mi></mrow><annotation encoding="application/x-tex">0, 1, 2,..., k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span>,</span><span class="mord mathrm">1</span>,</span><span class="mord mathrm">2</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, let's say being equal to <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>0</mn></msub>,</mo>c</mi>o</mi>u</mi>n</mi>t</mi>1</mn></msub>,</mo>c</mi>o</mi>u</mi>n</mi>t</mi>2</mn></msub>,</mo>.</mi>.</mi>,</mo>c</mi>o</mi>u</mi>n</mi>t</mi>k</mi></msub></mrow><annotation encoding="application/x-tex">count_0, count_1, count_2,.., count_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>,</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>. Now, we can determine the number of arrangements of an array with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements with exactly <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> inverse pairs easily. </p>
To generate the arrangements with exactly <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> inverse pairs and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements, we can add the new number <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> to all the arrangements with <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> inverse pairs at the last position. For the arrangements with <span class="maths katex-rendered">k</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathrm">1</span></span></span></span></span> inverse pairs , we can add <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> at a position 1 step from the right. </p>
Similarly, for an element with <span class="maths katex-rendered">k</mi>−</mo>i</mi></mrow><annotation encoding="application/x-tex">k-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathit">i</span></span></span></span></span> number of inverse pairs, we can add this new number <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> at a position <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> steps from the right. Each of these updations to the arrays leads to a new arrangement, each with the number of inverse pairs being equal to <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. </p>
The following image shows an example of how this is done for n=5 and k=4:</p>
<img alt="Inversions" src="../Figures/629/629_kinverse.PNG"></p>
Thus, to obtain the number of arrangements with exactly <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> inverse pairs and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> numbers will be given by <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>0</mn></msub>+</mo>c</mi>o</mi>u</mi>n</mi>t</mi>1</mn></msub>+</mo>.</mi>.</mi>.</mi>+</mo>c</mi>o</mi>u</mi>n</mi>t</mi>k</mi></msub></mrow><annotation encoding="application/x-tex">count_0 + count_1 + ... + count_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.76508em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>+</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>+</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>.</p>
From the above discussion, we can obtain the recursive formula for finding the number of arrangements with exactly <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> inverse pairs as follows. Let's say <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">count(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> represents the number of arrangements with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> elements and exactly <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> inverse pairs.</p>


If <span class="maths katex-rendered">n</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>=</span><span class="mord mathrm">0</span></span></span></span></span>, no inverse pairs exist. Thus, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>0</mn>,</mo>k</mi>)</mo>=</mo>0</mn></mrow><annotation encoding="application/x-tex">count(0,k)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span>=</span><span class="mord mathrm">0</span></span></span></span></span>.</p>
</li>

If <span class="maths katex-rendered">k</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>=</span><span class="mord mathrm">0</span></span></span></span></span>, only one arrangement is possible, which is all numbers sorted in ascending order. Thus, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>,</mo>0</mn>)</mo>=</mo>1</mn></mrow><annotation encoding="application/x-tex">count(n,0)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>,</span><span class="mord mathrm">0</span>)</span>=</span><span class="mord mathrm">1</span></span></span></span></span>.</p>
</li>

Otherwise, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>,</mo>k</mi>)</mo>=</mo>∑</mo>i</mi>=</mo>0</mn></mrow>m</mi>i</mi>n</mi>(</mo>k</mi>,</mo>n</mi>−</mo>1</mn>)</mo></mrow></msubsup>c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>−</mo>1</mn>,</mo>k</mi>−</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">count(n,k) = sum_{i=0}^{min(k,n-1)} count(n-1, k-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.0448em;"></span><span class="strut bottom" style="height: 1.32166em; vertical-align: -0.276864em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span>=</span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.276864em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -0.5198em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span><span class="mclose mtight">)</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathit">i</span>)</span></span></span></span></span>. </p>
</li>
</ol>
Note that the upper limit on the summation is <span class="maths katex-rendered">m</mi>i</mi>n</mi></mtext>(</mo>k</mi>,</mo>n</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">text{min}(k,n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">min</span></span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. This is because for <span class="maths katex-rendered">i</mi>&gt;</mo>k</mi></mrow><annotation encoding="application/x-tex">i&gt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>&gt;</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, <span class="maths katex-rendered">k</mi>−</mo>i</mi>&lt;</mo>0</mn></mrow><annotation encoding="application/x-tex">k-i&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathit">i</span>&lt;</span><span class="mord mathrm">0</span></span></span></span></span>. No arrangement exists with negative number of inverse pairs. The reason for the other factor can be seen as follows. </p>
To generate a new arrangement adding <span class="maths katex-rendered">k</mi>−</mo>i</mi></mrow><annotation encoding="application/x-tex">k-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathit">i</span></span></span></span></span> new inverse pairs after adding the <span class="maths katex-rendered">n</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> number, we need to add this number at the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position from the right. For an array with size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, only <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> maximum shifts are possible.</p>
We need to take the modulus at every step to keep the answer within integral limits.</p>
We can see that a lot of duplicate function calls are made in the normal recursive solution. We can remove this redundancy by making use of a memoization array which stores the result for any function call kInversePairs(i,j)</code> in <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">memo[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Thus, whenver a duplicate function call is made again, we can return the result directly from this memoization array. This prunes the search space to a great extent.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    Integer</span>[][]</span> memo</span> =</span> new</span> Integer</span>[</span>1001</span>][</span>1001</span>];</span>
    public</span> int</span> kInversePairs</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        if</span> (</span>n</span> ==</span> 0</span>)</span>
            return</span> 0</span>;</span>
        if</span> (</span>k</span> ==</span> 0</span>)</span>
            return</span> 1</span>;</span>
        if</span> (</span>memo</span>[</span>n</span>][</span>k</span>]</span> !=</span> null</span>)</span>
            return</span> memo</span>[</span>n</span>][</span>k</span>];</span>
        int</span> inv</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;=</span> Math</span>.</span>min</span>(</span>k</span>,</span> n</span> -</span> 1</span>);</span> i</span>++)</span>
            inv</span> =</span> (</span>inv</span> +</span> kInversePairs</span>(</span>n</span> -</span> 1</span>,</span> k</span> -</span> i</span>))</span> %</span> 1000000007</span>;</span>
        memo</span>[</span>n</span>][</span>k</span>]</span> =</span> inv</span>;</span>
        return</span> inv</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n^2*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. The function kInversePairs</code> is called <span class="maths katex-rendered">n</mi>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 0.814108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> times to fill the <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. Each function call itself takes <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array of constant size <span class="maths katex-rendered">1</mn>0</mn>0</mn>1</mn></mrow><annotation encoding="application/x-tex">1001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span></span>x<span class="maths katex-rendered">1</mn>0</mn>0</mn>1</mn></mrow><annotation encoding="application/x-tex">1001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span></span> is used. The depth of recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. </p>
</li>
</ul>

<h4 id="approach-3-dynamic-programming-time-limit-exceeded">Approach #3 Dynamic Programming [Time Limit Exceeded]</h4>
Algorithm</strong></p>
As we've seen in the discussion above, the solution for if we know the solutions for <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>−</mo>1</mn>,</mo>0</mn>)</mo></mrow><annotation encoding="application/x-tex">count(n-1,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathrm">0</span>)</span></span></span></span></span>, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>−</mo>1</mn>,</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">count(n-1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathrm">1</span>)</span></span></span></span></span>..., <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>−</mo>1</mn>,</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">count(n-1,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>, we can directly obtain the solution for <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>,</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">count(n,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> as <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>,</mo>k</mi>)</mo>=</mo>∑</mo>0</mn></mrow>m</mi>i</mi>n</mi>(</mo>k</mi>,</mo>n</mi>−</mo>1</mn>)</mo></mrow></msubsup>c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>n</mi>−</mo>1</mn>,</mo>k</mi>−</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">count(n,k)=sum_{0}^{min(k,n-1)} count(n-1, k-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.0448em;"></span><span class="strut bottom" style="height: 1.31111em; vertical-align: -0.266308em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span>=</span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.266308em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -0.5198em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span><span class="mclose mtight">)</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathit">i</span>)</span></span></span></span></span>.</p>
From this, we deduce that we can make use of Dynamic Programming to solve the given problem. To solve the given problem, we make use of a 2-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span>, where <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> is used to store the number of arrangements with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> elements and exactly <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> inverse pairs. Based on the discussions above, the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> updation equations become:</p>


If <span class="maths katex-rendered">n</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>=</span><span class="mord mathrm">0</span></span></span></span></span>, no inverse pairs exist. Thus, <span class="maths katex-rendered">d</mi>p</mi>[</mo>0</mn>]</mo>[</mo>k</mi>]</mo>=</mo>0</mn></mrow><annotation encoding="application/x-tex">dp[0][k]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathrm">0</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span>=</span><span class="mord mathrm">0</span></span></span></span></span>.</p>
</li>

If <span class="maths katex-rendered">k</mi>=</mo>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>=</span><span class="mord mathrm">0</span></span></span></span></span>, only one arrangement is possible, which is all numbers sorted in ascending order. Thus, <span class="maths katex-rendered">d</mi>p</mi>[</mo>n</mi>]</mo>[</mo>0</mn>]</mo>=</mo>1</mn></mrow><annotation encoding="application/x-tex">dp[n][0]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">n</span>]</span>[</span><span class="mord mathrm">0</span>]</span>=</span><span class="mord mathrm">1</span></span></span></span></span>.</p>
</li>

Otherwise, <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>,</mo>j</mi>]</mo>=</mo>∑</mo>p</mi>=</mo>0</mn></mrow>m</mi>i</mi>n</mi>(</mo>j</mi>,</mo>i</mi>−</mo>1</mn>)</mo></mrow></msubsup>c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>i</mi>−</mo>1</mn>,</mo>j</mi>−</mo>p</mi>)</mo></mrow><annotation encoding="application/x-tex">dp[i,j] = sum_{p=0}^{min(j,i-1)} count(i-1, j-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.0448em;"></span><span class="strut bottom" style="height: 1.44722em; vertical-align: -0.402416em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.266308em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">p</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -0.5198em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span><span class="mopen mtight">(</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathit mtight">i</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span><span class="mclose mtight">)</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">p</span>)</span></span></span></span></span>.</p>
</li>
</ol>
Again, the limit <span class="maths katex-rendered">m</mi>i</mi>n</mi></mtext>(</mo>j</mi>,</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">text{min}(j, i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">min</span></span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> is used to account for the cases where the number of inverse pairs needed becomes negative(<span class="maths katex-rendered">p</mi>&gt;</mo>j</mi></mrow><annotation encoding="application/x-tex">p&gt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span>&gt;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>) or the case where the new inverse pairs needed by adding the <span class="maths katex-rendered">n</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> number is more than <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> which isn't possible, since the new number can be added at <span class="maths katex-rendered">(</mo>n</mi>−</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(n-1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position at most from the right.</p>
We start filling the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> in a row-wise order starting from the first row. At the end, the value of <span class="maths katex-rendered">d</mi>p</mi>[</mo>n</mi>]</mo>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[n][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">n</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span> gives the required result.</p>
The following animation shows how the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> is filled for n=4 and k=5:</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 25</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>

    public</span> int</span> kInversePairs</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span>[][]</span> dp</span> =</span> new</span> int</span>[</span>n</span> +</span> 1</span>][</span>k</span> +</span> 1</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;=</span> k</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>j</span> ==</span> 0</span>)</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> 1</span>;</span>
                else</span> {</span>
                    for</span> (</span>int</span> p</span> =</span> 0</span>;</span> p</span> &lt;=</span> Math</span>.</span>min</span>(</span>j</span>,</span> i</span> -</span> 1</span>);</span> p</span>++)</span>
                        dp</span>[</span>i</span>][</span>j</span>]</span> =</span> (</span>dp</span>[</span>i</span>][</span>j</span>]</span> +</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span> -</span> p</span>])</span> %</span> 1000000007</span>;</span>
                }</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>n</span>][</span>k</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n^2*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is filled once. Filling each <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> entry takes <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-4-dynamic-programming-with-cumulative-sumaccepted">Approach #4 Dynamic Programming with Cumulative Sum[Accepted]:</h4>
Algorithm</strong></p>
From the last approach, we've observed that we need to traverse back to some limit in the previous row of the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array to fill in the current <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> entry. Instead of doing this traversal to find the sum of the required elements, we can ease the process if we fill the cumulative sum upto the current element in a row in any <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> entry, instead of the actual value. </p>
Thus, now, <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo>=</mo>c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>i</mi>,</mo>j</mi>)</mo>+</mo>∑</mo>k</mi>=</mo>0</mn></mrow>j</mi>−</mo>1</mn></mrow></msubsup>d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>k</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=count(i,j)+sum_{k=0}^{j-1} dp[i][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.942572em;"></span><span class="strut bottom" style="height: 1.24388em; vertical-align: -0.301308em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span>+</span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.301308em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -0.480908em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span></span></span></span></span>. Here, <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">count(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> refers to the number of arrangements with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> elements and exactly <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> inverse pairs. Thus, each entry contains the sum of all the previous elements in the same row along with its own result.</p>
Now, we need to determine the value of <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">count(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> to be added to the sum of previous elements in a row, in order to update the <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> entry. But, we need not traverse back in the previous row , since it contains entries representing the cumulative sums now.
Thus, to obtain the sum of elements from <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>  to <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>(including both), we can directly use <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j] - dp[i-1][j-i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>]</span></span></span></span></span>. </p>
Now, to reflect the condition <span class="maths katex-rendered">m</mi>i</mi>n</mi></mtext>(</mo>j</mi>,</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">text{min}(j, i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">min</span></span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> used in the previous approaches, we can note that, we need to take the sum of only <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> elements in the previous row, if <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> elements exist till we reach the end of the array while traversing backwards. Otherwise, we simply take the sum of all the elements. </p>
Only <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> elements are considered because for generating <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> new inverse pairs, by adding <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> as the new number at the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position, <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> could reach only upto <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span>, as discussed in the last approaches as well. Thus, we need to consider the sum of elements from <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>(</mo>i</mi>−</mo>1</mn>)</mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-(i-1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>]</span></span></span></span></span> to  <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>(including both) using <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j] - dp[i-1][j-i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>]</span></span></span></span></span> if <span class="maths katex-rendered">j-i ≥ 0</span><script type="math/tex">j-i ≥ 0</script></span>.</p>
Otherwise, we add all the elements of the previous row upto the current column <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> being considered. In other words, we can use <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> directly as the required sum.</p>
At the end, while returning the result, we need to return <span class="maths katex-rendered">d</mi>p</mi>[</mo>n</mi>]</mo>[</mo>k</mi>]</mo>−</mo>d</mi>p</mi>[</mo>n</mi>]</mo>[</mo>k</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[n][k]-dp[n][k-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">n</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">n</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to obtain the required result from the cumulative sums. </p>
The following animation illustrates the process of filling the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 26</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> kInversePairs</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span>[][]</span> dp</span> =</span> new</span> int</span>[</span>n</span> +</span> 1</span>][</span>k</span> +</span> 1</span>];</span>
        int</span> M</span> =</span> 1000000007</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;=</span> k</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>j</span> ==</span> 0</span>)</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> 1</span>;</span>
                else</span> {</span>
                    int</span> val</span> =</span> (</span>dp</span>[</span>i</span> -</span> 1</span>][</span>j</span>]</span> +</span> M</span> -</span> ((</span>j</span> -</span> i</span>)</span> &gt;=</span> 0</span> ?</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span> -</span> i</span>]</span> :</span> 0</span>))</span> %</span> M</span>;</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> (</span>dp</span>[</span>i</span>][</span>j</span> -</span> 1</span>]</span> +</span> val</span>)</span> %</span> M</span>;</span>
                }</span>
            }</span>
        }</span>
        return</span> ((</span>dp</span>[</span>n</span>][</span>k</span>]</span> +</span> M</span> -</span> (</span>k</span> &gt;</span> 0</span> ?</span> dp</span>[</span>n</span>][</span>k</span> -</span> 1</span>]</span> :</span> 0</span>))</span> %</span> M</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is filled once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-5-another-optimized-dynamic-programming-approachaccepted">Approach #5 Another Optimized Dynamic Programming Approach[Accepted]:</h4>
Algorithm</strong></p>
Another way to use the Dynamic Programming Approach could be if we can somehow directly store the required <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">count(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> in <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> entry, but still we should not need to traverse back in the previous row to find the sum of the required elements. </p>
To do so, we can note that for the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> row, we need to add the elements from <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>(including both) if <span class="maths katex-rendered">(</mo>j</mi>−</mo>1</mn>)</mo>&gt;</mo>0</mn></mrow><annotation encoding="application/x-tex">(j-1) &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>)</span>&gt;</span><span class="mord mathrm">0</span></span></span></span></span>. Otherwise, we need to add all the elements from <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>0</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathrm">0</span>]</span></span></span></span></span> to <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. This has already been discussed previously. </p>
Now, when we go for filling in <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> after filling <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, we know <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> already corresponds to the sum of the elements from <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. But, for filling <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, we require the sum of the elements from <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>(</mo>j</mi>−</mo>i</mi>+</mo>1</mn>)</mo>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][(j-i+1)+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>)</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. </p>
We can observe that this sum only excludes <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j-i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> from the previous sum(<span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>) and requires addition of only one new element(<span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span>) to the to this sum. If the value <span class="maths katex-rendered">j</mi>−</mo>i</mi>+</mo>1</mn>&lt;</mo>0</mn></mrow><annotation encoding="application/x-tex">j-i+1&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>&lt;</span><span class="mord mathrm">0</span></span></span></span></span>, we need not remove any value.</p>
Thus, we can directly obtain <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> value as <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo>=</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>−</mo>i</mi>]</mo>+</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>]</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, if <span class="maths katex-rendered">(j-i ≥ 0)</span>. Otherwise, we can use:  <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo>=</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo>+</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1][j] + dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. </p>
We can also note that, since, here <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> represents the number of inverse pairs that need to be currently considered, we can place another upper limit on <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> as well. The maximum number of inverse pairs for any arbitrary <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> occur only when the array is sorted in descending order leading to [n,n-1,....,3,2,1]</code> as the arrangement. </p>
This arrangement has a total of <span class="maths katex-rendered">n</mi>∗</mo>(</mo>n</mi>−</mo>1</mn>)</mo>/</mi>2</mn></mrow><annotation encoding="application/x-tex">n*(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>∗</span>(</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> inverse pairs. Thus, for an array with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> as the number of elements, the maximum number of inverse pairs possible is <span class="maths katex-rendered">i</mi>∗</mo>(</mo>i</mi>−</mo>1</mn>)</mo>/</mi>2</mn></mrow><annotation encoding="application/x-tex">i*(i-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>∗</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> only. Thus, for fillling in the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> row of <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span>, we can place this limit on <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>'s value.</p>
The following animation shows the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> filling process.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 21</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> kInversePairs</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span>[][]</span> dp</span> =</span> new</span> int</span>[</span>n</span> +</span> 1</span>][</span>k</span> +</span> 1</span>];</span>
        int</span> M</span> =</span> 1000000007</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;=</span> k</span> &amp;&amp;</span> j</span> &lt;=</span> i</span> *</span> (</span>i</span> -</span> 1</span>)</span> /</span> 2</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>i</span> ==</span> 1</span> &amp;&amp;</span> j</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> 1</span>;</span>
                    break</span>;</span>
                }</span> else</span> if</span> (</span>j</span> ==</span> 0</span>)</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> 1</span>;</span>
                else</span> {</span>
                    int</span> val</span> =</span> (</span>dp</span>[</span>i</span> -</span> 1</span>][</span>j</span>]</span> +</span> M</span> -</span> ((</span>j</span> -</span> i</span>)</span> &gt;=</span> 0</span> ?</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span> -</span> i</span>]</span> :</span> 0</span>))</span> %</span> M</span>;</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> (</span>dp</span>[</span>i</span>][</span>j</span> -</span> 1</span>]</span> +</span> val</span>)</span> %</span> M</span>;</span>
                }</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>n</span>][</span>k</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">(</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span>x<span class="maths katex-rendered">(</mo>k</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> is filled once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">(</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span>x<span class="maths katex-rendered">(</mo>k</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-6-once-again-memoization-accepted">Approach #6 Once Again Memoization [Accepted]:</h4>
Algorithm</strong></p>
The Dynamic Programming solution discussed in Approach 5 can also be written down in the form of a recursive solution. But, again, that will include a lot of duplicate function calls. Thus, a better solution would be to use memoization to store the results of the previous function calls.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    Integer</span>[][]</span> memo</span> =</span> new</span> Integer</span>[</span>1001</span>][</span>1001</span>];</span>
    int</span> M</span> =</span> 1000000007</span>;</span>
    public</span> int</span> kInversePairs</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        return</span> ((</span>inv</span>(</span>n</span>,</span> k</span>)</span> +</span> M</span> -</span> (</span>k</span> &gt;</span> 0</span> ?</span> inv</span>(</span>n</span>,</span> k</span> -</span> 1</span>)</span> :</span> 0</span>))</span> %</span> M</span>);</span>
    }</span>
    public</span> int</span> inv</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        if</span> (</span>n</span> ==</span> 0</span>)</span>
            return</span> 0</span>;</span>
        if</span> (</span>k</span> ==</span> 0</span>)</span>
            return</span> 1</span>;</span>
        if</span> (</span>memo</span>[</span>n</span>][</span>k</span>]</span> !=</span> null</span>)</span>
            return</span> memo</span>[</span>n</span>][</span>k</span>];</span>
        int</span> val</span> =</span> (</span>inv</span>(</span>n</span> -</span> 1</span>,</span> k</span>)</span> +</span> M</span> -</span> ((</span>k</span> -</span> n</span>)</span> &gt;=</span> 0</span> ?</span> inv</span>(</span>n</span> -</span> 1</span>,</span> k</span> -</span> n</span>)</span> :</span> 0</span>))</span> %</span> M</span>;</span>
        memo</span>[</span>n</span>][</span>k</span>]</span> =</span> (</span>inv</span>(</span>n</span>,</span> k</span> -</span> 1</span>)</span> +</span> val</span>)</span> %</span> M</span>;</span>
        return</span> memo</span>[</span>n</span>][</span>k</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> entries in the <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array are filled once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array of constant size <span class="maths katex-rendered">1</mn>0</mn>0</mn>1</mn></mrow><annotation encoding="application/x-tex">1001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span></span>x<span class="maths katex-rendered">1</mn>0</mn>0</mn>1</mn></mrow><annotation encoding="application/x-tex">1001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-7-1-d-dynamic-programmming-accepted">Approach #7 1-D dynamic Programmming [Accepted]:</h4>
Algorithm</strong></p>
From the Dynamic Programming solution, we can also note that we only need the values of the previous row in the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array, and not any other row. Thus, instead of storing the whole 2-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> in memory, we can make use of a 1-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> to store the previous row's entries only. The updations can be done in a 1-D <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> array of the same size as <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> can be updated using this <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> everytime a row is finished.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> kInversePairs</span>(</span>int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span>[]</span> dp</span> =</span> new</span> int</span>[</span>k</span> +</span> 1</span>];</span>
        int</span> M</span> =</span> 1000000007</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span>;</span> i</span>++)</span> {</span>
            int</span>[]</span> temp</span> =</span> new</span> int</span>[</span>k</span> +</span> 1</span>];</span>
            temp</span>[</span>0</span>]</span> =</span> 1</span>;</span>
            for</span> (</span>int</span> j</span> =</span> 1</span>;</span> j</span> &lt;=</span> k</span> ;</span> j</span>++)</span> {</span>
                int</span> val</span> =</span> (</span>dp</span>[</span>j</span>]</span> +</span> M</span> -</span> ((</span>j</span> -</span> i</span>)</span> &gt;=</span> 0</span> ?</span> dp</span>[</span>j</span> -</span> i</span>]</span> :</span> 0</span>))</span> %</span> M</span>;</span>
                temp</span>[</span>j</span>]</span> =</span> (</span>temp</span>[</span>j</span> -</span> 1</span>]</span> +</span> val</span>)</span> %</span> M</span>;</span>
            }</span>
            dp</span> =</span> temp</span>;</span>
        }</span>
        return</span> ((</span>dp</span>[</span>k</span>]</span> +</span> M</span> -</span> (</span>k</span> &gt;</span> 0</span> ?</span> dp</span>[</span>k</span> -</span> 1</span>]</span> :</span> 0</span>))</span> %</span> M</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">k</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span></span></span></span></span> is filled <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> times.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">(</mo>k</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>