<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>
<a href="#approach-2-iterative-method-using-stack-accepted">Approach #2 Iterative Method Using stack [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>
This solution is very simple. We simply need to do the preorder traversal of the given Binary Tree. But, along with this, we need to make use of braces at appropriate positions. But, we also need to make sure that we omit the unnecessary braces. To do the preorder traversal, we make use of recursion. We print the current node and call the same given function for the left and the right children of the node in that order(if they exist). For every node encountered, the following cases are possible.</p>
Case 1: Both the left child and the right child exist for the current node. In this case, we need to put the braces ()</code> around both the left child's preorder traversal output and the right child's preorder traversal output.</p>
Case 2: None of the left or the right child exist for the current node. In this case, as shown in the figure below, considering empty braces for the null left and right children is redundant. Hence, we need not put braces for any of them.</p>
<img alt="No_child" src="../Figures/606/606_Case2.PNG"></p>
Case 3: Only the left child exists for the current node. As the figure below shows, putting empty braces for the right child in this case is unnecessary while considering the preorder traversal. This is because the right child will always come after the left child in the preorder traversal. Thus, omitting the empty braces for the right child also leads to same mapping between the string and the binary tree.</p>
<img alt="Left_child" src="../Figures/606/606_Case3.PNG"></p>
Case 4: Only the right child exists for the current node. In this case, we need to consider the empty braces for the left child. This is because, during the preorder traversal, the left child needs to be considered first. Thus, to indicate that the child following the current node is a right child we need to put a pair of empty braces for the left child. </p>
<img alt="Right_child" src="../Figures/606/606_Case4.PNG"></p>
Just by taking care of the cases, mentioned above, we can obtain the required output string.</p>
Java</strong></p>
</span>/**</span>
 * Definition for a binary tree node.</span>
 * public class TreeNode {</span>
 *     int val;</span>
 *     TreeNode left;</span>
 *     TreeNode right;</span>
 *     TreeNode(int x) { val = x; }</span>
 * }</span>
 */</span>
public</span> class</span> Solution</span> {</span>
    public</span> String</span> tree2str</span>(</span>TreeNode</span> t</span>)</span> {</span>
        if</span>(</span>t</span>==</span>null</span>)</span>
            return</span> ""</span>;</span>
        if</span>(</span>t</span>.</span>left</span>==</span>null</span> &amp;&amp;</span> t</span>.</span>right</span>==</span>null</span>)</span>
            return</span> t</span>.</span>val</span>+</span>""</span>;</span>
        if</span>(</span>t</span>.</span>right</span>==</span>null</span>)</span>
            return</span> t</span>.</span>val</span>+</span>"("</span>+</span>tree2str</span>(</span>t</span>.</span>left</span>)+</span>")"</span>;</span>
        return</span> t</span>.</span>val</span>+</span>"("</span>+</span>tree2str</span>(</span>t</span>.</span>left</span>)+</span>")("</span>+</span>tree2str</span>(</span>t</span>.</span>right</span>)+</span>")"</span>;</span>   
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The preorder traversal is done over the <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes of the given Binary Tree.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> in case of a skewed tree.</p>
</li>
</ul>

<h4 id="approach-2-iterative-method-using-stack-accepted">Approach #2 Iterative Method Using stack [Accepted]</h4>
Algorithm</strong></p>
In order to solve the given problem, we can also make use of a <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. To see how to do it, we'll go through the implementation and we'll also look at the idea behind each step.</p>
We make use of a <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> onto which various nodes of the given tree will be pushed during the process. The node at the top of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> represents the current node to be processed. Whenever a node has been processed once, it is marked as visited. The reasoning behind this will be discussed soon. </p>
We start off by pushing the root of the binary tree onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. Now, the root acts as the current node. For every current node encountered, firstly, we check if it has not been visited already. If not, we add it to the set of visited nodes. </p>
Since, for the preorder traversal, we know, we need to process the nodes in the order current-left-right. Thus, we add a (</code> followed by the current node to the string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> to be returned. </p>
Now, if both the left and the right children of the current node exist, we need to process them in the order left-right. To do so, we need to push them onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> in the reverse order, so that when they are picked up later on, their order of processing gets corrected.</p>
Since we've already added <span class="maths katex-rendered">(</mo>c</mi>u</mi>r</mi>r</mi>e</mi>n</mi>t</mi>_</mi>n</mi>o</mi>d</mi>e</mi></mrow><annotation encoding="application/x-tex">(current_node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.06em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">c</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span></span> to the string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, if only the right child of the current node exists, as discussed in case 4 in the last approach, we need to put a ()</code> in <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> representing the null left node. We need not push anything onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> for the left node and we can directly add the ()</code> to <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> for this. But, we still need to push the right child onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> for future processing. </p>
If only the left child exists, we need not consider the right child at all, as discussed in case 3 in the last approach. We can continue the process by just pushing the left child onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>.</p>
Now, we need to note that even when a node is being processed, if it has not already been visited, it isn't popped off from the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. But, if a node that has already been processed(i.e. its children have been considered already), it is popped off from the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> when encountered again. Such a situation will occur for a node only when the preorder traversal of both its left and right sub-trees has been completely done. Thus, we need to add a )</code> to mark the end of the preorder traversal of the current node as well.</p>
Thus, at the end, we get the required pre-order traversal in the substring <span class="maths katex-rendered">s</mi>(</mo>1</mn>:</mo>n</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">s(1:n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>(</span><span class="mord mathrm">1</span>:</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> represents the length of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>. This is because, we need not put the parentheses(redundant) at the outermost level.</p>
The following animation better depicts the process.</p>
<div class="diaporama" style="width: 1000px; height: 563px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 13</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> String</span> tree2str</span>(</span>TreeNode</span> t</span>)</span> {</span>
        if</span> (</span>t</span> ==</span> null</span>)</span>
            return</span> ""</span>;</span>
        Stack</span> &lt;</span> TreeNode</span> &gt;</span> stack</span> =</span> new</span> Stack</span> &lt;</span> &gt;</span> ();</span>
        stack</span>.</span>push</span>(</span>t</span>);</span>
        Set</span> &lt;</span> TreeNode</span> &gt;</span> visited</span> =</span> new</span> HashSet</span> &lt;</span> &gt;</span> ();</span>
        StringBuilder</span> s</span> =</span> new</span> StringBuilder</span>();</span>
        while</span> (!</span>stack</span>.</span>isEmpty</span>())</span> {</span>
            t</span> =</span> stack</span>.</span>peek</span>();</span>
            if</span> (</span>visited</span>.</span>contains</span>(</span>t</span>))</span> {</span>
                stack</span>.</span>pop</span>();</span>
                s</span>.</span>append</span>(</span>")"</span>);</span>
            }</span> else</span> {</span>
                visited</span>.</span>add</span>(</span>t</span>);</span>
                s</span>.</span>append</span>(</span>"("</span> +</span> t</span>.</span>val</span>);</span>
                if</span> (</span>t</span>.</span>left</span> ==</span> null</span> &amp;&amp;</span> t</span>.</span>right</span> !=</span> null</span>)</span>
                    s</span>.</span>append</span>(</span>"()"</span>);</span>
                if</span> (</span>t</span>.</span>right</span> !=</span> null</span>)</span>
                    stack</span>.</span>push</span>(</span>t</span>.</span>right</span>);</span>
                if</span> (</span>t</span>.</span>left</span> !=</span> null</span>)</span>
                    stack</span>.</span>push</span>(</span>t</span>.</span>left</span>);</span>
            }</span>
        }</span>
        return</span> s</span>.</span>substring</span>(</span>1</span>,</span> s</span>.</span>length</span>()</span> -</span> 1</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes are pushed and popped in a stack.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> size can grow upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>