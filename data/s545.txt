<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-queue-accepted">Approach #1 Using queue [Accepted]</a></li>
<a href="#approach-2-without-using-extra-space-accepted">Approach #2 Without using extra Space [Accepted]</a></li>
<a href="#approach-3-using-division-and-modulus-accepted">Approach #3  Using division and modulus [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-queue-accepted">Approach #1 Using queue [Accepted]</h4>
Algorithm</strong></p>
The simplest method is to extract all the elements of the given matrix by reading the elements in a row-wise fashion. In this implementation, we use a queue to put the extracted elements. Then, we can take out the elements of the queue formed in a serial order and arrange the elements in the resultant required matrix in a row-by-row order again.</p>
The formation of the resultant matrix won't be possible if the number of elements in the original matrix isn't equal to the number of elements in the resultant matrix.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span>[][]</span> matrixReshape</span>(</span>int</span>[][]</span> nums</span>,</span> int</span> r</span>,</span> int</span> c</span>)</span> {</span>
        int</span>[][]</span> res</span> =</span> new</span> int</span>[</span>r</span>][</span>c</span>];</span>
        if</span> (</span>nums</span>.</span>length</span> ==</span> 0</span> ||</span> r</span> *</span> c</span> !=</span> nums</span>.</span>length</span> *</span> nums</span>[</span>0</span>].</span>length</span>)</span>
            return</span> nums</span>;</span>
        int</span> count</span> =</span> 0</span>;</span>
        Queue</span> &lt;</span> Integer</span> &gt;</span> queue</span> =</span> new</span> LinkedList</span> &lt;</span> &gt;</span> ();</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> nums</span>[</span>0</span>].</span>length</span>;</span> j</span>++)</span> {</span>
                queue</span>.</span>add</span>(</span>nums</span>[</span>i</span>][</span>j</span>]);</span>
            }</span>
        }</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> r</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> c</span>;</span> j</span>++)</span> {</span>
                res</span>[</span>i</span>][</span>j</span>]</span> =</span> queue</span>.</span>remove</span>();</span>
            }</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse over <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> elements twice. Here, <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refer to the number of rows and columns of the given matrix respectively.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The queue formed will be of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-without-using-extra-space-accepted">Approach #2 Without using extra Space [Accepted]</h4>
Algorithm</strong></p>
Instead of unnecessarily using the queue as in the brute force approach, we can keep putting the numbers in the resultant matrix directly while iterating over the given matrix in a row-by-row order. While putting the numbers in the resultant array, we fix a particular row and keep on incrementing the column numbers only till we reach the end of the required columns indicated by <span class="maths katex-rendered">c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span></span></span></span></span>. At this moment, we update the row index by incrementing it and reset the column index to start from 0 again. Thus, we can save the space consumed by the queue for storing the data that just needs to be copied into a new array.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span>[][]</span> matrixReshape</span>(</span>int</span>[][]</span> nums</span>,</span> int</span> r</span>,</span> int</span> c</span>)</span> {</span>
        int</span>[][]</span> res</span> =</span> new</span> int</span>[</span>r</span>][</span>c</span>];</span>
        if</span> (</span>nums</span>.</span>length</span> ==</span> 0</span> ||</span> r</span> *</span> c</span> !=</span> nums</span>.</span>length</span> *</span> nums</span>[</span>0</span>].</span>length</span>)</span>
            return</span> nums</span>;</span>
        int</span> rows</span> =</span> 0</span>,</span> cols</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> nums</span>[</span>0</span>].</span>length</span>;</span> j</span>++)</span> {</span>
                res</span>[</span>rows</span>][</span>cols</span>]</span> =</span> nums</span>[</span>i</span>][</span>j</span>];</span>
                cols</span>++;</span>
                if</span> (</span>cols</span> ==</span> c</span>)</span> {</span>
                    rows</span>++;</span>
                    cols</span> =</span> 0</span>;</span>
                }</span>
            }</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse the entire matrix of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> once only. Here, <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the number of rows and columns in the given matrix.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The resultant matrix of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> is used. </p>
</li>
</ul>

<h4 id="approach-3-using-division-and-modulus-accepted">Approach #3  Using division and modulus [Accepted]</h4>
Algorithm</strong></p>
In the last approach, we needed to keep a track of when we reached the end of columns for the resultant matrix and needed to update the current row and column number for putting the extracted elements by checking the current indices every time. Instead of doing these limit checks at every step, we can make use of maths to help ease the situation. </p>
The idea behind this approach is as follows. Do you know how a 2-D array is stored in the main memory(which is 1-D  in nature)? It is internally represented as a 1-D array only. The element <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array is represented in the form of a one dimensional array by using the index in the form: <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>n</mi>∗</mo>i</mi>+</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[n*i + j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">n</span>∗</span><span class="mord mathit">i</span>+</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, where <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> is the number of columns in the given matrix. Looking at the same in the reverse order, while putting the elements in the elements in the resultant matrix, we can make use of a <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> variable which gets incremented for every element traversed as if we are putting the elements in a 1-D resultant array. But, to convert the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> back into 2-D matrix indices with a column count of <span class="maths katex-rendered">c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span></span></span></span></span>, we can obtain the indices as <span class="maths katex-rendered">r</mi>e</mi>s</mi>[</mo>c</mi>o</mi>u</mi>n</mi>t</mi>/</mi>c</mi>]</mo>[</mo>c</mi>o</mi>u</mi>n</mi>t</mi>%</mi>c</mi>]</mo></mrow><annotation encoding="application/x-tex">res[count/c][count%c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span>[</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm">/</span><span class="mord mathit">c</span>]</span>[</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm">%</span><span class="mord mathit">c</span>]</span></span></span></span></span> where <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>/</mi>c</mi></mrow><annotation encoding="application/x-tex">count/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm">/</span><span class="mord mathit">c</span></span></span></span></span> is the row number and <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>%</mi>c</mi></mrow><annotation encoding="application/x-tex">count%c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathrm">%</span><span class="mord mathit">c</span></span></span></span></span> is the coloumn number. Thus, we can save the extra checking required at each step.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span>[][]</span> matrixReshape</span>(</span>int</span>[][]</span> nums</span>,</span> int</span> r</span>,</span> int</span> c</span>)</span> {</span>
        int</span>[][]</span> res</span> =</span> new</span> int</span>[</span>r</span>][</span>c</span>];</span>
        if</span> (</span>nums</span>.</span>length</span> ==</span> 0</span> ||</span> r</span> *</span> c</span> !=</span> nums</span>.</span>length</span> *</span> nums</span>[</span>0</span>].</span>length</span>)</span>
            return</span> nums</span>;</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> nums</span>[</span>0</span>].</span>length</span>;</span> j</span>++)</span> {</span>
                res</span>[</span>count</span> /</span> c</span>][</span>count</span> %</span> c</span>]</span> =</span> nums</span>[</span>i</span>][</span>j</span>];</span>
                count</span>++;</span>
            }</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse the entire matrix of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> once only. Here, <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the number of rows and columns in the given matrix.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The resultant matrix of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> is used. </p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>