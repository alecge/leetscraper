<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-two-queues-push-o1-pop-on">Approach #1 (Two Queues, push - O(1), pop O(n) )</a></li>
<a href="#approach-2-two-queues-push-on-pop-o1">Approach #2 (Two Queues, push - O(n), pop O(1) )</a></li>
<a href="#approach-3-one-queue-push-on-pop-o1">Approach #3 (One Queue, push - O(n), pop O(1) )</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
This article is for beginners. It introduces the following ideas:
Stack, Queue.</p>
Solution</h2>

<h4 id="approach-1-two-queues-push-o1-pop-on">Approach #1 (Two Queues, push - <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>, pop <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> )</h4>
Intuition</strong></p>
Stack is LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called top</code>.
In general stack is implemented using array or linked list, but in the current article we will review a different approach for implementing stack using queues. In contrast queue is FIFO</strong> (first in - first out) data structure, in which elements are added only from the one side - rear</code> and removed from the other - front</code>. In order to implement stack using queues, we need to maintain two queues q1</code> and q2</code>. Also we will keep top stack element in a constant memory.</p>
Algorithm</strong></p>
Push</strong></p>
The new element is always added to the rear of queue q1</code> and it is kept as top</code> stack element</p>
<img alt="Push an element in stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_pushA.png" width="539px"></p>
Figure 1. Push an element in stack</em></p>
Java</strong></p>
</span>private</span> Queue</span>&lt;</span>Integer</span>&gt;</span> q1</span> =</span> new</span> LinkedList</span>&lt;&gt;();</span>
private</span> Queue</span>&lt;</span>Integer</span>&gt;</span> q2</span> =</span> new</span> LinkedList</span>&lt;&gt;();</span>
private</span> int</span> top</span>;</span>

// Push element x onto stack.</span>
public</span> void</span> push</span>(</span>int</span> x</span>)</span> {</span>
    q1</span>.</span>add</span>(</span>x</span>);</span>
    top</span> =</span> x</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Queue is implemented as linked list and add</code> operation has <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> time complexity.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>
</p>
</li>
</ul>
Pop</strong></p>
We need to remove the element from the top of the stack. This is the last inserted element in q1</code>.
Because queue is FIFO (first in - first out) data structure, the last inserted element could be removed only after all elements, except it, have been removed. For this reason we need to maintain additional queue q2</code>, which will serve as a temporary storage to enqueue the removed elements from q1. The last inserted element in q2</code> is kept as top. Then the algorithm removes the last element in q1</code>. We swap q1</code> with q2</code> to avoid copying all elements from q2</code> to q1</code>.</p>
<img alt="Pop an element from stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_popA.png" width="539px"></p>
Figure 2. Pop an element from stack</em></p>
Java</strong></p>
</span>// Removes the element on top of the stack.</span>
public</span> void</span> pop</span>()</span> {</span>
    while</span> (</span>q1</span>.</span>size</span>()</span> &gt;</span> 1</span>)</span> {</span>
        top</span> =</span> q1</span>.</span>remove</span>();</span>
        q2</span>.</span>add</span>(</span>top</span>);</span>
    }</span>
    q1</span>.</span>remove</span>();</span>
    Queue</span>&lt;</span>Integer</span>&gt;</span> temp</span> =</span> q1</span>;</span>
    q1</span> =</span> q2</span>;</span>
    q2</span> =</span> temp</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The algorithm  dequeues n elements from q1</code> and enqueues <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> elements to q2</code>, where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the stack size. This gives <span class="maths katex-rendered">2</mn>n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">2n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> operations.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
</ul>

<h4 id="approach-2-two-queues-push-on-pop-o1">Approach #2 (Two Queues, push - <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, pop <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> )</h4>
Algorithm</strong></p>
Push</strong></p>
The algorithm inserts each new element to queue q2</code> and keep it as the top</code> element. In case queue q1</code> is not empty (there are elements in the stack), we remove all elements from q1</code> and add them to q2</code>. In this way the new inserted element (top</code> element in the stack) will be always positioned at the front of q2</code>. We swap q1</code> with q2</code> to avoid copying all elements from q2</code> to q1</code>.</p>
<img alt="Push an element in stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_pushB.png" width="539px"></p>
Figure 3. Push an element in stack</em></p>
Java</strong></p>
</span>public</span> void</span> push</span>(</span>int</span> x</span>)</span> {</span>
    q2</span>.</span>add</span>(</span>x</span>);</span>
    top</span> =</span> x</span>;</span>
    while</span> (!</span>q1</span>.</span>isEmpty</span>())</span> {</span>                
        q2</span>.</span>add</span>(</span>q1</span>.</span>remove</span>());</span>
    }</span>
    Queue</span>&lt;</span>Integer</span>&gt;</span> temp</span> =</span> q1</span>;</span>
    q1</span> =</span> q2</span>;</span>
    q2</span> =</span> temp</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The algorithm  removes n elements from q1</code> and inserts <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> elements to q2</code>, where n is the stack size. This gives <span class="maths katex-rendered">2</mn>n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">2n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> operations. The operations add</code> and remove</code> in linked lists has <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> complexity.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>
Pop</strong></p>
The algorithm dequeues an element from  queue q1</code> and keeps front element of q1</code> as top</code>.</p>
<img alt="Pop an element from stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_popB.png" width="539px"></p>
Figure 4. Pop an element from stack</em></p>
Java</strong></p>
</span>// Removes the element on top of the stack.</span>
public</span> void</span> pop</span>()</span> {</span>
    q1</span>.</span>remove</span>();</span>
    if</span> (!</span>q1</span>.</span>isEmpty</span>())</span> {</span>
        top</span> =</span> q1</span>.</span>peek</span>();</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
</ul>
In both approaches empty</code> and top</code> operations have the same implementation.</p>
Empty</strong></p>
Queue q1</code> always contains all stack elements, so the algorithm checks q1</code> size to return if the stack is empty.</p>
</span>// Return whether the stack is empty.</span>
public</span> boolean</span> empty</span>()</span> {</span>
    return</span> q1</span>.</span>isEmpty</span>();</span>
}</span>
</pre></div>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Top</strong></p>
The top</code> element is kept in constant memory and is modified each time when we push or pop an element.</p>
</span>// Get the top element.</span>
public</span> int</span> top</span>()</span> {</span>
    return</span> top</span>;</span>
}</span>
</pre></div>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
 The top</code> element has been calculated in advance and only returned in top</code> operation.</p>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>

<h4 id="approach-3-one-queue-push-on-pop-o1">Approach #3 (One Queue, push - <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, pop <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> )</h4>
The mentioned above two approaches have one weakness, they use two queues. This could be optimized as we use only one queue, instead of two.</p>
Algorithm</strong></p>
Push</strong></p>
When we push an element into a queue, it will be stored at back of the queue due to queue's properties.
But we need to implement a stack, where last inserted element should be in the front of the queue, not at the back. To achieve this we can invert the order of queue elements when pushing a new element.</p>
<img alt="Push an element in stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_pushC.png" width="539px"></p>
Figure 5. Push an element in stack</em></p>
Java</strong></p>
</span>private</span> LinkedList</span>&lt;</span>Integer</span>&gt;</span> q1</span> =</span> new</span> LinkedList</span>&lt;&gt;();</span>

// Push element x onto stack.</span>
public</span> void</span> push</span>(</span>int</span> x</span>)</span> {</span>
    q1</span>.</span>add</span>(</span>x</span>);</span>
    int</span> sz</span> =</span> q1</span>.</span>size</span>();</span>
    while</span> (</span>sz</span> &gt;</span> 1</span>)</span> {</span>
        q1</span>.</span>add</span>(</span>q1</span>.</span>remove</span>());</span>
        sz</span>--;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The algorithm  removes n elements and inserts <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> elements to q1</code> , where n is the stack size. This gives <span class="maths katex-rendered">2</mn>n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">2n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> operations. The operations add</code> and remove</code> in linked lists has <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> complexity.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>
Pop</strong></p>
The last inserted element is always stored at the front of q1</code> and we can pop it for constant time.</p>
Java</strong></p>
</span>// Removes the element on top of the stack.</span>
public</span> void</span> pop</span>()</span> {</span>
    q1</span>.</span>remove</span>();</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
</ul>
Empty</strong></p>
Queue q1</code> contains all stack elements, so the algorithm checks if q1</code> is empty.</p>
</span>// Return whether the stack is empty.</span>
public</span> boolean</span> empty</span>()</span> {</span>
    return</span> q1</span>.</span>isEmpty</span>();</span>
}</span>
</pre></div>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Top</strong></p>
The top</code> element is always positioned at the front of q1</code>. Algorithm return it.</p>
</span>// Get the top element.</span>
public</span> int</span> top</span>()</span> {</span>
    return</span> q1</span>.</span>peek</span>();</span>
}</span>
</pre></div>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
Analysis written by: @elmirap.</p>