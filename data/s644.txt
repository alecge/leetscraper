<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>
Intuition</strong></p>
Let trim(node)</code> be the desired answer for the subtree at that node.  We can construct the answer recursively.</p>
Algorithm</strong></p>
When <span class="maths katex-rendered">text{node.val &gt; R}</span><script type="math/tex">text{node.val > R}</script></span>, we know that the trimmed binary tree must occur to the left of the node. Similarly, when <span class="maths katex-rendered">(text{node.val &lt; L})</span>, the trimmed binary tree occurs to the right of the node. Otherwise, we will trim both sides of the tree.</p>
Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> TreeNode</span> trimBST</span>(</span>TreeNode</span> root</span>,</span> int</span> L</span>,</span> int</span> R</span>)</span> {</span>
        if</span> (</span>root</span> ==</span> null</span>)</span> return</span> root</span>;</span>
        if</span> (</span>root</span>.</span>val</span> &gt;</span> R</span>)</span> return</span> trimBST</span>(</span>root</span>.</span>left</span>,</span> L</span>,</span> R</span>);</span>
        if</span> (</span>root</span>.</span>val</span> &lt;</span> L</span>)</span> return</span> trimBST</span>(</span>root</span>.</span>right</span>,</span> L</span>,</span> R</span>);</span>

        root</span>.</span>left</span> =</span> trimBST</span>(</span>root</span>.</span>left</span>,</span> L</span>,</span> R</span>);</span>
        root</span>.</span>right</span> =</span> trimBST</span>(</span>root</span>.</span>right</span>,</span> L</span>,</span> R</span>);</span>
        return</span> root</span>;</span>
    }</span>
}</span>
</pre></div>


Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> trimBST</span>(</span>self</span>,</span> root</span>,</span> L</span>,</span> R</span>):</span>
        def</span> trim</span>(</span>node</span>):</span>
            if</span> not</span> node</span>:</span>
                return</span> None</span>
            elif</span> node</span>.</span>val</span> &gt;</span> R</span>:</span>
                return</span> trim</span>(</span>node</span>.</span>left</span>)</span>
            elif</span> node</span>.</span>val</span> &lt;</span> L</span>:</span>
                return</span> trim</span>(</span>node</span>.</span>right</span>)</span>
            else</span>:</span>
                node</span>.</span>left</span> =</span> trim</span>(</span>node</span>.</span>left</span>)</span>
                node</span>.</span>right</span> =</span> trim</span>(</span>node</span>.</span>right</span>)</span>
                return</span> node</span>

        return</span> trim</span>(</span>root</span>)</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the total number of nodes in the given tree.  We visit each node at most once.</p>
</li>

Space Complexity: <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.  Even though we don't explicitly use any additional memory, the call stack of our recursion could be as large as the number of nodes in the worst case.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>