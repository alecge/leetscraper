<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>
<a href="#approach-3-using-2-d-dynamic-programming-accepted">Approach #3 Using 2-d Dynamic Programming [Accepted]</a></li>
<a href="#approach-4-using-1-d-dynamic-programming-accepted">Approach #4 Using 1-d Dynamic Programming [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
We need to determine whether a given string can be formed by interleaving the other two strings.</p>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
The most basic idea is to find every string possible by all interleavings of the two given strings(<span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>).
In order to implement this method, we are using recursion. We start by taking the current character of the
first string(<span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span>) and then appending all possible interleavings of the remaining portion of the first string(<span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span>) and the second string(<span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>)
and comparing each result formed with the required interleaved string(<span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>). Similarly, we choose one character from the second
string(<span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>) and form all the interleavings with the remaining portion of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> to check if the required string <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> can be formed.</p>
For implementing the recursive function, we make the function call recursively as
<span class="maths katex-rendered">i</mi>s</mi>I</mi></msub>n</mi>t</mi>e</mi>r</mi>l</mi>e</mi>a</mi>v</mi>e</mi>(</mo>s</mi>1</mn>,</mo>i</mi>+</mo>1</mn>,</mo>s</mi>2</mn>,</mo>j</mi>,</mo>r</mi>e</mi>s</mi>+</mo>s</mi>1</mn>.</mi>c</mi>h</mi>a</mi>r</mi>A</mi>t</mi>(</mo>i</mi>)</mo>,</mo>s</mi>3</mn>)</mo></mrow><annotation encoding="application/x-tex">is_Interleave(s1,i+1,s2,j,res+s1.charAt(i),s3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.07847em;">I</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">e</span>(</span><span class="mord mathit">s</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">2</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span>+</span><span class="mord mathit">s</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">A</span><span class="mord mathit">t</span>(</span><span class="mord mathit">i</span>)</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">3</span>)</span></span></span></span></span> in which we have chosen the current character from <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and then make another function call <span class="maths katex-rendered">i</mi>s</mi>I</mi></msub>n</mi>t</mi>e</mi>r</mi>l</mi>e</mi>a</mi>v</mi>e</mi>(</mo>s</mi>1</mn>,</mo>i</mi>,</mo>s</mi>2</mn>,</mo>j</mi>+</mo>1</mn>,</mo>r</mi>e</mi>s</mi>+</mo>s</mi>2</mn>.</mi>c</mi>h</mi>a</mi>r</mi>A</mi>t</mi>(</mo>j</mi>)</mo>,</mo>s</mi>3</mn>)</mo></mrow><annotation encoding="application/x-tex">is_Interleave(s1,i,s2,j+1,res+s2.charAt(j),s3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.07847em;">I</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">e</span>(</span><span class="mord mathit">s</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">i</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">2</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span>+</span><span class="mord mathit">s</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">A</span><span class="mord mathit">t</span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">3</span>)</span></span></span></span></span>, in which the current character of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> is chosen. Here, <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> refers to that portion(interleaved) of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> which has already been processed. If anyone of these calls return the result as <span class="maths katex-rendered">T</mi>r</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">True</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>, it means that atleast one interleaving gives the required result <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>. The recursive calls end when both the strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> have been fully processed.</p>
Let's look at a small example to see how the execution proceeds.</p>
</span>s1="abc"
s2="bcd"
s3="abcbdc"
</pre></div>


Firstly we choose 'a' of s1 as the processed part i.e. res and call the recursive function considering the new strings as s1="bc",
s2="bcd", s3="abcbdc". When this function returns a result, we again call the recursive function but with the new strings as s1="abc", s2="cd", s3="abcbdc"</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> is_Interleave</span>(</span>String</span> s1</span>,</span>int</span> i</span>,</span>String</span> s2</span>,</span>int</span> j</span>,</span>String</span> res</span>,</span>String</span> s3</span>)</span>
    {</span>
        if</span>(</span>res</span>.</span>equals</span>(</span>s3</span>)</span> &amp;&amp;</span> i</span>==</span>s1</span>.</span>length</span>()</span> &amp;&amp;</span> j</span>==</span>s2</span>.</span>length</span>())</span>
            return</span> true</span>;</span>
        boolean</span> ans</span>=</span>false</span>;</span>
        if</span>(</span>i</span>&lt;</span>s1</span>.</span>length</span>())</span>
            ans</span>|=</span>is_Interleave</span>(</span>s1</span>,</span>i</span>+</span>1</span>,</span>s2</span>,</span>j</span>,</span>res</span>+</span>s1</span>.</span>charAt</span>(</span>i</span>),</span>s3</span>);</span>
        if</span>(</span>j</span>&lt;</span>s2</span>.</span>length</span>())</span>
            ans</span>|=</span>is_Interleave</span>(</span>s1</span>,</span>i</span>,</span>s2</span>,</span>j</span>+</span>1</span>,</span>res</span>+</span>s2</span>.</span>charAt</span>(</span>j</span>),</span>s3</span>);</span>
        return</span> ans</span>;</span>

    }</span>
    public</span> boolean</span> isInterleave</span>(</span>String</span> s1</span>,</span> String</span> s2</span>,</span> String</span> s3</span>)</span> {</span>
        return</span> is_Interleave</span>(</span>s1</span>,</span>0</span>,</span>s2</span>,</span>0</span>,</span>""</span>,</span>s3</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>2</mn>(</mo></msup>m</mi>+</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.888em;"></span><span class="strut bottom" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> is the length of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the length of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>+</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The size of stack for recursive calls can go upto <span class="maths katex-rendered">m</mi>+</mo>n</mi></mrow><annotation encoding="application/x-tex">m+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.58333em;"></span><span class="strut bottom" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>
Algorithm</strong></p>
In the recursive approach discussed above, we are considering every possible string formed by interleaving the two given
strings. But, there will be cases encountered in which, the same portion of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> would have been processed already
but in different orders(permutations). But irrespective of the order of processing, if the resultant string formed till now
is matching with the required string(<span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>), the final result is dependent only on the remaining portions of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>, but
not on the already processed portion. Thus, the recursive approach leads to redundant computations.</p>
This redundancy can be removed by making use of memoization along with recursion. For this, we maitain 3 pointers <span class="maths katex-rendered">i</mi>,</mo>j</mi>,</mo>k</mi></mrow><annotation encoding="application/x-tex">i, j, k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>
 which correspond to the index of the current character of <span class="maths katex-rendered">s</mi>1</mn>,</mo>s</mi>2</mn>,</mo>s</mi>3</mn></mrow><annotation encoding="application/x-tex">s1, s2, s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">2</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span> respectively. Also, we maintain a 2-d memo array to keep a track of the substrings processed so far. <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">memo[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> stores a 1/0 or -1 depending on
 whether the current portion of strings i.e. upto <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index for <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and upto <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index for s2 has already been evaluated. Again, we start by selecting the current character of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span>(pointed by $$i$). If it matches the current character
 of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>(pointed by <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>), we include it in the processed string and call the same function recurively as:
 <span class="maths katex-rendered">i</mi>s</mi>_</mi>I</mi>n</mi>t</mi>e</mi>r</mi>l</mi>e</mi>a</mi>v</mi>e</mi>(</mo>s</mi>1</mn>,</mo>i</mi>+</mo>1</mn>,</mo>s</mi>2</mn>,</mo>j</mi>,</mo>s</mi>3</mn>,</mo>k</mi>+</mo>1</mn>,</mo>m</mi>e</mi>m</mi>o</mi>)</mo></mrow><annotation encoding="application/x-tex">is_Interleave(s1, i+1, s2, j, s3, k+1,memo)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.06em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">e</span>(</span><span class="mord mathit">s</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">2</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>,</span><span class="mord mathit">s</span><span class="mord mathrm">3</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span>)</span></span></span></span></span>
</p>
Thus, here we have called the function by incrementing the pointers <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> since the portion of strings upto those indices
 has already been processed. Similarly, we choose one character from the second string and continue. The recursive function
 ends when either of the two strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> or <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> has been fully processed. If, let's say, the string <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> has been fully processed,
 we directly compare the remaining portion of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> with the remaining portion of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>. When the backtrack occurs from the recursive
 calls, we store the value returned by the recursive functions in the memoization array memo appropriatelys so that when it is encountered the next time, the recursive function won't be called, but the memoization array itself will return the previous generated result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> is_Interleave</span>(</span>String</span> s1</span>,</span> int</span> i</span>,</span> String</span> s2</span>,</span> int</span> j</span>,</span> String</span> s3</span>,</span> int</span> k</span>,</span> int</span>[][]</span> memo</span>)</span> {</span>
        if</span> (</span>i</span> ==</span> s1</span>.</span>length</span>())</span> {</span>
            return</span> s2</span>.</span>substring</span>(</span>j</span>).</span>equals</span>(</span>s3</span>.</span>substring</span>(</span>k</span>));</span>
        }</span>
        if</span> (</span>j</span> ==</span> s2</span>.</span>length</span>())</span> {</span>
            return</span> s1</span>.</span>substring</span>(</span>i</span>).</span>equals</span>(</span>s3</span>.</span>substring</span>(</span>k</span>));</span>
        }</span>
        if</span> (</span>memo</span>[</span>i</span>][</span>j</span>]</span> &gt;=</span> 0</span>)</span> {</span>
            return</span> memo</span>[</span>i</span>][</span>j</span>]</span> ==</span> 1</span> ?</span> true</span> :</span> false</span>;</span>
        }</span>
        boolean</span> ans</span> =</span> false</span>;</span>
        if</span> (</span>s3</span>.</span>charAt</span>(</span>k</span>)</span> ==</span> s1</span>.</span>charAt</span>(</span>i</span>)</span> &amp;&amp;</span> is_Interleave</span>(</span>s1</span>,</span> i</span> +</span> 1</span>,</span> s2</span>,</span> j</span>,</span> s3</span>,</span> k</span> +</span> 1</span>,</span> memo</span>)</span>
                ||</span> s3</span>.</span>charAt</span>(</span>k</span>)</span> ==</span> s2</span>.</span>charAt</span>(</span>j</span>)</span> &amp;&amp;</span> is_Interleave</span>(</span>s1</span>,</span> i</span>,</span> s2</span>,</span> j</span> +</span> 1</span>,</span> s3</span>,</span> k</span> +</span> 1</span>,</span> memo</span>))</span> {</span>
            ans</span> =</span> true</span>;</span>
        }</span>
        memo</span>[</span>i</span>][</span>j</span>]</span> =</span> ans</span> ?</span> 1</span> :</span> 0</span>;</span>
        return</span> ans</span>;</span>
    }</span>
    public</span> boolean</span> isInterleave</span>(</span>String</span> s1</span>,</span> String</span> s2</span>,</span> String</span> s3</span>)</span> {</span>
        int</span> memo</span>[][]</span> =</span> new</span> int</span>[</span>s1</span>.</span>length</span>()][</span>s2</span>.</span>length</span>()];</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> s1</span>.</span>length</span>();</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> s2</span>.</span>length</span>();</span> j</span>++)</span> {</span>
                memo</span>[</span>i</span>][</span>j</span>]</span> =</span> -</span>1</span>;</span>
            }</span>
        }</span>
        return</span> is_Interleave</span>(</span>s1</span>,</span> 0</span>,</span> s2</span>,</span> 0</span>,</span> s3</span>,</span> 0</span>,</span> memo</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>2</mn>(</mo></msup>m</mi>+</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.888em;"></span><span class="strut bottom" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> is the length of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the length of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>+</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The size of stack for recursive calls can go upto <span class="maths katex-rendered">m</mi>+</mo>n</mi></mrow><annotation encoding="application/x-tex">m+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.58333em;"></span><span class="strut bottom" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-3-using-2-d-dynamic-programming-accepted">Approach #3 Using 2-d Dynamic Programming [Accepted]</h4>
Algorithm</strong></p>
The recursive approach discussed in above solution included a character from one of the strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> or <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> in the resultant
interleaved string and called a recursive function to check whether the remaining portions of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> can be interleaved
to form the remaining portion of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>. In the current approach, we
 look at the same problem the other way around. Here, we include one character from <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> or <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> and check whether the
 resultant string formed so far by one particular interleaving of the the current prefix of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> form a prefix of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>.</p>
Thus, this approach relies on the fact that the in order to determine whether a substring
 of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>(upto index <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>), can be formed by interleaving strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> upto indices <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> respectively, solely depends
 on the characters of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> upto indices <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> only and not on the characters coming afterwards.</p>
To implement this method, we'll make use of a 2-d boolean array <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span>. In this array <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> implies if it is possible to
 obtain a substring of length <span class="maths katex-rendered">(</mo>i</mi>+</mo>j</mi>+</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">(i+j+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>+</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">2</span>)</span></span></span></span></span> which is a prefix of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span> by some interleaving of prefixes of strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> having
 lengths <span class="maths katex-rendered">(</mo>i</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> and <span class="maths katex-rendered">(</mo>j</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> respectively. For filling in the entry of <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, we need to consider two cases:</p>


The character
 just included i.e. either at <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> or at <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> doesn't match the character at <span class="maths katex-rendered">k</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>, where <span class="maths katex-rendered">k</mi>=</mo>i</mi>+</mo>j</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">k=i+j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>=</span><span class="mord mathit">i</span>+</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span></span></span></span></span>.
 In this case, the resultant string formed using some interleaving of prefixes of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> can never result in a prefix of length <span class="maths katex-rendered">k</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span></span></span></span></span> in <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>. Thus, we enter <span class="maths katex-rendered">F</mi>a</mi>l</mi>s</mi>e</mi></mrow><annotation encoding="application/x-tex">False</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></span> at the character <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>.</p>
</li>

The character
 just included i.e. either at <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> or at <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>  matches the character at <span class="maths katex-rendered">k</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>, where <span class="maths katex-rendered">k</mi>=</mo>i</mi>+</mo>j</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">k=i+j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>=</span><span class="mord mathit">i</span>+</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span></span></span></span></span>.
Now, if the character just included(say <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>) which matches the character at <span class="maths katex-rendered">k</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>, is the character at <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index of <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span>, we need to keep <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> at the last position in the resultant interleaved string formed so far. Thus, in order to use string <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> upto indices <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> to form a resultant string of length <span class="maths katex-rendered">(</mo>i</mi>+</mo>j</mi>+</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">(i+j+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>+</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">2</span>)</span></span></span></span></span> which is a prefix of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>, we need to ensure that the strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> upto indices <span class="maths katex-rendered">(</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> respectively obey the same property.</p>
</li>
</ol>
Similarly, if we just included the <span class="maths katex-rendered">j</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character of <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span>, which matches with the <span class="maths katex-rendered">k</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character of <span class="maths katex-rendered">s</mi>3</mn></mrow><annotation encoding="application/x-tex">s3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">3</span></span></span></span></span>, we need to ensure that the strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> upto indices <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">(</mo>j</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(j-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> also obey the same
property to enter a <span class="maths katex-rendered">t</mi>r</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> at <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>.</p>
This can be made clear with the following example:</p>
</span>s1="aabcc"
s2="dbbca"
s3="aadbbcbcac"
</pre></div>


<!--![97_Interleaving](../Figures/97_Interleaving.gif)-->

<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 36</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> isInterleave</span>(</span>String</span> s1</span>,</span> String</span> s2</span>,</span> String</span> s3</span>)</span> {</span>
        if</span> (</span>s3</span>.</span>length</span>()</span> !=</span> s1</span>.</span>length</span>()</span> +</span> s2</span>.</span>length</span>())</span> {</span>
            return</span> false</span>;</span>
        }</span>
        boolean</span> dp</span>[][]</span> =</span> new</span> boolean</span>[</span>s1</span>.</span>length</span>()</span> +</span> 1</span>][</span>s2</span>.</span>length</span>()</span> +</span> 1</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;=</span> s1</span>.</span>length</span>();</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;=</span> s2</span>.</span>length</span>();</span> j</span>++)</span> {</span>
                if</span> (</span>i</span> ==</span> 0</span> &amp;&amp;</span> j</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> true</span>;</span>
                }</span> else</span> if</span> (</span>i</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> dp</span>[</span>i</span>][</span>j</span> -</span> 1</span>]</span> &amp;&amp;</span> s2</span>.</span>charAt</span>(</span>j</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>);</span>
                }</span> else</span> if</span> (</span>j</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span>]</span> &amp;&amp;</span> s1</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>);</span>
                }</span> else</span> {</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> (</span>dp</span>[</span>i</span> -</span> 1</span>][</span>j</span>]</span> &amp;&amp;</span> s1</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>))</span> ||</span> (</span>dp</span>[</span>i</span>][</span>j</span> -</span> 1</span>]</span> &amp;&amp;</span> s2</span>.</span>charAt</span>(</span>j</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>));</span>
                }</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>s1</span>.</span>length</span>()][</span>s2</span>.</span>length</span>()];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. dp array of size <span class="maths katex-rendered">m</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.46528em;"></span><span class="strut bottom" style="height: 0.46528em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span></span></span></span></span> is filled.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. 2-d DP of size <span class="maths katex-rendered">(</mo>m</mi>+</mo>1</mn>)</mo>∗</mo>(</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(m+1)*(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">m</span>+</span><span class="mord mathrm">1</span>)</span>∗</span>(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> is required. <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> are the lengths of strings <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>2</mn></mrow><annotation encoding="application/x-tex">s2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span></span> repectively.</p>
</li>
</ul>

<h4 id="approach-4-using-1-d-dynamic-programming-accepted">Approach #4 Using 1-d Dynamic Programming [Accepted]:</h4>
Algorithm</strong></p>
This approach is the same as the previous approach except that we have used only 1-d <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array to store the results of the
 prefixes of the strings processed so far. Instead of maintaining a 2-d array, we can maintain a 1-d array only and update the
 array's element <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> when needed using <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and the previous value of <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> isInterleave</span>(</span>String</span> s1</span>,</span> String</span> s2</span>,</span> String</span> s3</span>)</span> {</span>
        if</span> (</span>s3</span>.</span>length</span>()</span> !=</span> s1</span>.</span>length</span>()</span> +</span> s2</span>.</span>length</span>())</span> {</span>
            return</span> false</span>;</span>
        }</span>
        boolean</span> dp</span>[]</span> =</span> new</span> boolean</span>[</span>s2</span>.</span>length</span>()</span> +</span> 1</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;=</span> s1</span>.</span>length</span>();</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;=</span> s2</span>.</span>length</span>();</span> j</span>++)</span> {</span>
                if</span> (</span>i</span> ==</span> 0</span> &amp;&amp;</span> j</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>j</span>]</span> =</span> true</span>;</span>
                }</span> else</span> if</span> (</span>i</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>j</span>]</span> =</span> dp</span>[</span>j</span> -</span> 1</span>]</span> &amp;&amp;</span> s2</span>.</span>charAt</span>(</span>j</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>);</span>
                }</span> else</span> if</span> (</span>j</span> ==</span> 0</span>)</span> {</span>
                    dp</span>[</span>j</span>]</span> =</span> dp</span>[</span>j</span>]</span> &amp;&amp;</span> s1</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>);</span>
                }</span> else</span> {</span>
                    dp</span>[</span>j</span>]</span> =</span> (</span>dp</span>[</span>j</span>]</span> &amp;&amp;</span> s1</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>))</span> ||</span> (</span>dp</span>[</span>j</span> -</span> 1</span>]</span> &amp;&amp;</span> s2</span>.</span>charAt</span>(</span>j</span> -</span> 1</span>)</span> ==</span> s3</span>.</span>charAt</span>(</span>i</span> +</span> j</span> -</span> 1</span>));</span>
                }</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>s2</span>.</span>length</span>()];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. dp array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is filled <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> times.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the length of the string <span class="maths katex-rendered">s</mi>1</mn></mrow><annotation encoding="application/x-tex">s1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span></span>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>