<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-memory-limit-exceeded">Approach #1: Brute Force [Memory Limit Exceeded]</a></li>
<a href="#approach-2-next-heap-time-limit-exceeded">Approach #2: Next Heap [Time Limit Exceeded]</a></li>
<a href="#approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-memory-limit-exceeded">Approach #1: Brute Force [Memory Limit Exceeded]</h4>
Intuition and Algorithm</strong></p>
Create the multiplication table and sort it, then take the <span class="maths katex-rendered">k</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> findKthNumber</span>(</span>self</span>,</span> m</span>,</span> n</span>,</span> k</span>):</span>
        table</span> =</span> [</span>i</span>*</span>j</span> for</span> i</span> in</span> range</span>(</span>1</span>,</span> m</span>+</span>1</span>)</span> for</span> j</span> in</span> range</span>(</span>1</span>,</span> n</span>+</span>1</span>)]</span>
        table</span>.</span>sort</span>()</span>
        return</span> table</span>[</span>k</span>-</span>1</span>]</span>
</pre></div>


Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> int</span> findKthNumber</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span>[]</span> table</span> =</span> new</span> int</span>[</span>m</span>*</span>n</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> m</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 1</span>;</span> j</span> &lt;=</span> n</span>;</span> j</span>++)</span> {</span>
                table</span>[(</span>i</span> -</span> 1</span>)</span> *</span> n</span> +</span> j</span> -</span> 1</span>]</span> =</span> i</span> *</span> j</span>;</span>
            }</span>
        }</span>
        Arrays</span>.</span>sort</span>(</span>table</span>);</span>
        return</span> table</span>[</span>k</span>-</span>1</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span> to create the table, and <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>log</mi>(</mo>m</mi>∗</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(m*nlog(m*n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> to sort it.</p>
</li>

Space Complexity:  <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span> to store the table.</p>
</li>
</ul>

<h4 id="approach-2-next-heap-time-limit-exceeded">Approach #2: Next Heap [Time Limit Exceeded]</h4>
Intuition</strong></p>
Maintain a heap of the smallest unused element of each row.  Then, finding the next element is a pop operation on the heap.</p>
Algorithm</strong></p>
Our heap</code> is going to consist of elements <span class="maths katex-rendered">(</mi>v</mi>a</mi>l</mi>,</mi>&nbsp;</mtext>r</mi>o</mi>o</mi>t</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{(val, root)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">(val,&nbsp;root)</span></span></span></span></span></span>, where <span class="maths katex-rendered">v</mi>a</mi>l</mi></mtext></mrow><annotation encoding="application/x-tex">text{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">val</span></span></span></span></span></span> is the next unused value of that row, and <span class="maths katex-rendered">r</mi>o</mi>o</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{root}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">root</span></span></span></span></span></span> was the starting value of that row.</p>
We will repeatedly find the next lowest element in the table.  To do this, we pop from the heap.  Then, if there's a next lowest element in that row, we'll put that element back on the heap.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> findKthNumber</span>(</span>self</span>,</span> m</span>,</span> n</span>,</span> k</span>):</span>
        heap</span> =</span> [(</span>i</span>,</span> i</span>)</span> for</span> i</span> in</span> range</span>(</span>1</span>,</span> m</span>+</span>1</span>)]</span>
        heapq</span>.</span>heapify</span>(</span>heap</span>)</span>

        for</span> _</span> in</span> xrange</span>(</span>k</span>):</span>
            val</span>,</span> root</span> =</span> heapq</span>.</span>heappop</span>(</span>heap</span>)</span>
            nxt</span> =</span> val</span> +</span> root</span>
            if</span> nxt</span> &lt;=</span> root</span> *</span> n</span>:</span>
                heapq</span>.</span>heappush</span>(</span>heap</span>,</span> (</span>nxt</span>,</span> root</span>))</span>

        return</span> val</span>
</pre></div>


Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> int</span> findKthNumber</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        PriorityQueue</span>&lt;</span>Node</span>&gt;</span> heap</span> =</span> new</span> PriorityQueue</span>&lt;</span>Node</span>&gt;(</span>m</span>,</span>
            Comparator</span>.&lt;</span>Node</span>&gt;</span> comparingInt</span>(</span>node</span> -&gt;</span> node</span>.</span>val</span>));</span>

        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> m</span>;</span> i</span>++)</span> {</span>
            heap</span>.</span>offer</span>(</span>new</span> Node</span>(</span>i</span>,</span> i</span>));</span>
        }</span>

        Node</span> node</span> =</span> null</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> k</span>;</span> i</span>++)</span> {</span>
            node</span> =</span> heap</span>.</span>poll</span>();</span>
            int</span> nxt</span> =</span> node</span>.</span>val</span> +</span> node</span>.</span>root</span>;</span>
            if</span> (</span>nxt</span> &lt;=</span> node</span>.</span>root</span> *</span> n</span>)</span> {</span>
                heap</span>.</span>offer</span>(</span>new</span> Node</span>(</span>nxt</span>,</span> node</span>.</span>root</span>));</span>
            }</span>
        }</span>
        return</span> node</span>.</span>val</span>;</span>
    }</span>
}</span>

class</span> Node</span> {</span>
    int</span> val</span>;</span>
    int</span> root</span>;</span>
    public</span> Node</span>(</span>int</span> v</span>,</span> int</span> r</span>)</span> {</span>
        val</span> =</span> v</span>;</span>
        root</span> =</span> r</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: <span class="maths katex-rendered">O</mi>(</mo>k</mi>∗</mo>m</mi>log</mi>m</mi>)</mo>=</mo>O</mi>(</mo>m</mi>2</mn></msup>n</mi>log</mi>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k * m log m) = O(m^2 n log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>∗</span><span class="mord mathit">m</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">m</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">n</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">m</span>)</span></span></span></span></span>.  Our initial heapify operation is <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span>.  Afterwards, each pop and push is <span class="maths katex-rendered">O</mi>(</mo>m</mi>log</mi>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">m</span>)</span></span></span></span></span>, and our outer loop is <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo>=</mo>O</mi>(</mo>m</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k) = O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>
</p>
</li>

Space Complexity:  <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span>.  Our heap is implemented as an array with <span class="maths katex-rendered">m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span></span> elements.</p>
</li>
</ul>

<h4 id="approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</h4>
Intuition</strong></p>
As <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> and <span class="maths katex-rendered">m</mi>*</mi>n</mi></mtext></mrow><annotation encoding="application/x-tex">text{m*n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 0.75em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">m*n</span></span></span></span></span></span> are up to <span class="maths katex-rendered">9</mn>∗</mo>1</mn>0</mn>8</mn></msup></mrow><annotation encoding="application/x-tex">9 * 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 0.814108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">9</span>∗</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">8</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>, linear solutions will not work.  This motivates solutions with <span class="maths katex-rendered">log</mi></mrow><annotation encoding="application/x-tex">log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped">lo<span style="margin-right: 0.01389em;">g</span></span></span></span></span></span> complexity, such as binary search.</p>
Algorithm</strong></p>
Let's do the binary search for the answer <span class="maths katex-rendered">A</mi></mtext></mrow><annotation encoding="application/x-tex">text{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A</span></span></span></span></span></span>.</p>
Say enough(x)</code> is true if and only if there are <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span> or more values in the multiplication table that are less than or equal to <span class="maths katex-rendered">x</mi></mtext></mrow><annotation encoding="application/x-tex">text{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">x</span></span></span></span></span></span>.  Colloquially, enough</code> describes whether <span class="maths katex-rendered">x</mi></mtext></mrow><annotation encoding="application/x-tex">text{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">x</span></span></span></span></span></span> is large enough to be the <span class="maths katex-rendered">k</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> value in the multiplication table.</p>
Then (for our answer <span class="maths katex-rendered">A</mi></mtext></mrow><annotation encoding="application/x-tex">text{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">A</span></span></span></span></span></span>), whenever <span class="maths katex-rendered">text{x ≥ A}</span><script type="math/tex">text{x ≥ A}</script></span>, enough(x)</code> is True</code>; and whenever <span class="maths katex-rendered">(text{x &lt; A})</span>, enough(x)</code> is False</code>.</p>
In our binary search, our loop invariant is enough(hi) = True</code>.  At the beginning, enough(m*n) = True</code>, and whenever hi</code> is set, it is set to a value that is "enough" (enough(mi) = True</code>).  That means hi</code> will be the lowest such value at the end of our binary search.</p>
This leaves us with the task of counting how many values are less than or equal to <span class="maths katex-rendered">x</mi></mtext></mrow><annotation encoding="application/x-tex">text{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">x</span></span></span></span></span></span>.  For each of <span class="maths katex-rendered">m</mi></mtext></mrow><annotation encoding="application/x-tex">text{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">m</span></span></span></span></span></span> rows, the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> row looks like <span class="maths katex-rendered">[</mi>i</mi>,</mi>&nbsp;</mtext>2</mn>*</mi>i</mi>,</mi>&nbsp;</mtext>3</mn>*</mi>i</mi>,</mi>&nbsp;</mtext>.</mi>.</mi>.</mi>,</mi>&nbsp;</mtext>n</mi>*</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[i, 2*i, 3*i, ..., n*i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[i,&nbsp;2*i,&nbsp;3*i,&nbsp;...,&nbsp;n*i]</span></span></span></span></span></span>.  The largest possible <span class="maths katex-rendered">(text{k*i ≤ x})</span> that could appear is <span class="maths katex-rendered">k</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>x</mi>&nbsp;</mtext>/</mi>/</mi>&nbsp;</mtext>i</mi></mtext></mrow><annotation encoding="application/x-tex">text{k = x // i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k&nbsp;=&nbsp;x&nbsp;//&nbsp;i</span></span></span></span></span></span>. However, if <span class="maths katex-rendered">x</mi></mtext></mrow><annotation encoding="application/x-tex">text{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">x</span></span></span></span></span></span> is really big, then perhaps <span class="maths katex-rendered">(text{k &gt; n})</span>, so in total there are <span class="maths katex-rendered">m</mi>i</mi>n</mi>(</mi>k</mi>,</mi>&nbsp;</mtext>n</mi>)</mi>&nbsp;</mtext>=</mi>&nbsp;</mtext>m</mi>i</mi>n</mi>(</mi>x</mi>&nbsp;</mtext>/</mi>/</mi>&nbsp;</mtext>i</mi>,</mi>&nbsp;</mtext>n</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{min(k, n) = min(x // i, n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">min(k,&nbsp;n)&nbsp;=&nbsp;min(x&nbsp;//&nbsp;i,&nbsp;n)</span></span></span></span></span></span> values in that row that are less than or equal to <span class="maths katex-rendered">x</mi></mtext></mrow><annotation encoding="application/x-tex">text{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">x</span></span></span></span></span></span>.</p>
After we have the count of how many values in the table are less than or equal to <span class="maths katex-rendered">x</mi></mtext></mrow><annotation encoding="application/x-tex">text{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">x</span></span></span></span></span></span>, by the definition of enough(x)</code>, we want to know if that count is greater than or equal to <span class="maths katex-rendered">k</mi></mtext></mrow><annotation encoding="application/x-tex">text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">k</span></span></span></span></span></span>.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> findKthNumber</span>(</span>self</span>,</span> m</span>,</span> n</span>,</span> k</span>):</span>
        def</span> enough</span>(</span>x</span>):</span>
            count</span> =</span> 0</span>
            for</span> i</span> in</span> xrange</span>(</span>1</span>,</span> m</span>+</span>1</span>):</span>
                count</span> +=</span> min</span>(</span>x</span> //</span> i</span>,</span> n</span>)</span>
            return</span> count</span> &gt;=</span> k</span>

        lo</span>,</span> hi</span> =</span> 1</span>,</span> m</span> *</span> n</span>
        while</span> lo</span> &lt;</span> hi</span>:</span>
            mi</span> =</span> (</span>lo</span> +</span> hi</span>)</span> /</span> 2</span>
            if</span> not</span> enough</span>(</span>mi</span>):</span>
                lo</span> =</span> mi</span> +</span> 1</span>
            else</span>:</span>
                hi</span> =</span> mi</span>
        return</span> lo</span>
</pre></div>


Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> boolean</span> enough</span>(</span>int</span> x</span>,</span> int</span> m</span>,</span> int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> m</span>;</span> i</span>++)</span> {</span>
            count</span> +=</span> Math</span>.</span>min</span>(</span>x</span> /</span> i</span>,</span> n</span>);</span>
        }</span>
        return</span> count</span> &gt;=</span> k</span>;</span>
    }</span>

    public</span> int</span> findKthNumber</span>(</span>int</span> m</span>,</span> int</span> n</span>,</span> int</span> k</span>)</span> {</span>
        int</span> lo</span> =</span> 1</span>,</span> hi</span> =</span> m</span> *</span> n</span>;</span>
        while</span> (</span>lo</span> &lt;</span> hi</span>)</span> {</span>
            int</span> mi</span> =</span> lo</span> +</span> (</span>hi</span> -</span> lo</span>)</span> /</span> 2</span>;</span>
            if</span> (!</span>enough</span>(</span>mi</span>,</span> m</span>,</span> n</span>,</span> k</span>))</span> lo</span> =</span> mi</span> +</span> 1</span>;</span>
            else</span> hi</span> =</span> mi</span>;</span>
        }</span>
        return</span> lo</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: <span class="maths katex-rendered">O</mi>(</mo>m</mi>∗</mo>log</mi>(</mo>m</mi>∗</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(m * log (m*n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>∗</span>lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">m</span>∗</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>.  Our binary search divides the interval <span class="maths katex-rendered">[</mi>l</mi>o</mi>,</mi>&nbsp;</mtext>h</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{[lo, hi]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">[lo,&nbsp;hi]</span></span></span></span></span></span> into half at each step.  At each step, we call enough</code> which requires <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span> time.</p>
</li>

Space Complexity:  <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.  We only keep integers in memory during our intermediate calculations.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>