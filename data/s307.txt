<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-naive-time-limit-exceeded">Approach #1 (Naive) [Time Limit Exceeded]</a></li>
<a href="#approach-2-sqrt-decomposition-accepted">Approach #2 (Sqrt decomposition) [Accepted]</a></li>
<a href="#approach-3-segment-tree-accepted">Approach #3 (Segment tree) [Accepted]</a>
<a href="#1-build-segment-tree">1. Build segment tree</a></li>
<a href="#2-update-segment-tree">2. Update segment tree</a></li>
<a href="#3-range-sum-query">3. Range Sum Query</a></li>
</ul>
</li>
</ul>
</li>
<a href="#further-thoughts">Further Thoughts</a></li>
</ul>
</div>
Summary</h2>
This article is for intermediate level readers. It introduces the following concepts:
Range sum query, Sqrt decomposition, Segment tree.</p>
Solution</h2>
<h4 id="approach-1-naive-time-limit-exceeded">Approach #1 (Naive) [Time Limit Exceeded]</h4>
Algorithm</strong></p>
A trivial solution for Range Sum Query - RSQ(i, j)</code> is to iterate the array from index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> and sum each element.</p>
Java</strong></p>
</span>private</span> int</span>[]</span> nums</span>;</span>
public</span> int</span> sumRange</span>(</span>int</span> i</span>,</span> int</span> j</span>)</span> {</span>
    int</span> sum</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> l</span> =</span> i</span>;</span> l</span> &lt;=</span> j</span>;</span> l</span>++)</span> {</span>
        sum</span> +=</span> data</span>[</span>l</span>];</span>
    }</span>
    return</span> sum</span>;</span>
}</span>

public</span> int</span> update</span>(</span>int</span> i</span>,</span> int</span> val</span>)</span> {</span>
    nums</span>[</span>i</span>]</span> =</span> val</span>;</span>
}</span>
// Time Limit Exceeded</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> - range sum query, <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> - update query</p>
For range sum query we access each element from the array for constant time and in the worst case we access <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements. Therefore time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Time complexity of update query is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>
<h4 id="approach-2-sqrt-decomposition-accepted">Approach #2 (Sqrt decomposition) [Accepted]</h4>
Intuition</strong></p>
The idea is to  split the array in blocks with length of <span class="maths katex-rendered">n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span></span></span></span></span>. Then we calculate the sum of each block and store it in auxiliary memory b</code>.
To query RSQ(i, j)</code>, we will add the sums of all the blocks lying inside and those that partially overlap with range <span class="maths katex-rendered">[</mo>i</mi>…</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">[i ldots j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>…</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>.</p>
Algorithm</strong></p>
<img alt="Range sum query using SQRT decomposition" src="https://leetcode.com/media/original_images/307_RSQ_Sqrt.png" width="539px"></p>
Figure 1. Range sum query using SQRT decomposition.</em></p>
In the example above, the array nums</code>'s length is 9</code>, which is split into blocks of size <span class="maths katex-rendered">9</mn></mrow></msqrt></mrow><annotation encoding="application/x-tex">sqrt{9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.90722em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.13278em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top: -0.06722em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathrm">9</span></span></span><span class="" style="top: -0.82722em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span></span></span></span></span>. To get RSQ(1, 7)</code> we add b[1]</code>.  It stores the sum of range [3, 5]</code> and partially sums from block 0</code>  and block 2</code>, which are overlapping boundary blocks.</p>
Java</strong></p>
</span>private</span> int</span>[]</span> b</span>;</span>
private</span> int</span> len</span>;</span>
private</span> int</span>[]</span> nums</span>;</span>

public</span> NumArray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
    this</span>.</span>nums</span> =</span> nums</span>;</span>
    double</span> l</span> =</span> Math</span>.</span>sqrt</span>(</span>nums</span>.</span>length</span>);</span>
    len</span> =</span> (</span>int</span>)</span> Math</span>.</span>ceil</span>(</span>nums</span>.</span>length</span>/</span>l</span>);</span>
    b</span> =</span> new</span> int</span> [</span>len</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span>
        b</span>[</span>i</span> /</span> len</span>]</span> +=</span> nums</span>[</span>i</span>];</span>
}</span>

public</span> int</span> sumRange</span>(</span>int</span> i</span>,</span> int</span> j</span>)</span> {</span>
    int</span> sum</span> =</span> 0</span>;</span>
    int</span> startBlock</span> =</span> i</span> /</span> len</span>;</span>
    int</span> endBlock</span> =</span> j</span> /</span> len</span>;</span>
    if</span> (</span>startBlock</span> ==</span> endBlock</span>)</span> {</span>
        for</span> (</span>int</span> k</span> =</span> i</span>;</span> k</span> &lt;=</span> j</span>;</span> k</span>++)</span>
            sum</span> +=</span> nums</span>[</span>k</span>];</span>
    }</span> else</span> {</span>
        for</span> (</span>int</span> k</span> =</span> i</span>;</span> k</span> &lt;=</span> (</span>startBlock</span> +</span> 1</span>)</span> *</span> len</span> -</span> 1</span>;</span> k</span>++)</span>
            sum</span> +=</span> nums</span>[</span>k</span>];</span>
        for</span> (</span>int</span> k</span> =</span> startBlock</span> +</span> 1</span>;</span> k</span> &lt;=</span> endBlock</span> -</span> 1</span>;</span> k</span>++)</span>
            sum</span> +=</span> b</span>[</span>k</span>];</span>
        for</span> (</span>int</span> k</span> =</span> endBlock</span> *</span> len</span>;</span> k</span> &lt;=</span> j</span>;</span> k</span>++)</span>
            sum</span> +=</span> nums</span>[</span>k</span>];</span>
    }</span>
    return</span> sum</span>;</span>
}</span>

public</span> void</span> update</span>(</span>int</span> i</span>,</span> int</span> val</span>)</span> {</span>
    int</span> b_l</span> =</span> i</span> /</span> len</span>;</span>
    b</span>[</span>b_l</span>]</span> =</span> b</span>[</span>b_l</span>]</span> -</span> nums</span>[</span>i</span>]</span> +</span> val</span>;</span>
    nums</span>[</span>i</span>]</span> =</span> val</span>;</span>
}</span>
// Accepted</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> - preprocessing, <span class="maths katex-rendered">O</mi>(</mo>n</mi></mrow></msqrt>)</mo></mrow><annotation encoding="application/x-tex">O(sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.05028em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span>)</span></span></span></span></span> - range sum query, <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> - update query</p>
For range sum query in the worst-case scenario we have to sum approximately <span class="maths katex-rendered">3</mn>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">3 sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span></span></span></span></span> elements. In this case the range includes <span class="maths katex-rendered">n</mi></mrow></msqrt>−</mo>2</mn></mrow><annotation encoding="application/x-tex">sqrt{n} - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span>−</span><span class="mord mathrm">2</span></span></span></span></span> blocks, which total sum costs <span class="maths katex-rendered">n</mi></mrow></msqrt>−</mo>2</mn></mrow><annotation encoding="application/x-tex">sqrt{n} - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span>−</span><span class="mord mathrm">2</span></span></span></span></span> operations. In addition to this we have to add the sum of the two boundary blocks. This takes another <span class="maths katex-rendered">2</mn>(</mo>n</mi></mrow></msqrt>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">2 (sqrt{n} - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.05028em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span>(</span><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> operations. The total amount of operations is around <span class="maths katex-rendered">3</mn>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">3 sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi></mrow></msqrt>)</mo></mrow><annotation encoding="application/x-tex">O(sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.05028em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span>)</span></span></span></span></span>.</p>
We need additional <span class="maths katex-rendered">n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.80028em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.23972em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top: 0.03972em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="" style="top: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span class="" style="top: -0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 1em;">​</span></span>​</span></span></span></span></span></span></span> memory to store all block sums.</p>
</li>
</ul>
<h4 id="approach-3-segment-tree-accepted">Approach #3 (Segment tree) [Accepted]</h4>
Algorithm</strong></p>
Segment tree is a very flexible data structure, because it is used to solve numerous range query problems like finding minimum, maximum, sum, greatest common divisor, least common denominator in array in logarithmic time.</p>
<img alt="Illustration of Segment tree" src="https://leetcode.com/media/original_images/307_RSQ_SegmentTree.png" width="539px"></p>
Figure 2. Illustration of Segment tree.</em></p>
The segment tree for array <span class="maths katex-rendered">a</mi>[</mo>0</mn>,</mo>1</mn>,</mo>…</mo>,</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">a[0, 1, ldots ,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span>[</span><span class="mord mathrm">0</span>,</span><span class="mord mathrm">1</span>,</span>…</span>,</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> is a binary tree in which each node contains aggregate</strong> information (min, max, sum, etc.) for a subrange <span class="maths katex-rendered">[</mo>i</mi>…</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">[i ldots j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>…</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> of the array, as its left and right child hold information for range <span class="maths katex-rendered">[</mo>i</mi>…</mo>i</mi>+</mo>j</mi></mrow>2</mn></mrow></mfrac>]</mo></mrow><annotation encoding="application/x-tex">[i ldots frac{i+j}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.907772em;"></span><span class="strut bottom" style="height: 1.25277em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>…</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>]</span></span></span></span></span> and <span class="maths katex-rendered">[</mo>i</mi>+</mo>j</mi></mrow>2</mn></mrow></mfrac>+</mo>1</mn>,</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">[frac{i + j}{2} + 1, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.907772em;"></span><span class="strut bottom" style="height: 1.25277em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped">[</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>.</p>
Segment tree could be implemented using either an array or a tree. For an array implementation, if the element at index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> is not a leaf, its left and right child are stored at index <span class="maths katex-rendered">2</mn>i</mi></mrow><annotation encoding="application/x-tex">2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">2</mn>i</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">2i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span></span></span></span></span> respectively.</p>
In the example above (Figure 2), every leaf node contains the initial array elements {2,4,5,7,8,9}</code>. The internal nodes contain the sum of the corresponding elements in range - (11)</code> for the elements from index 0 to index 2. The root (35)</code> being the sum  of its children (6)</code>;(29)</code>, holds the total sum of the entire array.</p>
Segment Tree can be broken down to the three following steps:</p>

Pre-processing step which builds the segment tree from a given array.</li>
Update the segment tree when an element is modified.</li>
Calculate the Range Sum Query using the segment tree.</li>
</ol>
<h5 id="1-build-segment-tree">1. Build segment tree</h5>
We will use a very effective bottom-up approach to build segment tree. We already know from the above that if some node <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span> holds the sum of <span class="maths katex-rendered">[</mo>i</mi>…</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">[i ldots j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>…</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> range, its left and right children hold the sum for range <span class="maths katex-rendered">[</mo>i</mi>…</mo>i</mi>+</mo>j</mi></mrow>2</mn></mrow></mfrac>]</mo></mrow><annotation encoding="application/x-tex">[i ldots frac{i + j}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.907772em;"></span><span class="strut bottom" style="height: 1.25277em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">i</span>…</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>]</span></span></span></span></span> and <span class="maths katex-rendered">[</mo>i</mi>+</mo>j</mi></mrow>2</mn></mrow></mfrac>+</mo>1</mn>,</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">[frac{i + j}{2} + 1, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.907772em;"></span><span class="strut bottom" style="height: 1.25277em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped">[</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> respectively.</p>
Therefore to find the sum of node <span class="maths katex-rendered">p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span></span>, we need to calculate the sum of its right and left child in advance.</p>
We begin from the leaves, initialize them with input array elements <span class="maths katex-rendered">a</mi>[</mo>0</mn>,</mo>1</mn>,</mo>…</mo>,</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">a[0, 1, ldots, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span>[</span><span class="mord mathrm">0</span>,</span><span class="mord mathrm">1</span>,</span>…</span>,</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. Then we move upward to the higher level to calculate the parents' sum till we get to the root of the segment tree.</p>
Java</strong></p>
</span>int</span>[]</span> tree</span>;</span>
int</span> n</span>;</span>
public</span> NumArray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
    if</span> (</span>nums</span>.</span>length</span> &gt;</span> 0</span>)</span> {</span>
        n</span> =</span> nums</span>.</span>length</span>;</span>
        tree</span> =</span> new</span> int</span>[</span>n</span> *</span> 2</span>];</span>
        buildTree</span>(</span>nums</span>);</span>
    }</span>
}</span>
private</span> void</span> buildTree</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
    for</span> (</span>int</span> i</span> =</span> n</span>,</span> j</span> =</span> 0</span>;</span>  i</span> &lt;</span> 2</span> *</span> n</span>;</span> i</span>++,</span>  j</span>++)</span>
        tree</span>[</span>i</span>]</span> =</span> nums</span>[</span>j</span>];</span>
    for</span> (</span>int</span> i</span> =</span> n</span> -</span> 1</span>;</span> i</span> &gt;</span> 0</span>;</span> --</span>i</span>)</span>
        tree</span>[</span>i</span>]</span> =</span> tree</span>[</span>i</span> *</span> 2</span>]</span> +</span> tree</span>[</span>i</span> *</span> 2</span> +</span> 1</span>];</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>
</p>
Time complexity is  <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>, because we calculate the sum of one node during each iteration of the for loop. There are approximately <span class="maths katex-rendered">2</mn>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span></span> nodes in a segment tree.</p>
This could be proved in the following way: Segmented tree for array with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements has <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> leaves (the array elements itself). The number of nodes in each level is half the number in the level below.</p>
So if we sum the number by level we will get:</p>

<p class="maths katex-rendered">n</mi>+</mo>n</mi>/</mi>2</mn>+</mo>n</mi>/</mi>4</mn>+</mo>n</mi>/</mi>8</mn>+</mo>…</mo>+</mo>1</mn>≈</mo>2</mn>n</mi></mrow><annotation encoding="application/x-tex">
n + n/2  + n/4 + n/8 + ldots + 1 approx 2n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span>+</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">4</span>+</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">8</span>+</span>…</span>+</span><span class="mord mathrm">1</span>≈</span><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span></span></p>
</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>
We used <span class="maths katex-rendered">2</mn>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span></span> extra space to store the segment tree.</p>
</li>
</ul>
<h5 id="2-update-segment-tree">2. Update segment tree</h5>
When we update the array at some index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> we need to rebuild the segment tree, because there are tree nodes which contain the sum of the modified element. Again we will use a bottom-up approach. We update the leaf node that stores <span class="maths katex-rendered">a</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>. From there we will follow the path up to the root updating the value of each parent as a sum of its children values.</p>
Java</strong></p>
</span>void</span> update</span>(</span>int</span> pos</span>,</span> int</span> val</span>)</span> {</span>
    pos</span> +=</span> n</span>;</span>
    tree</span>[</span>pos</span>]</span> =</span> val</span>;</span>
    while</span> (</span>pos</span> &gt;</span> 0</span>)</span> {</span>
        int</span> left</span> =</span> pos</span>;</span>
        int</span> right</span> =</span> pos</span>;</span>
        if</span> (</span>pos</span> %</span> 2</span> ==</span> 0</span>)</span> {</span>
            right</span> =</span> pos</span> +</span> 1</span>;</span>
        }</span> else</span> {</span>
            left</span> =</span> pos</span> -</span> 1</span>;</span>
        }</span>
        // parent is updated after child is updated</span>
        tree</span>[</span>pos</span> /</span> 2</span>]</span> =</span> tree</span>[</span>left</span>]</span> +</span> tree</span>[</span>right</span>];</span>
        pos</span> /=</span> 2</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>
Algorithm  has <span class="maths katex-rendered">O</mi>(</mo>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span> time complexity, because there are a few tree nodes with range that include  <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>th array element, one on each level. There are <span class="maths katex-rendered">log</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>  levels.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>
<h5 id="3-range-sum-query">3. Range Sum Query</h5>
We can find range sum query  <span class="maths katex-rendered">[</mo>L</mi>,</mo>R</mi>]</mo></mrow><annotation encoding="application/x-tex">[L, R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">L</span>,</span><span class="mord mathit" style="margin-right: 0.00773em;">R</span>]</span></span></span></span></span> using segment tree in the following way:</p>
Algorithm hold loop invariant:</p>

<span class="maths katex-rendered">l</mi>≤</mo>r</mi></mrow><annotation encoding="application/x-tex">l le r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.83041em; vertical-align: -0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span>≤</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> and sum of <span class="maths katex-rendered">[</mo>L</mi>…</mo>l</mi>]</mo></mrow><annotation encoding="application/x-tex">[L ldots l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">L</span>…</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>]</span></span></span></span></span> and <span class="maths katex-rendered">[</mo>r</mi>…</mo>R</mi>]</mo></mrow><annotation encoding="application/x-tex">[r ldots R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span>…</span><span class="mord mathit" style="margin-right: 0.00773em;">R</span>]</span></span></span></span></span> has been calculated, where <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> and <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> are the left and right boundary of calculated sum.
Initially we set <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> with left leaf <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> and <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> with right leaf <span class="maths katex-rendered">R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.00773em;">R</span></span></span></span></span>.
Range <span class="maths katex-rendered">[</mo>l</mi>,</mo>r</mi>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span>]</span></span></span></span></span> shrinks on each iteration till range borders meets after approximately <span class="maths katex-rendered">log</mi>n</mi></mrow><annotation encoding="application/x-tex">log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span></span></span></span></span> iterations of the algorithm</p>

Loop till <span class="maths katex-rendered">l</mi>≤</mo>r</mi></mrow><annotation encoding="application/x-tex">l le r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.83041em; vertical-align: -0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span>≤</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span>

Check if <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> is right child of its parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>


<span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> is right child of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>. Then <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> contains sum of range of <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> and another  child which is outside the range <span class="maths katex-rendered">[</mo>l</mi>,</mo>r</mi>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span>]</span></span></span></span></span> and we don't need parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> sum. Add <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> without its parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> and set <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> to point to the right of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> on the upper level.</li>

<span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> is not right child of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>. Then parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> contains sum of range which lies in <span class="maths katex-rendered">[</mo>l</mi>,</mo>r</mi>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span>]</span></span></span></span></span>. Add <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> and set <span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> to point to the parent of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>
</li>
</ul>
</li>
Check if <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> is left child of its parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>


<span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> is left child of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>. Then <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> contains sum of range of <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> and another  child which is outside the range <span class="maths katex-rendered">[</mo>l</mi>,</mo>r</mi>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span>]</span></span></span></span></span> and we don't need parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> sum. Add <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span>  to <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> without its parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> and set <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> to point to the left of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> on the upper level.</li>

<span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> is not left child of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>. Then parent <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> contains sum of range which lies in <span class="maths katex-rendered">[</mo>l</mi>,</mo>r</mi>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span>]</span></span></span></span></span>. Add <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> and set <span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> to point to the parent of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span>
</li>
</ul>
</li>
</ul>
</li>
</ul>
Java</strong></p>
</span>public</span> int</span> sumRange</span>(</span>int</span> l</span>,</span> int</span> r</span>)</span> {</span>
    // get leaf with value 'l'</span>
    l</span> +=</span> n</span>;</span>
    // get leaf with value 'r'</span>
    r</span> +=</span> n</span>;</span>
    int</span> sum</span> =</span> 0</span>;</span>
    while</span> (</span>l</span> &lt;=</span> r</span>)</span> {</span>
        if</span> ((</span>l</span> %</span> 2</span>)</span> ==</span> 1</span>)</span> {</span>
           sum</span> +=</span> tree</span>[</span>l</span>];</span>
           l</span>++;</span>
        }</span>
        if</span> ((</span>r</span> %</span> 2</span>)</span> ==</span> 0</span>)</span> {</span>
           sum</span> +=</span> tree</span>[</span>r</span>];</span>
           r</span>--;</span>
        }</span>
        l</span> /=</span> 2</span>;</span>
        r</span> /=</span> 2</span>;</span>
    }</span>
    return</span> sum</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span>
</p>
Time complexity is <span class="maths katex-rendered">O</mi>(</mo>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span> because on each iteration of the algorithm we move one level up, either to the parent of the  current node or to the next sibling of parent to the left or right direction till the two boundaries meet. In the worst-case scenario this happens at the root after <span class="maths katex-rendered">log</mi>n</mi></mrow><annotation encoding="application/x-tex">log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span></span></span></span></span> iterations of the algorithm.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>
Further Thoughts</h2>
The iterative version of Segment Trees was introduced in this article. A more intuitive, recursive version of Segment Trees to solve this problem is discussed <a href="https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/">here</a>. The concept of Lazy Propagation is also introduced there.</p>
There is an alternative solution of the problem using Binary Indexed Tree. It is faster and simpler to code.
You can find it <a href="https://leetcode.com/discuss/74222/java-using-binary-indexed-tree-with-clear-explanation">here</a>.</p>
Analysis written by: @elmirap.</p>