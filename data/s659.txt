<div class="toc hide">

<a href="#approach-1-dfs-accepted">Approach #1: DFS [Accepted]</a></li>
<a href="#approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</a></li>
</ul>
</div>
<h4 id="approach-1-dfs-accepted">Approach #1: DFS [Accepted]</h4>
Intuition and Algorithm</strong></p>
For each edge (u, v)</code>, traverse the graph with a depth-first search to see if we can connect u</code> to v</code>.  If we can, then it must be the duplicate edge.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> findRedundantConnection</span>(</span>self</span>,</span> edges</span>):</span>
        graph</span> =</span> collections</span>.</span>defaultdict</span>(</span>set</span>)</span>

        def</span> dfs</span>(</span>source</span>,</span> target</span>):</span>
            if</span> source</span> not</span> in</span> seen</span>:</span>
                seen</span>.</span>add</span>(</span>source</span>)</span>
                if</span> source</span> ==</span> target</span>:</span> return</span> True</span>
                return</span> any</span>(</span>dfs</span>(</span>nei</span>,</span> target</span>)</span> for</span> nei</span> in</span> graph</span>[</span>source</span>])</span>

        for</span> u</span>,</span> v</span> in</span> edges</span>:</span>
            seen</span> =</span> set</span>()</span>
            if</span> u</span> in</span> graph</span> and</span> v</span> in</span> graph</span> and</span> dfs</span>(</span>u</span>,</span> v</span>):</span>
                return</span> u</span>,</span> v</span>
            graph</span>[</span>u</span>]</span>.</span>add</span>(</span>v</span>)</span>
            graph</span>[</span>v</span>]</span>.</span>add</span>(</span>u</span>)</span>
</pre></div>


Java</strong></p>
</span>class</span> Solution</span> {</span>
    Set</span>&lt;</span>Integer</span>&gt;</span> seen</span> =</span> new</span> HashSet</span>();</span>
    int</span> MAX_EDGE_VAL</span> =</span> 2000</span>;</span>

    public</span> int</span>[]</span> findRedundantConnection</span>(</span>int</span>[][]</span> edges</span>)</span> {</span>
        ArrayList</span>&lt;</span>Integer</span>&gt;[]</span> graph</span> =</span> new</span> ArrayList</span>[</span>MAX_EDGE_VAL</span> +</span> 1</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;=</span> MAX_EDGE_VAL</span>;</span> i</span>++)</span> {</span>
            graph</span>[</span>i</span>]</span> =</span> new</span> ArrayList</span>();</span>
        }</span>

        for</span> (</span>int</span>[]</span> edge</span>:</span> edges</span>)</span> {</span>
            seen</span>.</span>clear</span>();</span>
            if</span> (!</span>graph</span>[</span>edge</span>[</span>0</span>]].</span>isEmpty</span>()</span> &amp;&amp;</span> !</span>graph</span>[</span>edge</span>[</span>1</span>]].</span>isEmpty</span>()</span> &amp;&amp;</span>
                    dfs</span>(</span>graph</span>,</span> edge</span>[</span>0</span>],</span> edge</span>[</span>1</span>]))</span> {</span>
                return</span> edge</span>;</span>
            }</span>
            graph</span>[</span>edge</span>[</span>0</span>]].</span>add</span>(</span>edge</span>[</span>1</span>]);</span>
            graph</span>[</span>edge</span>[</span>1</span>]].</span>add</span>(</span>edge</span>[</span>0</span>]);</span>
        }</span>
        throw</span> new</span> AssertionError</span>();</span>
    }</span>
    public</span> boolean</span> dfs</span>(</span>ArrayList</span>&lt;</span>Integer</span>&gt;[]</span> graph</span>,</span> int</span> source</span>,</span> int</span> target</span>)</span> {</span>
        if</span> (!</span>seen</span>.</span>contains</span>(</span>source</span>))</span> {</span>
            seen</span>.</span>add</span>(</span>source</span>);</span>
            if</span> (</span>source</span> ==</span> target</span>)</span> return</span> true</span>;</span>
            for</span> (</span>int</span> nei</span>:</span> graph</span>[</span>source</span>])</span> {</span>
                if</span> (</span>dfs</span>(</span>graph</span>,</span> nei</span>,</span> target</span>))</span> return</span> true</span>;</span>
            }</span>
        }</span>
        return</span> false</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the number of vertices (and also the number of edges) in the graph.  In the worst case, for every edge we include, we have to search every previously-occurring edge of the graph.</p>
</li>

Space Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.  The current construction of the graph has at most <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> nodes.</p>
</li>
</ul>

<h4 id="approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</h4>
Intuition and Algorithm</strong></p>
If we are familiar with a Disjoint Set Union (DSU) data structure, we can use this in a straightforward manner to solve the problem: we simply find the first edge occurring in the graph that is already connected.  The rest of this explanation will focus on the details of implementing DSU.</p>
A DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly.  In particular, we would like to support two operations:</p>


dsu.find(node x)</code>, which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and:</p>
</li>

dsu.union(node x, node y)</code>, which draws an edge (x, y)</code> in the graph, connecting the components with id find(x)</code> and find(y)</code> together.</p>
</li>
</ul>
To achieve this, we keep track of parent</code>, which remembers the id</code> of a smaller node in the same connected component.  If the node is it's own parent, we call this the leader</em> of that connected component.</p>
A naive implementation of a DSU structure would look something like this:</p>
Psuedocode</em></p>
</span># parent initialized as (x -&gt; x)</span>
function</span> find</span>(</span>x</span>):</span>
    while</span> parent</span>[</span>x</span>]</span> !=</span> x</span>:</span> #While x isn't the leader</span>
        x</span> =</span> parent</span>[</span>x</span>]</span>
    return</span> x</span>

function</span> union</span>(</span>x</span>,</span> y</span>):</span>
    parent</span>[</span>find</span>(</span>x</span>)]</span> =</span> find</span>(</span>y</span>)</span>
</pre></div>


We use two techniques to improve the run-time complexity: path compression</em>, and union-by-rank</em>.</p>


Path compression involves changing the x = parent[x]</code> in the find</code> function to parent[x] = find(parent[x])</code>.  Basically, as we compute the correct leader for x, we should remember our calculation.</p>
</li>

Union-by-rank involves distributing the workload of find</code> across leaders evenly.  Whenever we dsu.union(x, y)</code>, we have two leaders xr, yr</code> and we have to choose whether we want parent[x] = yr</code> or parent[y] = xr</code>.  We choose the leader that has a lower following to pick up a new follower.
Specifically, the meaning of rank</code> is that there are less than 2 ^ rank[x]</code> followers of x</code>.  This strategy can be shown to give us better bounds for how long the recursive loop in dsu.find</code> could run for.</p>
</li>
</ul>
</span>class</span> DSU</span>(</span>object</span>):</span>
    def</span> __init__</span>(</span>self</span>):</span>
        self</span>.</span>par</span> =</span> range</span>(</span>2001</span>)</span>
        self</span>.</span>rnk</span> =</span> [</span>0</span>]</span> *</span> 2001</span>

    def</span> find</span>(</span>self</span>,</span> x</span>):</span>
        if</span> self</span>.</span>par</span>[</span>x</span>]</span> !=</span> x</span>:</span>
            self</span>.</span>par</span>[</span>x</span>]</span> =</span> self</span>.</span>find</span>(</span>self</span>.</span>par</span>[</span>x</span>])</span>
        return</span> self</span>.</span>par</span>[</span>x</span>]</span>

    def</span> union</span>(</span>self</span>,</span> x</span>,</span> y</span>):</span>
        xr</span>,</span> yr</span> =</span> self</span>.</span>find</span>(</span>x</span>),</span> self</span>.</span>find</span>(</span>y</span>)</span>
        if</span> xr</span> ==</span> yr</span>:</span>
            return</span> False</span>
        elif</span> self</span>.</span>rnk</span>[</span>xr</span>]</span> &lt;</span> self</span>.</span>rnk</span>[</span>yr</span>]:</span>
            self</span>.</span>par</span>[</span>xr</span>]</span> =</span> yr</span>
        elif</span> self</span>.</span>rnk</span>[</span>xr</span>]</span> &gt;</span> self</span>.</span>rnk</span>[</span>yr</span>]:</span>
            self</span>.</span>par</span>[</span>yr</span>]</span> =</span> xr</span>
        else</span>:</span>
            self</span>.</span>par</span>[</span>yr</span>]</span> =</span> xr</span>
            self</span>.</span>rnk</span>[</span>xr</span>]</span> +=</span> 1</span>
        return</span> True</span>

class</span> Solution</span>(</span>object</span>):</span>
    def</span> findRedundantConnection</span>(</span>self</span>,</span> edges</span>):</span>
        dsu</span> =</span> DSU</span>()</span>
        for</span> edge</span> in</span> edges</span>:</span>
            if</span> not</span> dsu</span>.</span>union</span>(</span>*</span>edge</span>):</span>
                return</span> edge</span>
</pre></div>


Alternate Implementation of DSU without Union-By-Rank</em></p>
</span>class</span> DSU</span>:</span>
    def</span> __init__</span>(</span>self</span>):</span>
        self</span>.</span>par</span> =</span> range</span>(</span>2001</span>)</span>
    def</span> find</span>(</span>self</span>,</span> x</span>):</span>
        if</span> self</span>.</span>par</span>[</span>x</span>]</span> !=</span> x</span>:</span>
            self</span>.</span>par</span>[</span>x</span>]</span> =</span> self</span>.</span>find</span>(</span>self</span>.</span>par</span>[</span>x</span>])</span>
        return</span> self</span>.</span>par</span>[</span>x</span>]</span>
    def</span> union</span>(</span>self</span>,</span> x</span>,</span> y</span>):</span>
        self</span>.</span>par</span>[</span>self</span>.</span>find</span>(</span>x</span>)]</span> =</span> self</span>.</span>find</span>(</span>y</span>)</span>
</pre></div>


Java</strong></p>
</span>class</span> Solution</span> {</span>
    int</span> MAX_EDGE_VAL</span> =</span> 2000</span>;</span>

    public</span> int</span>[]</span> findRedundantConnection</span>(</span>int</span>[][]</span> edges</span>)</span> {</span>
        DSU</span> dsu</span> =</span> new</span> DSU</span>(</span>MAX_EDGE_VAL</span> +</span> 1</span>);</span>
        for</span> (</span>int</span>[]</span> edge</span>:</span> edges</span>)</span> {</span>
            if</span> (!</span>dsu</span>.</span>union</span>(</span>edge</span>[</span>0</span>],</span> edge</span>[</span>1</span>]))</span> return</span> edge</span>;</span>
        }</span>
        throw</span> new</span> AssertionError</span>();</span>
    }</span>
}</span>

class</span> DSU</span> {</span>
    int</span>[]</span> parent</span>;</span>
    int</span>[]</span> rank</span>;</span>

    public</span> DSU</span>(</span>int</span> size</span>)</span> {</span>
        parent</span> =</span> new</span> int</span>[</span>size</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> size</span>;</span> i</span>++)</span> parent</span>[</span>i</span>]</span> =</span> i</span>;</span>
        rank</span> =</span> new</span> int</span>[</span>size</span>];</span>
    }</span>

    public</span> int</span> find</span>(</span>int</span> x</span>)</span> {</span>
        if</span> (</span>parent</span>[</span>x</span>]</span> !=</span> x</span>)</span> parent</span>[</span>x</span>]</span> =</span> find</span>(</span>parent</span>[</span>x</span>]);</span>
        return</span> parent</span>[</span>x</span>];</span>
    }</span>

    public</span> boolean</span> union</span>(</span>int</span> x</span>,</span> int</span> y</span>)</span> {</span>
        int</span> xr</span> =</span> find</span>(</span>x</span>),</span> yr</span> =</span> find</span>(</span>y</span>);</span>
        if</span> (</span>xr</span> ==</span> yr</span>)</span> {</span>
            return</span> false</span>;</span>
        }</span> else</span> if</span> (</span>rank</span>[</span>xr</span>]</span> &lt;</span> rank</span>[</span>yr</span>])</span> {</span>
            parent</span>[</span>xr</span>]</span> =</span> yr</span>;</span>
        }</span> else</span> if</span> (</span>rank</span>[</span>xr</span>]</span> &gt;</span> rank</span>[</span>yr</span>])</span> {</span>
            parent</span>[</span>yr</span>]</span> =</span> xr</span>;</span>
        }</span> else</span> {</span>
            parent</span>[</span>yr</span>]</span> =</span> xr</span>;</span>
            rank</span>[</span>xr</span>]++;</span>
        }</span>
        return</span> true</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>α</mi>(</mo>N</mi>)</mo>)</mo>≈</mo>O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(Nalpha(N)) approx O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit" style="margin-right: 0.0037em;">α</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span>)</span>≈</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the number of vertices (and also the number of edges) in the graph, and <span class="maths katex-rendered">α</mi></mrow><annotation encoding="application/x-tex">alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.0037em;">α</span></span></span></span></span> is the Inverse-Ackermann</em> function.  We make up to <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> queries of dsu.union</code>, which takes (amortized) <span class="maths katex-rendered">O</mi>(</mo>α</mi>(</mo>N</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(alpha(N))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.0037em;">α</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span>)</span></span></span></span></span> time.  Outside the scope of this article, it can be shown why dsu.union</code> has <span class="maths katex-rendered">O</mi>(</mo>α</mi>(</mo>N</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(alpha(N))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.0037em;">α</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span>)</span></span></span></span></span> complexity, what the Inverse-Ackermann function is, and why <span class="maths katex-rendered">O</mi>(</mo>α</mi>(</mo>N</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(alpha(N))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.0037em;">α</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span>)</span></span></span></span></span> is approximately <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>

Space Complexity:  <span class="maths katex-rendered">O</mi>(</mo>N</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>)</span></span></span></span></span>.  The current construction of the graph (embedded in our dsu</code> structure) has at most <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> nodes.</p>
</li>
</ul>