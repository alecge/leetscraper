<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-3-using-bit-manipulation-accepted">Approach #3 Using Bit Manipulation [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
The brute force approach is simple. We can traverse through all the numbers from <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>. For every current number chosen, we can check all the consecutive positions in this number to check if the number contains two consecutive ones or not. If not, we increment the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> of the resultant numbers with no consecutive ones. </p>
To check if a <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> exists at the position <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>(counting from the LSB side), in the current number <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, we can proceed as follows. We can shift a binary <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span>
<span class="maths katex-rendered">x</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>−</span><span class="mord mathrm">1</span></span></span></span></span> times towards the left to get a number <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> which has a <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> only at the <span class="maths katex-rendered">x</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position. Now, logical ANDing of <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> and <span class="maths katex-rendered">y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span> will result in a logical <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> output only if <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> contains <span class="maths katex-rendered">1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span> at the <span class="maths katex-rendered">x</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findIntegers</span>(</span>int</span> num</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;=</span> num</span>;</span> i</span>++)</span>
            if</span> (</span>check</span>(</span>i</span>))</span>
                count</span>++;</span>
        return</span> count</span>;</span>
    }</span>
    public</span> boolean</span> check</span>(</span>int</span> n</span>)</span> {</span>
        int</span> i</span> =</span> 31</span>;</span>
        while</span> (</span>i</span> &gt;</span> 0</span>)</span> {</span>
            if</span> ((</span>n</span> &amp;</span> (</span>1</span> &lt;&lt;</span> i</span>))</span> !=</span> 0</span> &amp;&amp;</span> (</span>n</span> &amp;</span> (</span>1</span> &lt;&lt;</span> (</span>i</span> -</span> 1</span>)))</span> !=</span> 0</span>)</span>
                return</span> false</span>;</span>
            i</span>--;</span>
        }</span>
        return</span> true</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>3</mn>2</mn>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(32*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">3</span><span class="mord mathrm">2</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We test  the 32 consecutive positions of every number from <span class="maths katex-rendered">0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span> to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to given number. </p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
In the last approach, we generated every number and then checked if it contains consecutive ones at any position or not. Instead of this, we can generate only the required kind of numbers. e.g. If we genearte numbers in the order of the number of bits in the current number, if we get a binary number 110</code> on the way at the step of 3-bit number generation. Now, since this number already contains two consecutive ones, it is useless to generate number with more number of bits with the current bitstream as the suffix(e.g. numbers of the form 1110</code> and 0110</code>).</p>
The current approach is based on the above idea. We can start with the LSB position, by placing a 0</code> and a 1</code> at the LSB. These two initial numbers correspond to the 1-bit numbers which don't contain any consecutive ones. Now, taking 0</code> as the initial suffix, if we want to generate two bit numbers with no two consecutive 1's, we can append a 1</code> and a 0</code> both in front of the initial 0</code> generating the numbers 10</code> and 00</code> as the two bit numbers ending with a 0</code> with no two consecutive 1's.</p>
But, when we take 1</code> as the initial suffix, we can append a 0</code> to it to generate 01</code> which doesn't contain any consecutive ones. But, adding a 1</code> won't satisfy this criteria(11</code> will be generated). Thus, while generating the current number, we need to keep a track of the point that whether a 1</code> was added as the last prefix or not. If yes, we can't append a new 1</code> and only 0</code> can be appended. If a 0</code> was appended as the last prefix, both 0</code> and 1</code> can be appended in the new bit-pattern without creating a violating number.
Thus, we can continue forward with the 3-bit number generation only with 00</code>, 01</code> and 10</code> as the new suffixes  in the same manner. </p>
To get a count of numbers lesser than <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>, with no two consecutive 1's, based on the above discussion, we make use of a recursive function find(i, sum, num, prev)</code>. This function returns the count of binary numbers with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> bits with no two consecutive 1's. Here, <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> refers to the binary number generated till now(the prefix obtained as the input). <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> refers to the given number. <span class="maths katex-rendered">p</mi>r</mi>e</mi>v</mi></mrow><annotation encoding="application/x-tex">prev</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span></span></span></span></span> is a boolean variable that indicates whether the last prefix added was a 1</code> or a 0</code>.</p>
If the last prefix was a 0</code>, we can add both 1</code> and 0</code> as the new prefix. Thus, we need to make a function call find(i + 1, sum, num, false) + find(i + 1, sum + (1 &lt;&lt; i), num, true)</code>. Here, the first sub-part refers to a 0</code> being added at the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position. Thus, we pass a false</code> as the prefix in this case. The second sub-part refers to a 1</code> being added at the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position. Thus, we pass true</code> as the prefix in this case. </p>
If the last prefix was a 1</code>, we can add only a 0</code> as the new prefix. Thus, only one function call find(i + 1, sum, num, false)</code> is made in this case. </p>
Further, we need to stop the number generation whenver the current input number(<span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>) exceeds the given number <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>. </p>
<img alt="Tree" src="../Figures/600_Non_Negative_2.PNG"></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findIntegers</span>(</span>int</span> num</span>)</span> {</span>
        return</span> find</span>(</span>0</span>,</span> 0</span>,</span> num</span>,</span> false</span>);</span>
    }</span>
    public</span> int</span> find</span>(</span>int</span> i</span>,</span> int</span> sum</span>,</span> int</span> num</span>,</span> boolean</span> prev</span>)</span> {</span>
        if</span> (</span>sum</span> &gt;</span> num</span>)</span>
            return</span> 0</span>;</span>
        if</span> (</span>1</span>&lt;&lt;</span>i</span> &gt;</span> num</span>)</span>
            return</span> 1</span>;</span>
        if</span> (</span>prev</span>)</span>
            return</span> find</span>(</span>i</span> +</span> 1</span>,</span> sum</span>,</span> num</span>,</span> false</span>);</span>
        return</span> find</span>(</span>i</span> +</span> 1</span>,</span> sum</span>,</span> num</span>,</span> false</span>)</span> +</span> find</span>(</span>i</span> +</span> 1</span>,</span> sum</span> +</span> (</span>1</span> &lt;&lt;</span> i</span>),</span> num</span>,</span> true</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>x</mi>)</mo></mrow><annotation encoding="application/x-tex">O(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">x</span>)</span></span></span></span></span>. Only <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> numbers are generated. Here, <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> refers to the resultant count to be returned.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>m</mi>a</mi>x</mi>_</mi>i</mi>n</mi>t</mi>)</mo>=</mo>3</mn>2</mn>)</mo></mrow><annotation encoding="application/x-tex">O(log(max_int)=32)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.06em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span>)</span>=</span><span class="mord mathrm">3</span><span class="mord mathrm">2</span>)</span></span></span></span></span>. The depth of recursion tree can go upto <span class="maths katex-rendered">3</mn>2</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-3-using-bit-manipulation-accepted">Approach #3 Using Bit Manipulation [Accepted]</h4>
Algorithm</strong></p>
Before we discuss the idea behind this approach, we consider another simple idea that will be used in the current approach. </p>
Suppose, we need to find the count of binary numbers with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> bits such that these numbers don't contain consecutive 1's. In order to do so, we can look at the problem in a recursive fashion. Suppose <span class="maths katex-rendered">f</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> gives the count of such binary numbers with <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> bits. In order to determine the value of <span class="maths katex-rendered">f</mi>[</mo>n</mi>]</mo></mrow><annotation encoding="application/x-tex">f[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>]</span></span></span></span></span>, which is the requirement, we can consider the cases shown below:</p>
<img alt="Recursive_Function" src="../Figures/600_Non_Negative_1.png"></p>
From the above figure, we can see that if we know the value of <span class="maths katex-rendered">f</mi>[</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">f</mi>[</mo>n</mi>−</mo>2</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span>]</span></span></span></span></span>, in order to generate the required binary numbers with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> bits, we can append a 0</code> to all the binary numbers contained in <span class="maths katex-rendered">f</mi>[</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> without creating an invalid number. These numbers give a factor of <span class="maths katex-rendered">f</mi>[</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to be included in <span class="maths katex-rendered">f</mi>[</mo>n</mi>]</mo></mrow><annotation encoding="application/x-tex">f[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>]</span></span></span></span></span>. But, we can't append a 1</code> to all these numbers, since it could lead to the presence of two consecutive ones in the newly generated numbers. Thus, for the currently generated numbers to end with a 1</code>, we need to ensure that the second last position is always 0</code>. Thus, we need to fix a 01</code> at the end of all the numbers contained in <span class="maths katex-rendered">f</mi>[</mo>n</mi>−</mo>2</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span>]</span></span></span></span></span>. This gives a factor of <span class="maths katex-rendered">f</mi>[</mo>n</mi>−</mo>2</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span>]</span></span></span></span></span> to be included in <span class="maths katex-rendered">f</mi>[</mo>n</mi>]</mo></mrow><annotation encoding="application/x-tex">f[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>]</span></span></span></span></span>. Thus, in total, we get <span class="maths katex-rendered">f</mi>[</mo>n</mi>]</mo>=</mo>f</mi>[</mo>n</mi>−</mo>1</mn>]</mo>+</mo>f</mi>[</mo>n</mi>−</mo>2</mn>]</mo></mrow><annotation encoding="application/x-tex">f[n] = f[n-1] + f[n-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>]</span>=</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span>]</span></span></span></span></span>.</p>
Now, let's look into the current approach. We'll try to understand the idea behind the approach by taking two simple examples. Firstly, we look at the case where the given number doesn't contain any consecutive 1's.Say, <span class="maths katex-rendered">n</mi>u</mi>m</mi>=</mo>1</mn>0</mn>1</mn>0</mn>1</mn>0</mn>0</mn></mtext></mrow><annotation encoding="application/x-tex">num = text{1010100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">1010100</span></span></span></span></span></span>(7 bit number). Now, we'll see how we can find the numbers lesser than <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> with no two consecutive 1's. We start off with the MSB of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>. If we fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the MSB position, and find out the count of 6 bit numbers(corresponding to the 6 LSBs) with no two consecutive 1's, these 6-bit numbers will lie in the range <span class="maths katex-rendered">0</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>0</mn></mtext>1</mn>1</mn>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{0}text{000000} -&gt; textbf{0}text{111111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">0</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">0</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111111</span></span></span></span></span></span>. For finding this count we can make use of <span class="maths katex-rendered">f</mi>[</mo>6</mn>]</mo></mrow><annotation encoding="application/x-tex">f[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">6</span>]</span></span></span></span></span> which we'll have already calculated based on the discussion above. </p>
But, even after doing this, all the numbers in the required range haven't been covered yet. Now, if we try to fix <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the MSB, the numbers considered will lie in the range <span class="maths katex-rendered">1</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn></mtext>1</mn>1</mn>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{1}text{000000} -&gt; textbf{1}text{111111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">1</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">1</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111111</span></span></span></span></span></span>. As we can see, this covers the numbers in the range <span class="maths katex-rendered">1</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn></mtext>0</mn>1</mn>0</mn>1</mn>0</mn>0</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{1}text{000000} -&gt; textbf{1}text{010100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">1</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">1</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">010100</span></span></span></span></span></span>, but it covers the numbers in the range beyond limit as well. Thus, we can't fix <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the MSB and consider all the 6-bit numbers at the LSBs. </p>
For covering the pending range, we fix <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the MSB, and move forward to proceed with the second digit(counting from MSB). Now, since we've already got a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at this position, we can't substitute a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> here, since doing so will lead to generation of numbers exceeding <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>. Thus, the only option left here is to substitute a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the second position. But, if we do so, and consider the 5-bit numbers(at the 5 LSBs) with no two consecutive 1's, these new numbers will fall in the range <span class="maths katex-rendered">1</mn>0</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn></mtext>1</mn>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{10}text{00000} -&gt; textbf{10}text{11111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">10</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">00000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">10</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">11111</span></span></span></span></span></span>. But, again we can observe that considering these numbers leads to exceeding the required range. Thus, we can't consider all the 5-bit numbers for the required count by fixing <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the second position. </p>
Thus, now, we fix <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the second position and proceed further. Again, we encounter a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the third position. Thus, as discussed above, we can fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at this position and find out the count of 4-bit consecutive numbers with no two consecutive 1's(by varying only the 4 LSB bits). We can obtain this value from <span class="maths katex-rendered">f</mi>[</mo>4</mn>]</mo></mrow><annotation encoding="application/x-tex">f[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">4</span>]</span></span></span></span></span>. Thus, now the numbers in the range <span class="maths katex-rendered">1</mn>0</mn>0</mn></mtext>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>0</mn></mtext>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{100}text{0000} -&gt; textbf{100}text{1111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">0000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">1111</span></span></span></span></span></span> have been covered up. </p>
Again, as discussed above, now we fix a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the third position, and proceed with the fourth bit. It is a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span>. So, we need to fix it as such as per the above discussion, and proceed with the fifth bit. It is a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span>. So, we fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> here and consider all the numbers by varying the two LSBs for finding the required count of numbers in the range <span class="maths katex-rendered">1</mn>0</mn>1</mn>0</mn>1</mn></mtext>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>1</mn>0</mn>1</mn></mtext>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{10101}text{00} -&gt; textbf{10101}text{11}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">10101</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">00</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">10101</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">11</span></span></span></span></span></span>. Now, we proceed to the sixth bit, find a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> there. So, we fix <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the sixth position and proceed to the seventh bit which is again <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span>. So, we fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the seventh position as well.</p>
Now, we can see, that based on the above procedure, the numbers in the range <span class="maths katex-rendered">1</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn></mtext>1</mn>1</mn>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{1}text{000000} -&gt; textbf{1}text{111111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">1</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">1</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111111</span></span></span></span></span></span>, <span class="maths katex-rendered">1</mn>0</mn>0</mn></mtext>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>0</mn></mtext>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{100}text{0000} -&gt; textbf{100}text{1111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">0000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">1111</span></span></span></span></span></span>,  <span class="maths katex-rendered">1</mn>0</mn>0</mn></mtext>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>0</mn></mtext>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{100}text{0000} -&gt; textbf{100}text{1111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">0000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">1111</span></span></span></span></span></span> have been considered and the counts for these ranges have been obtained as <span class="maths katex-rendered">f</mi>[</mo>6</mn>]</mo></mrow><annotation encoding="application/x-tex">f[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">6</span>]</span></span></span></span></span>, <span class="maths katex-rendered">f</mi>[</mo>4</mn>]</mo></mrow><annotation encoding="application/x-tex">f[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">4</span>]</span></span></span></span></span> and <span class="maths katex-rendered">f</mi>[</mo>2</mn>]</mo></mrow><annotation encoding="application/x-tex">f[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">2</span>]</span></span></span></span></span> respectively. Now, only <span class="maths katex-rendered">1</mn>0</mn>1</mn>0</mn>1</mn>0</mn>0</mn></mtext></mrow><annotation encoding="application/x-tex">text{1010100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1010100</span></span></span></span></span></span> is pending to be considered in the required count. Since, it doesn't contain any consecutive 1's, we add a 1 to the total count obtained till now to consider this number. Thus, the result returned is <span class="maths katex-rendered">f</mi>[</mo>6</mn>]</mo>+</mo>f</mi>[</mo>4</mn>]</mo>+</mo>f</mi>[</mo>2</mn>]</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">f[6] + f[4] + f[2] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">6</span>]</span>+</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">4</span>]</span>+</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">2</span>]</span>+</span><span class="mord mathrm">1</span></span></span></span></span>.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 12</div></div></div>
Now, we look at the case, where <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> contains some consecutive 1's. The idea will be the same as the last example, with the only exception taken when the two consecutive 1's are encountered. Let's say, <span class="maths katex-rendered">n</mi>u</mi>m</mi>=</mo>1</mn>0</mn>1</mn>1</mn>0</mn>1</mn>0</mn></mtext></mrow><annotation encoding="application/x-tex">num = text{1011010}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">1011010</span></span></span></span></span></span>(7 bit number). Now, as per the last discussion, we start with the MSB. We find a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at this position. Thus, we initially fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at this position to consider the numbers in the range <span class="maths katex-rendered">0</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>0</mn></mtext>1</mn>1</mn>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{0}text{000000} -&gt; textbf{0}text{111111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">0</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">0</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111111</span></span></span></span></span></span>, by varying the 6 LSB bits only. The count of the required numbers in this range is again given by <span class="maths katex-rendered">f</mi>[</mo>6</mn>]</mo></mrow><annotation encoding="application/x-tex">f[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">6</span>]</span></span></span></span></span>.</p>
Now, we fix a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the MSB and move on to the second bit. It is a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span>, so we have no choice but to fix <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at this position and to proceed with the third bit. It is a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span>, so we fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> here, considering the numbers in the range <span class="maths katex-rendered">1</mn>0</mn>0</mn></mtext>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>0</mn></mtext>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{100}text{0000} -&gt; textbf{100}text{1111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">0000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">1111</span></span></span></span></span></span>. This accounts for a factor of <span class="maths katex-rendered">f</mi>[</mo>4</mn>]</mo></mrow><annotation encoding="application/x-tex">f[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">4</span>]</span></span></span></span></span>. Now, we fix a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> at the third positon, and proceed with the fourth bit. It is a <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span>(consecutive to the previous <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span>). Now, initially we fix a <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> at the fourth position, considering the numbers in the range <span class="maths katex-rendered">1</mn>0</mn>1</mn>0</mn></mtext>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>1</mn>0</mn></mtext>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{1010}text{000} -&gt; textbf{1010}text{111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">1010</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">1010</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111</span></span></span></span></span></span>. This adds a factor of <span class="maths katex-rendered">f</mi>[</mo>3</mn>]</mo></mrow><annotation encoding="application/x-tex">f[3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">3</span>]</span></span></span></span></span> to the required count. </p>
Now, we can see that till now the numbers in the range <span class="maths katex-rendered">0</mn></mtext>0</mn>0</mn>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>0</mn></mtext>1</mn>1</mn>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{0}text{000000} -&gt; textbf{0}text{111111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">0</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">0</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111111</span></span></span></span></span></span>, <span class="maths katex-rendered">1</mn>0</mn>0</mn></mtext>0</mn>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>0</mn></mtext>1</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{100}text{0000} -&gt; textbf{100}text{1111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">0000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">100</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">1111</span></span></span></span></span></span>, <span class="maths katex-rendered">1</mn>0</mn>1</mn>0</mn></mtext>0</mn>0</mn>0</mn></mtext>−</mo>&gt;</mo>1</mn>0</mn>1</mn>0</mn></mtext>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">textbf{1010}text{000} -&gt; textbf{1010}text{111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathbf">1010</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">000</span></span>−</span>&gt;</span><span class="mord text textstyle uncramped"><span class="mord mathbf">1010</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">111</span></span></span></span></span></span> have been considered. But, if we try to consider any number larger than <span class="maths katex-rendered">1</mn>0</mn>1</mn>0</mn>1</mn>1</mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1010111}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1010111</span></span></span></span></span></span>, it leads to the presence of two consecutive 1's in the new number at the third and fourth position. Thus, all the valid numbers upto <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> have been considered with this, giving a resultant count of <span class="maths katex-rendered">f</mi>[</mo>6</mn>]</mo>+</mo>f</mi>[</mo>4</mn>]</mo>+</mo>f</mi>[</mo>3</mn>]</mo></mrow><annotation encoding="application/x-tex">f[6] + f[4] + f[3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">6</span>]</span>+</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">4</span>]</span>+</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathrm">3</span>]</span></span></span></span></span>.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 8</div></div></div>
Thus, summarizing the above discussion, we can say that we start scanning the given number <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> from its MSB. For every 1 encountered at the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> bit position(counting from 0 from LSB), we add a factor of <span class="maths katex-rendered">f</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> to the resultant count. For every 0 encountered, we don't add any factor. We also keep a track of the last bit checked. If we happen to find two consecutive 1's at any time, we add the factors for the positions of both the 1's and stop the traversal immediately. If we don't find any two consecutive 1's, we proceed till reaching the LSB and add an extra 1 to account for the given number <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> as well, since the procedure discussed above considers numbers upto <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> without including itself.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findIntegers</span>(</span>int</span> num</span>)</span> {</span>
        int</span>[]</span> f</span> =</span> new</span> int</span>[</span>32</span>];</span>
        f</span>[</span>0</span>]</span> =</span> 1</span>;</span>
        f</span>[</span>1</span>]</span> =</span> 2</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 2</span>;</span> i</span> &lt;</span> f</span>.</span>length</span>;</span> i</span>++)</span>
            f</span>[</span>i</span>]</span> =</span> f</span>[</span>i</span> -</span> 1</span>]</span> +</span> f</span>[</span>i</span> -</span> 2</span>];</span>
        int</span> i</span> =</span> 30</span>,</span> sum</span> =</span> 0</span>,</span> prev_bit</span> =</span> 0</span>;</span>
        while</span> (</span>i</span> &gt;=</span> 0</span>)</span> {</span>
            if</span> ((</span>num</span> &amp;</span> (</span>1</span> &lt;&lt;</span> i</span>))</span> !=</span> 0</span>)</span> {</span>
                sum</span> +=</span> f</span>[</span>i</span>];</span>
                if</span> (</span>prev_bit</span> ==</span> 1</span>)</span> {</span>
                    sum</span>--;</span>
                    break</span>;</span>
                }</span>
                prev_bit</span> =</span> 1</span>;</span>
            }</span> else</span>
                prev_bit</span> =</span> 0</span>;</span>
            i</span>--;</span>
        }</span>
        return</span> sum</span> +</span> 1</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>2</mn></msub>(</mo>m</mi>a</mi>x</mi>_</mi>i</mi>n</mi>t</mi>)</mo>=</mo>3</mn>2</mn>)</mo></mrow><annotation encoding="application/x-tex">O(log_2(max_int)=32)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.06em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>(</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span>)</span>=</span><span class="mord mathrm">3</span><span class="mord mathrm">2</span>)</span></span></span></span></span>. One loop to fill <span class="maths katex-rendered">f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span></span></span></span></span> array and one loop to check all bits of <span class="maths katex-rendered">n</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>2</mn></msub>(</mo>m</mi>a</mi>x</mi>_</mi>i</mi>n</mi>t</mi>)</mo>=</mo>3</mn>2</mn>)</mo></mrow><annotation encoding="application/x-tex">O(log_2(max_int)=32)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.06em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>(</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span>)</span>=</span><span class="mord mathrm">3</span><span class="mord mathrm">2</span>)</span></span></span></span></span>. <span class="maths katex-rendered">f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10764em;">f</span></span></span></span></span> array of size 32 is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>