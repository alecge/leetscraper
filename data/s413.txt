<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>
<a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>
<a href="#approach-3-using-recursion-accepted">Approach #3  Using Recursion [Accepted]</a></li>
<a href="#approach-5-dynamic-programming-accepted">Approach #5 Dynamic Programming [Accepted]:</a></li>
<a href="#approach-5-constant-space-dynamic-programming-accepted">Approach #5 Constant Space Dynamic Programming [Accepted]:</a></li>
<a href="#approach-6-using-formula-accepted">Approach #6 Using Formula [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>
The most naive solution is to consider every pair of elements(with atleast 1 element between them), so that the range of elements lying between these two elements acts as a slice. Then, we can iterate over every such slice(range) to check if all the consecutive elements within this range have the same difference. For every such range found, we can increment the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> that is used to keep a track of the required result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> numberOfArithmeticSlices</span>(</span>int</span>[]</span> A</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> s</span> =</span> 0</span>;</span> s</span> &lt;</span> A</span>.</span>length</span> -</span> 2</span>;</span> s</span>++)</span> {</span>
            int</span> d</span> =</span> A</span>[</span>s</span> +</span> 1</span>]</span> -</span> A</span>[</span>s</span>];</span>
            for</span> (</span>int</span> e</span> =</span> s</span> +</span> 2</span>;</span> e</span> &lt;</span> A</span>.</span>length</span>;</span> e</span>++)</span> {</span>
                int</span> i</span> =</span> 0</span>;</span>
                for</span> (</span>i</span> =</span> s</span> +</span> 1</span>;</span> i</span> &lt;=</span> e</span>;</span> i</span>++)</span>
                    if</span> (</span>A</span>[</span>i</span>]</span> -</span> A</span>[</span>i</span> -</span> 1</span>]</span> !=</span> d</span>)</span>
                        break</span>;</span>
                if</span> (</span>i</span> &gt;</span> e</span>)</span>
                    count</span>++;</span>
            }</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. We iterate over the range formed by every pair of elements. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the number of elements in the given array <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant extra space is used.</p>
</li>
</ul>

<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>
Algorithm</strong></p>
In the last approach, we considered every possible range and then iterated over the range to check if the difference between every consercutive element in this range is the same. We can optimize this approach to some extent, by making a small observation. </p>
We can see, that if we are currently considering the range bound by the elements, let's say, <span class="maths katex-rendered">A</mi>[</mo>s</mi>]</mo></mrow><annotation encoding="application/x-tex">A[s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit">s</span>]</span></span></span></span></span>(start) and <span class="maths katex-rendered">A</mi>[</mo>e</mi>]</mo></mrow><annotation encoding="application/x-tex">A[e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit">e</span>]</span></span></span></span></span>(end), we have checked the consecutive elements in this range to have the same difference. Now, when we move on to the next range between the indices <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">e</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">e+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span>+</span><span class="mord mathrm">1</span></span></span></span></span>, we again perform a check on all the elements in the range <span class="maths katex-rendered">s</mi>:</mo>e</mi></mrow><annotation encoding="application/x-tex">s:e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>:</span><span class="mord mathit">e</span></span></span></span></span>, along with one additional pair <span class="maths katex-rendered">A</mi>[</mo>e</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">A[e+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit">e</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">A</mi>[</mo>e</mi>]</mo></mrow><annotation encoding="application/x-tex">A[e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit">e</span>]</span></span></span></span></span>. We can remove this redundant check in the range <span class="maths katex-rendered">s</mi>:</mo>e</mi></mrow><annotation encoding="application/x-tex">s:e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span>:</span><span class="mord mathit">e</span></span></span></span></span> and just check the last pair to have the same difference as the one used for the previous range(same <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, incremented <span class="maths katex-rendered">e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span></span></span></span></span>).</p>
Note that if the last range didn't constitute an arithmetic slice, the same elements will be a part of the updated range as well. Thus, we can omit the rest of the ranges consisting of the same starting index. The rest of the process remains the same as in the last approach.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> numberOfArithmeticSlices</span>(</span>int</span>[]</span> A</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> s</span> =</span> 0</span>;</span> s</span> &lt;</span> A</span>.</span>length</span> -</span> 2</span>;</span> s</span>++)</span> {</span>
            int</span> d</span> =</span> A</span>[</span>s</span> +</span> 1</span>]</span> -</span> A</span>[</span>s</span>];</span>
            for</span> (</span>int</span> e</span> =</span> s</span> +</span> 2</span>;</span> e</span> &lt;</span> A</span>.</span>length</span>;</span> e</span>++)</span> {</span>
                if</span> (</span>A</span>[</span>e</span>]</span> -</span> A</span>[</span>e</span> -</span> 1</span>]</span> ==</span> d</span>)</span>
                    count</span>++;</span>
                else</span>
                    break</span>;</span>
            }</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Two for loops are used.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant extra space is used.</p>
</li>
</ul>

<h4 id="approach-3-using-recursion-accepted">Approach #3  Using Recursion [Accepted]</h4>
Algorithm</strong></p>
By making use of the observation discussed in the last approach, we know, that if a range of elements between the indices <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> constitute an Arithmetic Slice, and another element <span class="maths katex-rendered">A</mi>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">A[j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> is included such that <span class="maths katex-rendered">A</mi>[</mo>j</mi>+</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">A[j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">A</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">A[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> have the same difference as that of the previous common difference, the ranges between <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(i,j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> will constitutes an arithmetic slice. Further, if the original range <span class="maths katex-rendered">(</mo>i</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> doesn't form an arithmetic slice, adding new elements to this range won't do us any good. Thus, no more arithmetic slices can be obtained by adding new elements to it.</p>
By making use of this observation, we can develop a recursive solution for the given problem as well. Assume that a <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> variable is used to store the total number of arithmetic slices in the given array <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span>. We make use of a recursive function slices(A,i)</code> which returns the number of Arithmetic Slices in the range <span class="maths katex-rendered">(</mo>k</mi>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(k,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span>, but which are not a part of any range <span class="maths katex-rendered">(</mo>k</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(k,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> such that <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>. It also updates <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> with the number of arithmetic slices(total) in the current range. Thus, <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> refers to  the minimum index such that the range <span class="maths katex-rendered">(</mo>k</mi>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(k,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> constitutes a valid arithmetic slice.</p>
Now, suppose we know the number of arithmetic slices in the range <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(0,i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span> constituted by the elements <span class="maths katex-rendered">[</mo>a</mi>0</mn></msub>,</mo>a</mi>1</mn></msub>,</mo>a</mi>2</mn></msub>,</mo>.</mi>.</mi>.</mi>a</mi>(</mo></msub>i</mi>−</mo>1</mn>)</mo>]</mo></mrow><annotation encoding="application/x-tex">[a_0,a_1,a_2,...a_(i-1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathit">a</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>]</span></span></span></span></span>, to be say <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>. If this range itself is an arithmetic slice, all the consecutive elements have the same difference(equal to say, <span class="maths katex-rendered">a</mi>(</mo></msub>i</mi>−</mo>1</mn>)</mo>−</mo>a</mi>(</mo></msub>i</mi>−</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">a_(i-1)-a_(i-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>−</span><span class="mord mathit">a</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span>)</span></span></span></span></span>). Now, adding a new element <span class="maths katex-rendered">a</mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> to it to extend the range to <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> will constitute an arithmetic slice only if this new element satisfies <span class="maths katex-rendered">a</mi>i</mi></msub>−</mo>a</mi>(</mo></msub>i</mi>−</mo>1</mn>)</mo>=</mo>a</mi>(</mo></msub>i</mi>−</mo>1</mn>)</mo>−</mo>a</mi>(</mo></msub>i</mi>−</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">a_i-a_(i-1)=a_(i-1)-a_(i-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>−</span><span class="mord mathit">a</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>=</span><span class="mord mathit">a</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>−</span><span class="mord mathit">a</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mopen mtight">(</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span>)</span></span></span></span></span>. Thus, now, the addition of this new element, will lead to an addition of <span class="maths katex-rendered">a</mi>p</mi></mrow><annotation encoding="application/x-tex">ap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> number of arithmetic slices to the ones obtained in the range <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(0,i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. The new arithmetic slices will be the ones constituting the ranges <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>)</mo>,</mo>(</mo>1</mn>,</mo>i</mi>)</mo>,</mo>.</mi>.</mi>.</mi>(</mo>i</mi>−</mo>2</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(0,i), (1,i), ... (i-2,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span>,</span>(</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">i</span>)</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span>, which are a total of  <span class="maths katex-rendered">x</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span>+</span><span class="mord mathrm">1</span></span></span></span></span> additional arithmetic slices. This is because, apart from the range <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> the rest of the ranges <span class="maths katex-rendered">(</mo>1</mn>,</mo>i</mi>)</mo>,</mo>(</mo>2</mn>,</mo>i</mi>)</mo>,</mo>.</mi>.</mi>.</mi>(</mo>i</mi>−</mo>2</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(1,i), (2,i),...(i-2,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">i</span>)</span>,</span>(</span><span class="mord mathrm">2</span>,</span><span class="mord mathit">i</span>)</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> can be mapped to <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>−</mo>1</mn>)</mo>,</mo>(</mo>1</mn>,</mo>i</mi>−</mo>1</mn>)</mo>,</mo>.</mi>.</mi>.</mi>(</mo>i</mi>−</mo>3</mn>,</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(0,i-1), (1,i-1),...(i-3,i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>,</span>(</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">3</span>,</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>, with count equal to <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>. </p>
Thus, in every call to slices</code>, if the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element has the same common difference with the last element as the previous common difference, we can find the number of new arithmetic slices added by the use of this element, <span class="maths katex-rendered">a</mi>p</mi></mrow><annotation encoding="application/x-tex">ap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> and also update the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> to include this <span class="maths katex-rendered">a</mi>p</mi></mrow><annotation encoding="application/x-tex">ap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> into it, apart from the count obtained by the smaller ranges. But, if the new element doesn't have the same common difference, extra arithmetic slices can't be contributed by it and hence, no addition is done to <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> for the current element. But, of course <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> will be updated as per the count obtained from the smaller ranges.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> sum</span> =</span> 0</span>;</span>
    public</span> int</span> numberOfArithmeticSlices</span>(</span>int</span>[]</span> A</span>)</span> {</span>
        slices</span>(</span>A</span>,</span> A</span>.</span>length</span> -</span> 1</span>);</span>
        return</span> sum</span>;</span>
    }</span>
    public</span> int</span> slices</span>(</span>int</span>[]</span> A</span>,</span> int</span> i</span>)</span> {</span>
        if</span> (</span>i</span> &lt;</span> 2</span>)</span>
            return</span> 0</span>;</span>
        int</span> ap</span> =</span> 0</span>;</span>
        if</span> (</span>A</span>[</span>i</span>]</span> -</span> A</span>[</span>i</span> -</span> 1</span>]</span> ==</span> A</span>[</span>i</span> -</span> 1</span>]</span> -</span> A</span>[</span>i</span> -</span> 2</span>])</span> {</span>
            ap</span> =</span> 1</span> +</span> slices</span>(</span>A</span>,</span> i</span> -</span> 1</span>);</span>
            sum</span> +=</span> ap</span>;</span>
        }</span> else</span>
            slices</span>(</span>A</span>,</span> i</span> -</span> 1</span>);</span>
        return</span> ap</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The recursive function is called at most <span class="maths katex-rendered">n</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span></span></span></span></span> times.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the recursion tree goes upto <span class="maths katex-rendered">n</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-5-dynamic-programming-accepted">Approach #5 Dynamic Programming [Accepted]:</h4>
Algorithm</strong></p>
In the last approach, we start with the full range <span class="maths katex-rendered">(</mo>0</mn>,</mo>n</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(0,n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the number of elements in the given <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span> array. We can observe that the result for the range <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> only depends on the elements in the range <span class="maths katex-rendered">(</mo>0</mn>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(0,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">0</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> and not on any element beyond this range. Thus, we can make use of Dynamic Programming to solve the given problem.</p>
We can make use of a 1-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> with number of elements equal to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> is used to store the number of arithmetic slices possible in the range <span class="maths katex-rendered">(</mo>k</mi>,</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">(k,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit">i</span>)</span></span></span></span></span> and not in any range <span class="maths katex-rendered">(</mo>k</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(k,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> such that <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>. Again, <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> refers to the minimum index possible such that <span class="maths katex-rendered">(</mo>k</mi>,</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">(k,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> constitutes a valid Arithmetic Slice.</p>
Instead of going in the reverse order as in the recursive approach, we can start filling the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> in a forward manner. The intuition remains the same as in the last approach. For the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> element being considered, we check if this element satsfies the common difference criteria with the previous element. If so, we know the number of new arithmetic slices added will be <span class="maths katex-rendered">1</mn>+</mo>d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">1+dp[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span>+</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> as discussed in the last approach. The <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> is also updated by the same count to reflect the new arithmetic slices added.  </p>
The following animation illustrates the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> filling process.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 9</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> numberOfArithmeticSlices</span>(</span>int</span>[]</span> A</span>)</span> {</span>
        int</span>[]</span> dp</span> =</span> new</span> int</span>[</span>A</span>.</span>length</span>];</span>
        int</span> sum</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 2</span>;</span> i</span> &lt;</span> dp</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>A</span>[</span>i</span>]</span> -</span> A</span>[</span>i</span> -</span> 1</span>]</span> ==</span> A</span>[</span>i</span> -</span> 1</span>]</span> -</span> A</span>[</span>i</span> -</span> 2</span>])</span> {</span>
                dp</span>[</span>i</span>]</span> =</span> 1</span> +</span> dp</span>[</span>i</span> -</span> 1</span>];</span>
                sum</span> +=</span> dp</span>[</span>i</span>];</span>
            }</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse over the given <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span> array with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements once only.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. 1-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-5-constant-space-dynamic-programming-accepted">Approach #5 Constant Space Dynamic Programming [Accepted]:</h4>
Algorithm</strong></p>
In the last approach, we can observe that we only require the element <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> to determine the value to be entered at <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element. </p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> numberOfArithmeticSlices</span>(</span>int</span>[]</span> A</span>)</span> {</span>
        int</span> dp</span> =</span> 0</span>;</span>
        int</span> sum</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 2</span>;</span> i</span> &lt;</span> A</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>A</span>[</span>i</span>]</span> -</span> A</span>[</span>i</span> -</span> 1</span>]</span> ==</span> A</span>[</span>i</span> -</span> 1</span>]</span> -</span> A</span>[</span>i</span> -</span> 2</span>])</span> {</span>
                dp</span> =</span> 1</span> +</span> dp</span>;</span>
                sum</span> +=</span> dp</span>;</span>
            }</span> else</span>
                dp</span> =</span> 0</span>;</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We traverse over the given <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span> array with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements once only.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant extra space is used.</p>
</li>
</ul>

<h4 id="approach-6-using-formula-accepted">Approach #6 Using Formula [Accepted]:</h4>
Algorithm</strong></p>
From the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> solution, we can observe that for <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> consecutive elements sastisfying the common difference criteria, we update the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> for each such element by <span class="maths katex-rendered">1</mn>,</mo>2</mn>,</mo>3</mn>,</mo>.</mi>.</mi>.</mi>,</mo>k</mi></mrow><annotation encoding="application/x-tex">1, 2, 3, ..., k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span>,</span><span class="mord mathrm">2</span>,</span><span class="mord mathrm">3</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>,</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> counts in that order. Thus, instead of updating the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> at the same time, we can just keep a track of the number of consecutive elements satisfying the common differnce criteria in a <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> variable and just update the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> directly as <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>∗</mo>(</mo>c</mi>o</mi>u</mi>n</mi>t</mi>+</mo>1</mn>)</mo>/</mi>2</mn></mrow><annotation encoding="application/x-tex">count*(count+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>∗</span>(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>+</span><span class="mord mathrm">1</span>)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> whenver an element not satisfying this criteria is found. At the same time, we also need to reset the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> value. </p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> numberOfArithmeticSlices</span>(</span>int</span>[]</span> A</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        int</span> sum</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 2</span>;</span> i</span> &lt;</span> A</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>A</span>[</span>i</span>]</span> -</span> A</span>[</span>i</span> -</span> 1</span>]</span> ==</span> A</span>[</span>i</span> -</span> 1</span>]</span> -</span> A</span>[</span>i</span> -</span> 2</span>])</span> {</span>
                count</span>++;</span>
            }</span> else</span> {</span>
                sum</span> +=</span> (</span>count</span> +</span> 1</span>)</span> *</span> (</span>count</span>)</span> /</span> 2</span>;</span>
                count</span> =</span> 0</span>;</span>
            }</span>
        }</span>
        return</span> sum</span> +=</span> count</span> *</span> (</span>count</span> +</span> 1</span>)</span> /</span> 2</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We iterate over <span class="maths katex-rendered">A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span></span> with <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> elements exactly once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant extra space is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>