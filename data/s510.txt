<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>
<a href="#approach-3-backtracking-accepted">Approach #3 Backtracking [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
In the brute force method, we can find out all the arrays that can be formed using the numbers from 1 to N(by creating every possible permutation of the given elements). Then, we iterate over all the elements of every permutation generated and check for the required conditions of divisibility.</p>
In order to generate all the possible pairings, we make use of a function permute(nums, current_index)</code>. This function creates all the possible permutations of the elements of the given array.</p>
To do so, permute</code> takes the index of the current element <span class="maths katex-rendered">c</mi>u</mi>r</mi>r</mi>e</mi>n</mi>t</mi>i</mi></msub>n</mi>d</mi>e</mi>x</mi></mrow><annotation encoding="application/x-tex">current_index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">x</span></span></span></span></span> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>
Thus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.</p>
!?!../Documents/561_Array.json:1000,563!?!</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> count</span> =</span> 0</span>;</span>
    public</span> int</span> countArrangement</span>(</span>int</span> N</span>)</span> {</span>
        int</span>[]</span> nums</span> =</span> new</span> int</span>[</span>N</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> N</span>;</span> i</span>++)</span>
            nums</span>[</span>i</span> -</span> 1</span>]</span> =</span> i</span>;</span>
        permute</span>(</span>nums</span>,</span> 0</span>);</span>
        return</span> count</span>;</span>
    }</span>
    public</span> void</span> permute</span>(</span>int</span>[]</span> nums</span>,</span> int</span> l</span>)</span> {</span>
        if</span> (</span>l</span> ==</span> nums</span>.</span>length</span> -</span> 1</span>)</span> {</span>
            int</span> i</span>;</span>
            for</span> (</span>i</span> =</span> 1</span>;</span> i</span> &lt;=</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
                if</span> (</span>nums</span>[</span>i</span> -</span> 1</span>]</span> %</span> i</span> !=</span> 0</span> &amp;&amp;</span> i</span> %</span> nums</span>[</span>i</span> -</span> 1</span>]</span> !=</span> 0</span>)</span>
                    break</span>;</span>
            }</span>
            if</span> (</span>i</span> ==</span> nums</span>.</span>length</span> +</span> 1</span>)</span> {</span>
                count</span>++;</span>
            }</span>
        }</span>
        for</span> (</span>int</span> i</span> =</span> l</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            swap</span>(</span>nums</span>,</span> i</span>,</span> l</span>);</span>
            permute</span>(</span>nums</span>,</span> l</span> +</span> 1</span>);</span>
            swap</span>(</span>nums</span>,</span> i</span>,</span> l</span>);</span>
        }</span>
    }</span>
    public</span> void</span> swap</span>(</span>int</span>[]</span> nums</span>,</span> int</span> x</span>,</span> int</span> y</span>)</span> {</span>
        int</span> temp</span> =</span> nums</span>[</span>x</span>];</span>
        nums</span>[</span>x</span>]</span> =</span> nums</span>[</span>y</span>];</span>
        nums</span>[</span>y</span>]</span> =</span> temp</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>!</mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>!</span>)</span></span></span></span></span>. A total of <span class="maths katex-rendered">n</mi>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>!</span></span></span></span></span> permutations will be generated for an array of length <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>
Algorithm</strong></p>
In the brute force approach, we create the full array for every permutation and then check the array for the given divisibilty conditions. But this method can be optimized to a great extent. To do so, we can keep checking the elements while being added to the permutation array at every step for the divisibility condition and  can stop creating it any further as soon as we find out the element just added to the permutation violates the divisiblity condition. </p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> count</span> =</span> 0</span>;</span>
    public</span> int</span> countArrangement</span>(</span>int</span> N</span>)</span> {</span>
        int</span>[]</span> nums</span> =</span> new</span> int</span>[</span>N</span>];</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> N</span>;</span> i</span>++)</span>
            nums</span>[</span>i</span> -</span> 1</span>]</span> =</span> i</span>;</span>
        permute</span>(</span>nums</span>,</span> 0</span>);</span>
        return</span> count</span>;</span>
    }</span>
    public</span> void</span> permute</span>(</span>int</span>[]</span> nums</span>,</span> int</span> l</span>)</span> {</span>
        if</span> (</span>l</span> ==</span> nums</span>.</span>length</span>)</span> {</span>
            count</span>++;</span>
        }</span>
        for</span> (</span>int</span> i</span> =</span> l</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            swap</span>(</span>nums</span>,</span> i</span>,</span> l</span>);</span>
            if</span> (</span>nums</span>[</span>l</span>]</span> %</span> (</span>l</span> +</span> 1</span>)</span> ==</span> 0</span> ||</span> (</span>l</span> +</span> 1</span>)</span> %</span> nums</span>[</span>l</span>]</span> ==</span> 0</span>)</span>
                permute</span>(</span>nums</span>,</span> l</span> +</span> 1</span>);</span>
            swap</span>(</span>nums</span>,</span> i</span>,</span> l</span>);</span>
        }</span>
    }</span>
    public</span> void</span> swap</span>(</span>int</span>[]</span> nums</span>,</span> int</span> x</span>,</span> int</span> y</span>)</span> {</span>
        int</span> temp</span> =</span> nums</span>[</span>x</span>];</span>
        nums</span>[</span>x</span>]</span> =</span> nums</span>[</span>y</span>];</span>
        nums</span>[</span>y</span>]</span> =</span> temp</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> refers to the number of valid permutations.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Further, <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used, where, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the given number.</p>
</li>
</ul>

<h4 id="approach-3-backtracking-accepted">Approach #3 Backtracking [Accepted]</h4>
Algorithm</strong></p>
The idea behind this approach is simple. We try to create all the permutations of numbers from 1 to N. We can fix one number at a particular position and check for the divisibility criteria of that number at the particular position. But, we need to keep a track of the numbers which have already been considered earlier so that they aren't reconsidered while generating the permutations. If the current 
number doesn't satisfy the divisibility criteria, we can leave all the permutations that can be generated with that number at the particular position. This helps to prune the search space of the permutations to a great extent. We do so by trying to place each of the numbers at each position.</p>
We make use of a visited array of size <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span>. Here, <span class="maths katex-rendered">v</mi>i</mi>s</mi>i</mi>t</mi>e</mi>d</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">visited[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> refers to the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> number being already placed/not placed in the array being formed till now(True indicates that the number has already been placed).</p>
We make use of a calculate</code> function, which puts all the numbers pending numbers from 1 to N(i.e. not placed till now in the array), indicated by a <span class="maths katex-rendered">F</mi>a</mi>l</mi>s</mi>e</mi></mrow><annotation encoding="application/x-tex">False</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></span> at the corresponding <span class="maths katex-rendered">v</mi>i</mi>s</mi>i</mi>t</mi>e</mi>d</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">visited[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> position, and tries to create all the permutations with those numbers starting from the <span class="maths katex-rendered">p</mi>o</mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit">s</span></span></span></span></span> index onwards in the current array. While putting the <span class="maths katex-rendered">p</mi>o</mi>s</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">pos^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> number, we check whether the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> number satisfies the divisibility criteria on the go i.e. we continue forward with creating the permutations with the number <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> at the <span class="maths katex-rendered">p</mi>o</mi>s</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">pos^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position only if the number <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">p</mi>o</mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit">s</span></span></span></span></span> satisfy the given criteria. Otherwise, we continue with putting the next numbers at the same position and keep on generating the permutations.</p>
Look at the animation below for a better understanding of the methodology:</p>
!?!../Documents/526_Beautiful.json:1000,563!?!</p>
Below code is inspired by <a href="http://leetcode.com/shawngao">@shawngao</a></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> count</span> =</span> 0</span>;</span>
    public</span> int</span> countArrangement</span>(</span>int</span> N</span>)</span> {</span>
        boolean</span>[]</span> visited</span> =</span> new</span> boolean</span>[</span>N</span> +</span> 1</span>];</span>
        calculate</span>(</span>N</span>,</span> 1</span>,</span> visited</span>);</span>
        return</span> count</span>;</span>
    }</span>
    public</span> void</span> calculate</span>(</span>int</span> N</span>,</span> int</span> pos</span>,</span> boolean</span>[]</span> visited</span>)</span> {</span>
        if</span> (</span>pos</span> &gt;</span> N</span>)</span>
            count</span>++;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> N</span>;</span> i</span>++)</span> {</span>
            if</span> (!</span>visited</span>[</span>i</span>]</span> &amp;&amp;</span> (</span>pos</span> %</span> i</span> ==</span> 0</span> ||</span> i</span> %</span> pos</span> ==</span> 0</span>))</span> {</span>
                visited</span>[</span>i</span>]</span> =</span> true</span>;</span>
                calculate</span>(</span>N</span>,</span> pos</span> +</span> 1</span>,</span> visited</span>);</span>
                visited</span>[</span>i</span>]</span> =</span> false</span>;</span>
            }</span>
        }</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> refers to the number of valid permutations.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">v</mi>i</mi>s</mi>i</mi>t</mi>e</mi>d</mi></mrow><annotation encoding="application/x-tex">visited</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used. The depth of recursion tree will also go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the given integer <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>