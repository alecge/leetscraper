<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-collectionsort-accepted">Approach #1 Using Collection.sort( ) [Accepted]</a></li>
<a href="#approach-2-using-binary-search-and-two-pointers-accepted">Approach #2 Using Binary Search and Two Pointers [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-collectionsort-accepted">Approach #1 Using Collection.sort( ) [Accepted]</h4>
Algorithm</strong></p>
Intuitively, we can sort the elements in list arr</code> by their absolute difference values to the target x</code>. Then the sublist of the first k elements is the result after sorting the elements by the natural order.</p>
Java</strong></p>
</span>public</span> List</span>&lt;</span>Integer</span>&gt;</span> findClosestElements</span>(</span>List</span>&lt;</span>Integer</span>&gt;</span> arr</span>,</span> int</span> k</span>,</span> int</span> x</span>)</span> {</span>
     Collections</span>.</span>sort</span>(</span>arr</span>,</span> (</span>a</span>,</span>b</span>)</span> -&gt;</span> a</span> ==</span> b</span> ?</span> a</span> -</span> b</span> :</span> Math</span>.</span>abs</span>(</span>a</span>-</span>x</span>)</span> -</span> Math</span>.</span>abs</span>(</span>b</span>-</span>x</span>));</span>
     arr</span> =</span> arr</span>.</span>subList</span>(</span>0</span>,</span> k</span>);</span>
     Collections</span>.</span>sort</span>(</span>arr</span>);</span>
     return</span> arr</span>;</span>
}</span>
</pre></div>


Note: This solution is inspired by <a href="https://discuss.leetcode.com/user/compton_scatter">@compton_scatter</a>.</p>
Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>. Collections.sort() uses binary sort so it has a <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> complexity.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. The in-place sorting does not consume any extra space. However, generating a k length sublist will take some space.</p>
</li>
</ul>

<h4 id="approach-2-using-binary-search-and-two-pointers-accepted">Approach #2 Using Binary Search and Two Pointers [Accepted]</h4>
Algorithm</strong></p>
The original array has been sorted so we can take this advantage by the following steps.
1. If the target x</code> is less or equal than the first element in the sorted array, the first k</code> elements are the result.
2. Similarly, if the target x</code> is more or equal than the last element in the sorted array, the last k</code> elements are the result.
3. Otherwise, we can use binary search to find the index</code> of the element, which is equal (when this list has x</code>) or a little bit larger than x</code> (when this list does not have it). Then set low</code> to its left k-1</code> position, and high</code> to the right k-1</code> position of this index</code> as a start. The desired k numbers must in this rang [index-k-1, index+k-1]. So we can shrink this range to get the result using the following rules.
    * If low</code> reaches the lowest index 0</code> or the low</code> element is closer to x</code> than the high</code> element, decrease the high</code> index.
    * If high</code> reaches to the highest index arr.size()-1</code> or it is nearer to x</code> than the low</code> element, increase the low</code> index.
    * The looping ends when there are exactly k elements in [low, high], the subList of which is the result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> List</span>&lt;</span>Integer</span>&gt;</span> findClosestElements</span>(</span>List</span>&lt;</span>Integer</span>&gt;</span> arr</span>,</span> int</span> k</span>,</span> int</span> x</span>)</span> {</span>
        int</span> n</span> =</span> arr</span>.</span>size</span>();</span>
        if</span> (</span>x</span> &lt;=</span> arr</span>.</span>get</span>(</span>0</span>))</span> {</span>
            return</span> arr</span>.</span>subList</span>(</span>0</span>,</span> k</span>);</span>
        }</span> else</span> if</span> (</span>arr</span>.</span>get</span>(</span>n</span> -</span> 1</span>)</span> &lt;=</span> x</span>)</span> {</span>
            return</span> arr</span>.</span>subList</span>(</span>n</span> -</span> k</span>,</span> n</span>);</span>
        }</span> else</span> {</span>
            int</span> index</span> =</span> Collections</span>.</span>binarySearch</span>(</span>arr</span>,</span> x</span>);</span>
            if</span> (</span>index</span> &lt;</span> 0</span>)</span>
                index</span> =</span> -</span>index</span> -</span> 1</span>;</span>
            int</span> low</span> =</span> Math</span>.</span>max</span>(</span>0</span>,</span> index</span> -</span> k</span> -</span> 1</span>),</span> high</span> =</span> Math</span>.</span>min</span>(</span>arr</span>.</span>size</span>()</span> -</span> 1</span>,</span> index</span> +</span> k</span> -</span> 1</span>);</span>

            while</span> (</span>high</span> -</span> low</span> &gt;</span> k</span> -</span> 1</span>)</span> {</span>
                if</span> (</span>low</span> &lt;</span> 0</span> ||</span> (</span>x</span> -</span> arr</span>.</span>get</span>(</span>low</span>))</span> &lt;=</span> (</span>arr</span>.</span>get</span>(</span>high</span>)</span> -</span> x</span>))</span>
                    high</span>--;</span>
                else</span> if</span> (</span>high</span> &gt;</span> arr</span>.</span>size</span>()</span> -</span> 1</span> ||</span> (</span>x</span> -</span> arr</span>.</span>get</span>(</span>low</span>))</span> &gt;</span> (</span>arr</span>.</span>get</span>(</span>high</span>)</span> -</span> x</span>))</span>
                    low</span>++;</span>
                else</span>
                    System</span>.</span>out</span>.</span>println</span>(</span>"unhandled case: "</span> +</span> low</span> +</span> " "</span> +</span> high</span>);</span>
            }</span>
            return</span> arr</span>.</span>subList</span>(</span>low</span>,</span> high</span> +</span> 1</span>);</span>
        }</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>+</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log(n)+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>+</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. <span class="maths katex-rendered">O</mi>(</mo>l</mi>o</mi>g</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> is for the time of binary search, while <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span> is for shrinking the index range to k elements.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>k</mi>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span>)</span></span></span></span></span>. It is to generate the required sublist.</p>
</li>
</ul>
Analysis written by: <a href="https://discuss.leetcode.com/user/mr-bin">@Mr.Bin</a></p>