<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-sorting-accepted">Approach #1 Using Sorting [Accepted]</a></li>
<a href="#approach-2-using-priority-queue-accepted">Approach #2 Using Priority-Queue [Accepted]</a></li>
<a href="#approach-3-calculating-idle-slots-accepted">Approach #3 Calculating Idle slots [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-sorting-accepted">Approach #1 Using Sorting [Accepted]</h4>
Before we start off with the solution, we can note that the names of the tasks are irrelevant for obtaining the solution of the given problem. The time taken for the tasks to be finished is only dependent on the number of instances of each task and not on the names of tasks. </p>
The first solution that comes to the mind is to consider the tasks to be executed in the descending order of their number of instances. For every task executed, we can keep a track of the time at which this task was executed in order to consider the impact of cooling time in the future. We can execute all the tasks in the descending order of their number of instances and can keep on updating the number of instances pending for each task as well. After one cycle of the task list is executed, we can again start with the first task(largest count of instances) and keep on continuing the process by inserting idle cycles wherever appropriate by considering the last execution time of the task and the cooling time as well. </p>
But, there is a flaw in the above idea. Consider the case, where say the number of instances of tasks A, B, C, D, E  are 6, 1, 1, 1, 1 respectively with n=2(cooling time). If we go by the above method, firstly we give 1 round to each A, B, C, D and E. Now, only 5 instances of A are pending, but each instance will take 3 time units to complete because of cooling time. But a better way to schedule the tasks will be this: A, B, C, A, D, E, ... . In this way, by giving turn to the task A as soon as its cooling time is over, we can save a good number of clock cycles.</p>
From the above example, we are clear with one idea. It is that, the tasks with the currently maximum number of outstanding (pending)instances will contribute to a large number of idle cycles in the future, if not executed with appropriate interleavings with the other tasks. Thus, we need to re-execute such a task as soon as its cooling time is finished. </p>
Thus, based on the above ideas, firstly, we obtain a count of the number of instances of each task in <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> array. Then, we start executing the tasks in the order of descending number of their initial instances. As soon as we execute the first task, we start its cooling timer as well(<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>). For every task executed, we update the pending number of instances of the current task. We update the current time, <span class="maths katex-rendered">t</mi>i</mi>m</mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span></span>, at every instant as well. Now, as soon as the timer, <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>'s value exceeds the cooling time, as discussed above, we again need to consider the task with the largest number of pending instances. Thus, we again sort the <span class="maths katex-rendered">t</mi>a</mi>s</mi>k</mi>s</mi></mrow><annotation encoding="application/x-tex">tasks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">s</span></span></span></span></span> array with updated counts of instances and again pick up the tasks in the descending order of their number of instances. </p>
Now, the task picked up first after the sorting, will either be the first task picked up in the last iteration(which will now be picked after its cooling time has been finished) or the task picked will be the one which lies at <span class="maths katex-rendered">(</mo>n</mi>+</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(n+1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> position in the previous descending <span class="maths katex-rendered">t</mi>a</mi>s</mi>k</mi>s</mi></mrow><annotation encoding="application/x-tex">tasks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">s</span></span></span></span></span> array. In either of the cases, the cooling time won't cause any conflicts(it has been considered implicitly). Further, the task most critical currently will always be picked up which was the main requirement.</p>
We stop this process, when the pending instances of all the tasks have been reduced to 0. At this moment, <span class="maths katex-rendered">t</mi>i</mi>m</mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span></span> gives the required result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> leastInterval</span>(</span>char</span>[]</span> tasks</span>,</span> int</span> n</span>)</span> {</span>
        int</span>[]</span> map</span> =</span> new</span> int</span>[</span>26</span>];</span>
        for</span> (</span>char</span> c</span>:</span> tasks</span>)</span>
            map</span>[</span>c</span> -</span> 'A'</span>]++;</span>
        Arrays</span>.</span>sort</span>(</span>map</span>);</span>
        int</span> time</span> =</span> 0</span>;</span>
        while</span> (</span>map</span>[</span>25</span>]</span> &gt;</span> 0</span>)</span> {</span>
            int</span> i</span> =</span> 0</span>;</span>
            while</span> (</span>i</span> &lt;=</span> n</span>)</span> {</span>
                if</span> (</span>map</span>[</span>25</span>]</span> ==</span> 0</span>)</span>
                    break</span>;</span>
                if</span> (</span>i</span> &lt;</span> 26</span> &amp;&amp;</span> map</span>[</span>25</span> -</span> i</span>]</span> &gt;</span> 0</span>)</span>
                    map</span>[</span>25</span> -</span> i</span>]--;</span>
                time</span>++;</span>
                i</span>++;</span>
            }</span>
            Arrays</span>.</span>sort</span>(</span>map</span>);</span>
        }</span>
        return</span> time</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>t</mi>i</mi>m</mi>e</mi>)</mo></mrow><annotation encoding="application/x-tex">O(time)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span>)</span></span></span></span></span>. Number of iterations will be equal to resultant time <span class="maths katex-rendered">t</mi>i</mi>m</mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span></span>. </p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant size array <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-2-using-priority-queue-accepted">Approach #2 Using Priority-Queue [Accepted]</h4>
Algorithm</strong></p>
Instead of making use of sorting as done in the last approach, we can also make use of a Max-Heap(<span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>) to pick the order in which the tasks need to be executed. But we need to ensure that the heapification occurs only after the intervals of cooling time, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, as done in the last approach.</p>
To do so, firstly, we put only those elements from <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> into the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> which have non-zero number of instances. Then, we start picking up the largest task from the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> for current execution. (Again, at every instant, we update the current <span class="maths katex-rendered">t</mi>i</mi>m</mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span></span> as well.) We pop this element from the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>. We also decrement its pending number of instances and if any more instances of the current task are pending, we store them(count) in a temporary <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> list, to be added later on back into the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>. We keep on doing so, till a cycle of cooling time has been finished. After every such cycle, we add the generated <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> list back to the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> for considering the most critical task again. </p>
We keep on doing so till the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>(and <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span>) become totally empty. At this instant, the current value of <span class="maths katex-rendered">t</mi>i</mi>m</mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span></span> gives the required result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> leastInterval</span>(</span>char</span>[]</span> tasks</span>,</span> int</span> n</span>)</span> {</span>
        int</span>[]</span> map</span> =</span> new</span> int</span>[</span>26</span>];</span>
        for</span> (</span>char</span> c</span>:</span> tasks</span>)</span>
            map</span>[</span>c</span> -</span> 'A'</span>]++;</span>
        PriorityQueue</span> &lt;</span> Integer</span> &gt;</span> queue</span> =</span> new</span> PriorityQueue</span> &lt;</span> &gt;</span> (</span>26</span>,</span> Collections</span>.</span>reverseOrder</span>());</span>
        for</span> (</span>int</span> f</span>:</span> map</span>)</span> {</span>
            if</span> (</span>f</span> &gt;</span> 0</span>)</span>
                queue</span>.</span>add</span>(</span>f</span>);</span>
        }</span>
        int</span> time</span> =</span> 0</span>;</span>
        while</span> (!</span>queue</span>.</span>isEmpty</span>())</span> {</span>
            int</span> i</span> =</span> 0</span>;</span>
            List</span> &lt;</span> Integer</span> &gt;</span> temp</span> =</span> new</span> ArrayList</span> &lt;</span> &gt;</span> ();</span>
            while</span> (</span>i</span> &lt;=</span> n</span>)</span> {</span>
                if</span> (!</span>queue</span>.</span>isEmpty</span>())</span> {</span>
                    if</span> (</span>queue</span>.</span>peek</span>()</span> &gt;</span> 1</span>)</span>
                        temp</span>.</span>add</span>(</span>queue</span>.</span>poll</span>()</span> -</span> 1</span>);</span>
                    else</span>
                        queue</span>.</span>poll</span>();</span>
                }</span>
                time</span>++;</span>
                if</span> (</span>queue</span>.</span>isEmpty</span>()</span> &amp;&amp;</span> temp</span>.</span>size</span>()</span> ==</span> 0</span>)</span>
                    break</span>;</span>
                i</span>++;</span>
            }</span>
            for</span> (</span>int</span> l</span>:</span> temp</span>)</span>
                queue</span>.</span>add</span>(</span>l</span>);</span>
        }</span>
        return</span> time</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Number of iterations will be equal to resultant time <span class="maths katex-rendered">t</mi>i</mi>m</mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span></span>. </p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> and <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> size will not exceed O(26).</p>
</li>
</ul>

<h4 id="approach-3-calculating-idle-slots-accepted">Approach #3 Calculating Idle slots [Accepted]</h4>
Algorithm</strong></p>
This approach is inpired by <a href="http://leetcode.com/zhanzq">@zhanzq</a></p>
If we are able to, somehow, determine the number of idle slots(<span class="maths katex-rendered">i</mi>d</mi>l</mi>e</mi>_</mi>s</mi>l</mi>o</mi>t</mi>s</mi></mrow><annotation encoding="application/x-tex">idle_slots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mord mathit">s</span></span></span></span></span>), we can find out the time required to execute all the tasks as <span class="maths katex-rendered">i</mi>d</mi>l</mi>e</mi>_</mi>s</mi>l</mi>o</mi>t</mi>s</mi>+</mo>T</mi>o</mi>t</mi>a</mi>l</mi>N</mi>u</mi>m</mi>b</mi>e</mi>r</mi>O</mi>f</mi>T</mi>a</mi>s</mi>k</mi>s</mi></mrow><annotation encoding="application/x-tex">idle_slots + Total Number Of Tasks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mord mathit">s</span>+</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">s</span></span></span></span></span>. Thus, the idea is to find out the idle time first.</p>
To find the idle time, consider figure 1 below.</p>
<img alt="Tasks" src="../Figures/621_Task_Scheduler_new.PNG"></p>
From this figure, we can observe that the maximum number of idle slots will always be given by the product of the cooling time and the number of instances of the task with maximum count less 1(in case only multiple instances of the same task need to be executed, and each, then, is executed after lapse of every cooling time). The factor of 1 is deducted from the task's count with maximum number of instances, as is clear from the figure, is that in the last round of execution of the tasks, the idle slots need not be considered for insertion following the execution of the related task. Now, based on the count of the instances of the other tasks, we can reduce the number of idle slots from this maximum value, to determine the minimum number of idle slots needed.</p>
To do so, consider figure 2 as shown above. From the figure above, assuming the tasks are executed in row-wise order, we can see that in case the number of instances of another task equal the number of instances of the task with maximum number of instances, the number of idle slots saved is equal to its number of instances less 1 as is clear for the case of task B above. But, if the count of the number of instances, say <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> is lesser than the this maximum value, the number of idle slots saved is equal to the value <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> itself as is clear for the case of task C. Further, we can observe that  for any arbitrary task other than A, B or C with the count of number of instances lesser than C, this task can be easily accomodated into the idle slots or if no more idle slot is available, this task can be appended after every row of tasks without interfering with the cooling time. In the first case, subtracting its number of intances from the number of idle slots leads to obtaining the correct number of available idle slots. In the second case, which will only occur if the number of idle slots pending is already zero, it leads to negative net idle slots, which can later be considered as zero for the purpose of calculations.</p>
Thus, we can easily obtain the number of pending idle slots by subtracting appropriate number of slots from the available ones and at the end, we can obtain the total time required as the sum of pending idle slots and the total number of tasks.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> leastInterval</span>(</span>char</span>[]</span> tasks</span>,</span> int</span> n</span>)</span> {</span>
        int</span>[]</span> map</span> =</span> new</span> int</span>[</span>26</span>];</span>
        for</span> (</span>char</span> c</span>:</span> tasks</span>)</span>
            map</span>[</span>c</span> -</span> 'A'</span>]++;</span>
        Arrays</span>.</span>sort</span>(</span>map</span>);</span>
        int</span> max_val</span> =</span> map</span>[</span>25</span>]</span> -</span> 1</span>,</span> idle_slots</span> =</span> max_val</span> *</span> n</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 24</span>;</span> i</span> &gt;=</span> 0</span> &amp;&amp;</span> map</span>[</span>i</span>]</span> &gt;</span> 0</span>;</span> i</span>--)</span> {</span>
            idle_slots</span> -=</span> Math</span>.</span>min</span>(</span>map</span>[</span>i</span>],</span> max_val</span>);</span>
        }</span>
        return</span> idle_slots</span> &gt;</span> 0</span> ?</span> idle_slots</span> +</span> tasks</span>.</span>length</span> :</span> tasks</span>.</span>length</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We iterate over <span class="maths katex-rendered">t</mi>a</mi>s</mi>k</mi>s</mi></mrow><annotation encoding="application/x-tex">tasks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">s</span></span></span></span></span> array only once. (<span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>).Sorting <span class="maths katex-rendered">t</mi>a</mi>s</mi>k</mi>s</mi></mrow><annotation encoding="application/x-tex">tasks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">s</span></span></span></span></span> array of length <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> takes <span class="maths katex-rendered">O</mi>(</mo>2</mn>6</mn>l</mi>o</mi>g</mi>(</mo>2</mn>6</mn>)</mo>)</mo>=</mo>O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">Obig(26log(26)big)= O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord mathrm">2</span><span class="mord mathrm">6</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span>(</span><span class="mord mathrm">2</span><span class="mord mathrm">6</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> time. After this, only one iteration over 26 elements of <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> is done(<span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> array of constant size(26) is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>