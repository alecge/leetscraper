<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>
<a href="#approach-2-similar-approach-accepted">Approach #2 Similar Approach [Accepted]</a></li>
<a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]:</a></li>
<a href="#approach-4-1-d-dynamic-programming-accepted">Approach #4 1-D Dynamic Programming [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>
The idea behind the recursive approach is simple. The two players Player 1 and Player 2 will be taking turns alternately. For the Player 1 to be the winner, we need <span class="maths katex-rendered">score_{Player_1} ≥ score_{Player_2}</span><script type="math/tex">score_{Player_1} ≥ score_{Player_2}</script></span>. Or in other terms, <span class="maths katex-rendered">(score_{Player_1} - score_{Player_2} ≥ 0)</span>. </p>
Thus, for the turn of Player 1, we can add its score obtained to the total score and for Player 2's turn, we can substract its score from the total score. At the end, we can check if the total score is greater than or equal to zero(equal score of both players), to predict that Player 1 will be the winner.</p>
Thus, by making use of a recursive function winner(nums,s,e,turn)</code> which predicts the winner for the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array as the score array with the elements in the range of indices <span class="maths katex-rendered">[</mo>s</mi>,</mo>e</mi>]</mo></mrow><annotation encoding="application/x-tex">[s,e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">s</span>,</span><span class="mord mathit">e</span>]</span></span></span></span></span> currently being considered, given a particular player's turn, indicated by <span class="maths katex-rendered">t</mi>u</mi>r</mi>n</mi>=</mo>1</mn></mrow><annotation encoding="application/x-tex">turn=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span>=</span><span class="mord mathrm">1</span></span></span></span></span> being Player 1's turn and <span class="maths katex-rendered">t</mi>u</mi>r</mi>n</mi>=</mo>−</mo>1</mn></mrow><annotation encoding="application/x-tex">turn=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span>=</span>−</span><span class="mord mathrm">1</span></span></span></span></span> being the Player 2's turn, we can predict the winner of the given problem by making the function call winner(nums,0,n-1,1)</code>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
In every turn, we can either pick up the first(<span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>s</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">s</span>]</span></span></span></span></span>) or the last(<span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>e</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">e</span>]</span></span></span></span></span>) element of the current subarray. Since both the players are assumed to be playing smartly and making the best move at every step, both will tend to maximize their scores. Thus, we can make use of the same function winner</code> to determine the maximum score possible for any of the players. </p>
Now, at every step of the recursive process, we determine the maximum score possible for the current player. It will be the maximum one possible out of the scores obtained by picking the first or the last element of the current subarray. </p>
To obtain the score possible from the remaining subarray, we can again make use of the same winner</code> function and add the score corresponding to the point picked in the current function call. But, we need to take care of whether to add or subtract this score to the total score available. If it is Player 1's turn, we add the current number's score to the total score, otherwise, we need to subtract the same. </p>
Thus, at every step, we need update the search space appropriately based on the element chosen and also invert the <span class="maths katex-rendered">t</mi>u</mi>r</mi>n</mi></mrow><annotation encoding="application/x-tex">turn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span></span></span></span></span>'s value to indicate the turn change among the players and either add or subtract the current player's score from the total score available to determine the end result.</p>
Further, note that the value returned at every step is given by <span class="maths katex-rendered">t</mi>u</mi>r</mi>n</mi>∗</mo>m</mi>a</mi>x</mi></mtext>(</mo>t</mi>u</mi>r</mi>n</mi>∗</mo>a</mi>,</mo>t</mi>u</mi>r</mi>n</mi>∗</mo>b</mi>)</mo></mrow><annotation encoding="application/x-tex">turn *text{max}(turn * a, turn * b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span>∗</span><span class="mord text textstyle uncramped"><span class="mord mathrm">max</span></span>(</span><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span>∗</span><span class="mord mathit">a</span>,</span><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span>∗</span><span class="mord mathit">b</span>)</span></span></span></span></span>. This is equivalent to the statement <span class="maths katex-rendered">m</mi>a</mi>x</mi>(</mo>a</mi>,</mo>b</mi>)</mo></mrow><annotation encoding="application/x-tex">max(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span>(</span><span class="mord mathit">a</span>,</span><span class="mord mathit">b</span>)</span></span></span></span></span> for Player 1's turn and <span class="maths katex-rendered">m</mi>i</mi>n</mi>(</mo>a</mi>,</mo>b</mi>)</mo></mrow><annotation encoding="application/x-tex">min(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>(</span><span class="mord mathit">a</span>,</span><span class="mord mathit">b</span>)</span></span></span></span></span> for Player 2's turn. </p>
This is done because, looking from Player 1's perspective, for any move made by Player 1, it tends to leave the remaining subarray in a situation which minimizes the best score possible for Player 2, even if it plays in the best possible manner. But, when the turn passes to Player 1 again, for Player 1 to win, the remaining subarray should be left in a state such that the score obtained from this subarrray is maximum(for Player 1). </p>
This is a general criteria for any arbitrary two player game and is commonly known as the 
<a href="https://en.wikipedia.org/wiki/Minimax">Min-Max algorithm</a>.</p>
The following image shows how the scores are passed to determine the end result for a simple example.</p>
<img alt="Recursive_Tree" src="../Figures/486/486_Predict_the_winner_new.PNG"></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> PredictTheWinner</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        return</span> winner</span>(</span>nums</span>,</span> 0</span>,</span> nums</span>.</span>length</span> -</span> 1</span>,</span> 1</span>)</span> &gt;=</span> 0</span>;</span>
    }</span>
    public</span> int</span> winner</span>(</span>int</span>[]</span> nums</span>,</span> int</span> s</span>,</span> int</span> e</span>,</span> int</span> turn</span>)</span> {</span>
        if</span> (</span>s</span> ==</span> e</span>)</span>
            return</span> turn</span> *</span> nums</span>[</span>s</span>];</span>
        int</span> a</span> =</span> turn</span> *</span> nums</span>[</span>s</span>]</span> +</span> winner</span>(</span>nums</span>,</span> s</span> +</span> 1</span>,</span> e</span>,</span> -</span>turn</span>);</span>
        int</span> b</span> =</span> turn</span> *</span> nums</span>[</span>e</span>]</span> +</span> winner</span>(</span>nums</span>,</span> s</span>,</span> e</span> -</span> 1</span>,</span> -</span>turn</span>);</span>
        return</span> turn</span> *</span> Math</span>.</span>max</span>(</span>turn</span> *</span> a</span>,</span> turn</span> *</span> b</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>2</mn>n</mi></msup>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Size of recursion tree will be <span class="maths katex-rendered">2</mn>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.664392em;"></span><span class="strut bottom" style="height: 0.664392em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-similar-approach-accepted">Approach #2 Similar Approach [Accepted]</h4>
Algorithm</strong></p>
We can omit the use of <span class="maths katex-rendered">t</mi>u</mi>r</mi>n</mi></mrow><annotation encoding="application/x-tex">turn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span></span></span></span></span> to keep a track of the player for the current turn. To do so, we can make use of a simple observation. If the current turn belongs to, say Player 1, we pick up an element, say <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>, from either end, and give the turn to Player 2. Thus, if we obtain the score for the remaining elements(leaving <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>), this score, now belongs to Player 2. Thus, since Player 2 is competing against Player 1, this score should be subtracted from Player 1's current(local) score(<span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span>) to obtain the effective score of Player 1 at the current instant.</p>
Similar argument holds true for Player 2's turn as well i.e. we can subtract Player 1's score for the remaining subarray from Player 2's current score to obtain its effective score. By making use of this observation, we can omit the use of <span class="maths katex-rendered">t</mi>u</mi>r</mi>n</mi></mrow><annotation encoding="application/x-tex">turn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span></span></span></span></span> from winner</code> to find the required result by making the slight change discussed above in the winner</code>'s implementation.</p>
While returning the result from winner</code> for the current function call, we return the larger of the effective scores possible by choosing either the first or the last element from the currently available subarray. Rest of the process remains the same as the last approach.</p>
Now, in order to remove the duplicate function calls, we can make use of a 2-D memoization array, <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span>, such that we can store the result obtained for the function call winner</code> for a subarray with starting and ending indices being <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span></span></span></span></span> ] at <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi>[</mo>s</mi>]</mo>[</mo>e</mi>]</mo></mrow><annotation encoding="application/x-tex">memo[s][e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span>[</span><span class="mord mathit">s</span>]</span>[</span><span class="mord mathit">e</span>]</span></span></span></span></span>. This helps to prune the search space to a great extent.</p>
This approach is inspired by <a href="http://leetcode.com/chidong">@chidong</a></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> PredictTheWinner</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        Integer</span>[][]</span> memo</span> =</span> new</span> Integer</span>[</span>nums</span>.</span>length</span>][</span>nums</span>.</span>length</span>];</span>
        return</span> winner</span>(</span>nums</span>,</span> 0</span>,</span> nums</span>.</span>length</span> -</span> 1</span>,</span> memo</span>)</span> &gt;=</span> 0</span>;</span>
    }</span>
    public</span> int</span> winner</span>(</span>int</span>[]</span> nums</span>,</span> int</span> s</span>,</span> int</span> e</span>,</span> Integer</span>[][]</span> memo</span>)</span> {</span>
        if</span> (</span>s</span> ==</span> e</span>)</span>
            return</span> nums</span>[</span>s</span>];</span>
        if</span> (</span>memo</span>[</span>s</span>][</span>e</span>]</span> !=</span> null</span>)</span>
            return</span> memo</span>[</span>s</span>][</span>e</span>];</span>
        int</span> a</span> =</span> nums</span>[</span>s</span>]</span> -</span> winner</span>(</span>nums</span>,</span> s</span> +</span> 1</span>,</span> e</span>,</span> memo</span>);</span>
        int</span> b</span> =</span> nums</span>[</span>e</span>]</span> -</span> winner</span>(</span>nums</span>,</span> s</span>,</span> e</span> -</span> 1</span>,</span> memo</span>);</span>
        memo</span>[</span>s</span>][</span>e</span>]</span> =</span> Math</span>.</span>max</span>(</span>a</span>,</span> b</span>);</span>
        return</span> memo</span>[</span>s</span>][</span>e</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. The entire <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is filled only once. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the size of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used for memoization.</p>
</li>
</ul>

<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]:</h4>
Algorithm</strong></p>
We can observe that the effective score for the current player for any given subarray <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>x</mi>:</mo>y</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[x:y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">x</span>:</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span></span></span></span></span> only depends on the elements within the range <span class="maths katex-rendered">[</mo>x</mi>,</mo>y</mi>]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">x</span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span></span></span></span></span> in the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>. It mainly depends on whether the element <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>x</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">x</span>]</span></span></span></span></span> or <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>y</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span></span></span></span></span> is chosen in the current turn and also on the maximum score possible for the other player from the remaining subarray left after choosing the current element. Thus, it is certain that the current effective score isn't dependent on the elements outside the range <span class="maths katex-rendered">[</mo>x</mi>,</mo>y</mi>]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">x</span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span></span></span></span></span>. </p>
Based on the above observation, we can say that if know the maximum effective score possible for the subarray <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>x</mi>+</mo>1</mn>,</mo>y</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[x+1,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">x</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>x</mi>,</mo>y</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[x,y-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">x</span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>, we can easily determine the maximum effective score possible for the subarray <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>x</mi>,</mo>y</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">x</span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span></span></span></span></span> as <span class="maths katex-rendered">m</mi>a</mi>x</mi></mtext>(</mo>n</mi>u</mi>m</mi>s</mi>[</mo>x</mi>]</mo>−</mo>s</mi>c</mi>o</mi>r</mi>e</mi>[</mo>x</mi>+</mo>1</mn>,</mo>y</mi>]</mo></mrow></msub>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>y</mi>]</mo>−</mo>s</mi>c</mi>o</mi>r</mi>e</mi>[</mo>x</mi>,</mo>y</mi>−</mo>1</mn>]</mo></mrow></msub>)</mo></mrow><annotation encoding="application/x-tex">text{max}(nums[x]-score_{[x+1,y]}, nums[y]-score_{[x,y-1]})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.1052em; vertical-align: -0.3552em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">max</span></span>(</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">x</span>]</span>−</span><span class="mord mathit">s</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mopen mtight">[</span><span class="mord mathit mtight">x</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span><span class="mclose mtight">]</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.03588em;">y</span>]</span>−</span><span class="mord mathit">s</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="" style="top: 0.1802em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mopen mtight">[</span><span class="mord mathit mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span><span class="mclose mtight">]</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. These equations are deduced based on the last approach. </p>
From this,  we conclude that we can make use of Dynamic Programming to determine the required maximum effective score for the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>. We can make use of a 2-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array, such that <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> is used to store the maximum effective score possible for the subarray <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>,</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. The <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> updation equation becomes: </p>

<span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>,</mo>j</mi>]</mo>=</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>+</mo>1</mn>]</mo>[</mo>j</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i,j] = nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>.</p>
We can fill in the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array starting from the last row. At the end, the value for <span class="maths katex-rendered">d</mi>p</mi>[</mo>0</mn>]</mo>[</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[0][n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathrm">0</span>]</span>[</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> gives the required result. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
Look at the animation below to clearly understand the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> filling process.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 12</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> PredictTheWinner</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span>[][]</span> dp</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span> +</span> 1</span>][</span>nums</span>.</span>length</span>];</span>
        for</span> (</span>int</span> s</span> =</span> nums</span>.</span>length</span>;</span> s</span> &gt;=</span> 0</span>;</span> s</span>--)</span> {</span>
            for</span> (</span>int</span> e</span> =</span> s</span> +</span> 1</span>;</span> e</span> &lt;</span> nums</span>.</span>length</span>;</span> e</span>++)</span> {</span>
                int</span> a</span> =</span> nums</span>[</span>s</span>]</span> -</span> dp</span>[</span>s</span> +</span> 1</span>][</span>e</span>];</span>
                int</span> b</span> =</span> nums</span>[</span>e</span>]</span> -</span> dp</span>[</span>s</span>][</span>e</span> -</span> 1</span>];</span>
                dp</span>[</span>s</span>][</span>e</span>]</span> =</span> Math</span>.</span>max</span>(</span>a</span>,</span> b</span>);</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>0</span>][</span>nums</span>.</span>length</span> -</span> 1</span>]</span> &gt;=</span> 0</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. <span class="maths katex-rendered">(</mo>(</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">((n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span>(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span>x<span class="maths katex-rendered">n</mi>)</mo>/</mi>2</mn></mrow><annotation encoding="application/x-tex">n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></span> entries in <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">(</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is filled once. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">(</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span>x<span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-4-1-d-dynamic-programming-accepted">Approach #4 1-D Dynamic Programming [Accepted]:</h4>
Algorithm</strong></p>
From the last approach, we see that the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> updation equation is: </p>

<span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>,</mo>j</mi>]</mo>=</mo>n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>+</mo>1</mn>]</mo>[</mo>j</mi>]</mo>,</mo>n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo>−</mo>d</mi>p</mi>[</mo>i</mi>]</mo>[</mo>j</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i,j] = nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>,</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>,</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. </p>
Thus, for filling in any entry in <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array, only the entries in the next row(same column) and the previous column(same row) are needed.</p>
Instead of making use of a new row in <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array for the current <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> row's updations, we can overwrite the values in the previous row itself and consider the values as belonging to the new row's entries, since the older values won't be needed ever in the future again. Thus, instead of making use of a 2-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array, we can make use of a 1-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array and make the updations appropriately.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> boolean</span> PredictTheWinner</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span>[]</span> dp</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span>];</span>
        for</span> (</span>int</span> s</span> =</span> nums</span>.</span>length</span>;</span> s</span> &gt;=</span> 0</span>;</span> s</span>--)</span> {</span>
            for</span> (</span>int</span> e</span> =</span> s</span> +</span> 1</span>;</span> e</span> &lt;</span> nums</span>.</span>length</span>;</span> e</span>++)</span> {</span>
                int</span> a</span> =</span> nums</span>[</span>s</span>]</span> -</span> dp</span>[</span>e</span>];</span>
                int</span> b</span> =</span> nums</span>[</span>e</span>]</span> -</span> dp</span>[</span>e</span> -</span> 1</span>];</span>
                dp</span>[</span>e</span>]</span> =</span> Math</span>.</span>max</span>(</span>a</span>,</span> b</span>);</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>nums</span>.</span>length</span> -</span> 1</span>]</span> &gt;=</span> 0</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. The elements of <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array are updated <span class="maths katex-rendered">1</mn>+</mo>2</mn>+</mo>3</mn>+</mo>.</mi>.</mi>.</mi>+</mo>n</mi></mrow><annotation encoding="application/x-tex">1+2+3+...+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span>+</span><span class="mord mathrm">2</span>+</span><span class="mord mathrm">3</span>+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>+</span><span class="mord mathit">n</span></span></span></span></span> times. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. 1-D <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>