<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-using-extra-array-accepted">Approach #2 Using Extra Array [Accepted]</a></li>
<a href="#approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
The brute force approach is really simple. We consider every possible subarray within the given array and count the number of zeros and ones in each subarray. Then, we find out the maximum size subarray with equal no. of zeros and ones out of them.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>

    public</span> int</span> findMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> maxlen</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> start</span> =</span> 0</span>;</span> start</span> &lt;</span> nums</span>.</span>length</span>;</span> start</span>++)</span> {</span>
            int</span> zeroes</span> =</span> 0</span>,</span> ones</span> =</span> 0</span>;</span>
            for</span> (</span>int</span> end</span> =</span> start</span>;</span> end</span> &lt;</span> nums</span>.</span>length</span>;</span> end</span>++)</span> {</span>
                if</span> (</span>nums</span>[</span>end</span>]</span> ==</span> 0</span>)</span> {</span>
                    zeroes</span>++;</span>
                }</span> else</span> {</span>
                    ones</span>++;</span>
                }</span>
                if</span> (</span>zeroes</span> ==</span> ones</span>)</span> {</span>
                    maxlen</span> =</span> Math</span>.</span>max</span>(</span>maxlen</span>,</span> end</span> -</span> start</span> +</span> 1</span>);</span>
                }</span>
            }</span>
        }</span>
        return</span> maxlen</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. We consider every possible subarray by traversing over the complete array for every start point possible.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Only two variables <span class="maths katex-rendered">z</mi>e</mi>r</mi>o</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">zeroes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.04398em;">z</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">o</mi>n</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">ones</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> are required.</p>
</li>
</ul>

<h4 id="approach-2-using-extra-array-accepted">Approach #2 Using Extra Array [Accepted]</h4>
Algorithm</strong></p>
In this approach, we make use of a <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> variable, which is used to store the relative number of ones and zeros encountered so far while traversing the array. The <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> variable is incremented by one for every <span class="maths katex-rendered">1</mn></mtext></mrow><annotation encoding="application/x-tex">text{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></span></span> encountered and the same is decremented by one for every <span class="maths katex-rendered">0</mn></mtext></mrow><annotation encoding="application/x-tex">text{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></span></span> encountered.</p>
We start traversing the array from the beginning. If at any moment, the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> becomes zero, it implies that we've encountered equal number of zeros and ones from the beginning till the current index of the array(<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>). Not only this, another point to be noted is that  if we encounter the same <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> twice while traversing the array, it means that the number of zeros and ones are equal between the indices corresponding to the equal <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> values. The following figure illustrates the observation for the sequence [0 0 1 0 0 0 1 1]</code>:</p>
<img alt="Contiguous_Array" src="../Figures/535_Contiguous_Array.PNG"></p>
In the above figure, the subarrays between (A,B), (B,C) and (A,C) (lying between indices corresponing to <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi>=</mo>2</mn></mrow><annotation encoding="application/x-tex">count = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>=</span><span class="mord mathrm">2</span></span></span></span></span>) have equal number of zeros and ones.</p>
Another point to be noted is that the largest subarray is the one between the points (A, C). Thus, if we keep a track of the indices corresponding to the same <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> values that lie farthest apart, we can determine the size of the largest subarray with equal no. of zeros and ones easily.</p>
Now, the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> values can range between <span class="maths katex-rendered">-</mi>n</mi></mtext></mrow><annotation encoding="application/x-tex">text{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">-n</span></span></span></span></span></span> to <span class="maths katex-rendered">+</mi>n</mi></mtext></mrow><annotation encoding="application/x-tex">text{+n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.58333em;"></span><span class="strut bottom" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">+n</span></span></span></span></span></span>, with the extreme points corresponding to the complete array being filled with all 0's and all 1's respectively. Thus, we make use of an array <span class="maths katex-rendered">a</mi>r</mi>r</mi></mrow><annotation encoding="application/x-tex">arr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span>(of size <span class="maths katex-rendered">2</mn>n</mi>+</mi>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{2n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">2n+1</span></span></span></span></span></span>to keep a track of the various <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span>'s encountered so far. We make an entry containing the current element's index (<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>) in the <span class="maths katex-rendered">a</mi>r</mi>r</mi></mrow><annotation encoding="application/x-tex">arr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> for a new <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> encountered everytime. Whenever, we come across the same <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> value later while traversing the array, we determine the length of the subarray lying between the indices corresponding to the same <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> values.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>

    public</span> int</span> findMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span>[]</span> arr</span> =</span> new</span> int</span>[</span>2</span> *</span> nums</span>.</span>length</span> +</span> 1</span>];</span>
        Arrays</span>.</span>fill</span>(</span>arr</span>,</span> -</span>2</span>);</span>
        arr</span>[</span>nums</span>.</span>length</span>]</span> =</span> -</span>1</span>;</span>
        int</span> maxlen</span> =</span> 0</span>,</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            count</span> =</span> count</span> +</span> (</span>nums</span>[</span>i</span>]</span> ==</span> 0</span> ?</span> -</span>1</span> :</span> 1</span>);</span>
            if</span> (</span>arr</span>[</span>count</span> +</span> nums</span>.</span>length</span>]</span> &gt;=</span> -</span>1</span>)</span> {</span>
                maxlen</span> =</span> Math</span>.</span>max</span>(</span>maxlen</span>,</span> i</span> -</span> arr</span>[</span>count</span> +</span> nums</span>.</span>length</span>]);</span>
            }</span> else</span> {</span>
                arr</span>[</span>count</span> +</span> nums</span>.</span>length</span>]</span> =</span> i</span>;</span>
            }</span>

        }</span>
        return</span> maxlen</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The complete array is traversed only once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">a</mi>r</mi>r</mi></mrow><annotation encoding="application/x-tex">arr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span> array of size <span class="maths katex-rendered">2</mn>n</mi>+</mi>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{2n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">2n+1</span></span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</h4>
Algorithm</strong></p>
This approach relies on the same premise as the previous approach. But, we need not use an array of size <span class="maths katex-rendered">2</mn>n</mi>+</mi>1</mn></mtext></mrow><annotation encoding="application/x-tex">text{2n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">2n+1</span></span></span></span></span></span>, since it isn't necessary that we'll encounter all the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> values possible. Thus, we make use of a HashMap <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> to store the entries in the form of <span class="maths katex-rendered">(</mo>i</mi>n</mi>d</mi>e</mi>x</mi>,</mo>c</mi>o</mi>u</mi>n</mi>t</mi>)</mo></mrow><annotation encoding="application/x-tex">(index, count)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">x</span>,</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span>)</span></span></span></span></span>. We make an entry for a <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> in the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> whenever the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> is encountered first, and later on use the correspoding index to find the length of the largest subarray with equal no. of zeros and ones when the same <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> is encountered again.</p>
The following animation depicts the process:
<!--<img alt="Contiguous_Array" src="../Figures/525_Contiguous_Array.gif" />-->
!?!../Documents/525_Contiguous_Array.json:1000,563!?!</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>

    public</span> int</span> findMaxLength</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        Map</span>&lt;</span>Integer</span>,</span> Integer</span>&gt;</span> map</span> =</span> new</span> HashMap</span>&lt;&gt;();</span>
        map</span>.</span>put</span>(</span>0</span>,</span> -</span>1</span>);</span>
        int</span> maxlen</span> =</span> 0</span>,</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            count</span> =</span> count</span> +</span> (</span>nums</span>[</span>i</span>]</span> ==</span> 1</span> ?</span> 1</span> :</span> -</span>1</span>);</span>
            if</span> (</span>map</span>.</span>containsKey</span>(</span>count</span>))</span> {</span>
                maxlen</span> =</span> Math</span>.</span>max</span>(</span>maxlen</span>,</span> i</span> -</span> map</span>.</span>get</span>(</span>count</span>));</span>
            }</span> else</span> {</span>
                map</span>.</span>put</span>(</span>count</span>,</span> i</span>);</span>
            }</span>
        }</span>
        return</span> maxlen</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The entire array is traversed only once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Maximum size of the HashMap <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> will be <span class="maths katex-rendered">n</mi></mtext></mrow><annotation encoding="application/x-tex">text{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">n</span></span></span></span></span></span>, if all the elements are either 1 or 0.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>