<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>
<a href="#approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>
Intuition</strong></p>
If there were no Kleene stars (the *</code> wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.</p>
When a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.</p>
Algorithm</strong></p>
Without a Kleene star, our solution would look like this:</p>
Python</strong></p>
</span>def</span> match</span>(</span>text</span>,</span> pattern</span>):</span>
    if</span> not</span> pattern</span>:</span> return</span> not</span> text</span>
    first_match</span> =</span> bool</span>(</span>text</span>)</span> and</span> pattern</span>[</span>0</span>]</span> in</span> {</span>text</span>[</span>0</span>],</span> '.'</span>}</span>
    return</span> first_match</span> and</span> match</span>(</span>text</span>[</span>1</span>:],</span> pattern</span>[</span>1</span>:])</span>
</pre></div>


If a star is present in the pattern, it will be in the second position <span class="maths katex-rendered">p</mi>a</mi>t</mi>t</mi>e</mi>r</mi>n</mi>[</mi>1</mn>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{pattern[1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">pattern[1]</span></span></span></span></span></span>.  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.</p>
Python</strong></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> isMatch</span>(</span>self</span>,</span> text</span>,</span> pattern</span>):</span>
        if</span> not</span> pattern</span>:</span>
            return</span> not</span> text</span>

        first_match</span> =</span> bool</span>(</span>text</span>)</span> and</span> pattern</span>[</span>0</span>]</span> in</span> {</span>text</span>[</span>0</span>],</span> '.'</span>}</span>

        if</span> len</span>(</span>pattern</span>)</span> &gt;=</span> 2</span> and</span> pattern</span>[</span>1</span>]</span> ==</span> '*'</span>:</span>
            return</span> (</span>self</span>.</span>isMatch</span>(</span>text</span>,</span> pattern</span>[</span>2</span>:])</span> or</span>
                    first_match</span> and</span> self</span>.</span>isMatch</span>(</span>text</span>[</span>1</span>:],</span> pattern</span>))</span>
        else</span>:</span>
            return</span> first_match</span> and</span> self</span>.</span>isMatch</span>(</span>text</span>[</span>1</span>:],</span> pattern</span>[</span>1</span>:])</span>
</pre></div>


Java</strong></p>
</span>class</span> Solution</span> {</span>
    public</span> boolean</span> isMatch</span>(</span>String</span> text</span>,</span> String</span> pattern</span>)</span> {</span>
        if</span> (</span>pattern</span>.</span>isEmpty</span>())</span> return</span> text</span>.</span>isEmpty</span>();</span>
        boolean</span> first_match</span> =</span> (!</span>text</span>.</span>isEmpty</span>()</span> &amp;&amp;</span> 
                               (</span>pattern</span>.</span>charAt</span>(</span>0</span>)</span> ==</span> text</span>.</span>charAt</span>(</span>0</span>)</span> ||</span> pattern</span>.</span>charAt</span>(</span>0</span>)</span> ==</span> '.'</span>));</span>

        if</span> (</span>pattern</span>.</span>length</span>()</span> &gt;=</span> 2</span> &amp;&amp;</span> pattern</span>.</span>charAt</span>(</span>1</span>)</span> ==</span> '*'</span>){</span>
            return</span> (</span>isMatch</span>(</span>text</span>,</span> pattern</span>.</span>substring</span>(</span>2</span>))</span> ||</span> 
                    (</span>first_match</span> &amp;&amp;</span> isMatch</span>(</span>text</span>.</span>substring</span>(</span>1</span>),</span> pattern</span>)));</span>
        }</span> else</span> {</span>
            return</span> first_match</span> &amp;&amp;</span> isMatch</span>(</span>text</span>.</span>substring</span>(</span>1</span>),</span> pattern</span>.</span>substring</span>(</span>1</span>));</span>
        }</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Let <span class="maths katex-rendered">T</mi>,</mo>P</mi></mrow><annotation encoding="application/x-tex">T, P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span>,</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> be the lengths of the text and the pattern respectively.  In the worst case, a call to match(text[i:], pattern[2j:])</code> will be made <span class="maths katex-rendered">(</mo>i</mi>+</mo>j</mi></mrow>i</mi></mrow></mfrac>)</mo></mrow></mrow><annotation encoding="application/x-tex">binom{i+j}{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.905664em;"></span><span class="strut bottom" style="height: 1.25567em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size1">(</span></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="" style="top: -0.444em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span> times, and strings of the order <span class="maths katex-rendered">O</mi>(</mo>T</mi>−</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">O(T - i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>−</span><span class="mord mathit">i</span>)</span></span></span></span></span> and <span class="maths katex-rendered">O</mi>(</mo>P</mi>−</mo>2</mn>∗</mo>j</mi>)</mo></mrow><annotation encoding="application/x-tex">O(P - 2*j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>−</span><span class="mord mathrm">2</span>∗</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span> will be made.  Thus, the complexity has the order <span class="maths katex-rendered">∑</mo>i</mi>=</mo>0</mn></mrow>T</mi></msubsup>∑</mo>j</mi>=</mo>0</mn></mrow>P</mi>/</mi>2</mn></mrow></msubsup>(</mo>i</mi>+</mo>j</mi></mrow>i</mi></mrow></mfrac>)</mo></mrow>O</mi>(</mo>T</mi>+</mo>P</mi>−</mo>i</mi>−</mo>2</mn>j</mi>)</mo></mrow><annotation encoding="application/x-tex">sum_{i = 0}^T sum_{j = 0}^{P/2} binom{i+j}{i} O(T+P-i-2j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.0448em;"></span><span class="strut bottom" style="height: 1.45777em; vertical-align: -0.412972em;"></span><span class="base textstyle uncramped"><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.30001em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -0.364em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.13889em;">T</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mop op-symbol small-op" style="top: -5e-06em;">∑</span><span class="" style="top: 0.276864em; margin-left: 0em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span></span></span></span><span class="" style="top: -0.5198em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.13889em;">P</span><span class="mord mathrm mtight">/</span><span class="mord mathrm mtight">2</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size1">(</span></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="" style="top: -0.444em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose style-wrap reset-textstyle textstyle uncramped" style="top: 0em;"><span class="delimsizing size1">)</span></span></span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>+</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>−</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>)</span></span></span></span></span>.  With some effort outside the scope of this article, we can show this is bounded by <span class="maths katex-rendered">O</mi>(</mo>(</mo>T</mi>+</mo>P</mi>)</mo>2</mn>[</mo></msup>T</mi>+</mo>P</mi></mrow>2</mn></mrow></mfrac>]</mo>)</mo></mrow><annotation encoding="application/x-tex">Obig((T+P)2^[T + frac{P}{2}]big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.888em;"></span><span class="strut bottom" style="height: 1.23801em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>+</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>)</span><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mopen mtight">[</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>+</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.13889em;">P</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>]</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span>.</p>
</li>

Space Complexity:  For every call to match</code>, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of <span class="maths katex-rendered">O</mi>(</mo>(</mo>T</mi>+</mo>P</mi>)</mo>2</mn>T</mi>+</mo>P</mi></mrow>2</mn></mrow></mfrac></mrow></msup>)</mo></mrow><annotation encoding="application/x-tex">Obig((T+P)2^{T + frac{P}{2}}big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.973465em;"></span><span class="strut bottom" style="height: 1.32347em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span>+</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>)</span><span class="mord mathrm">2</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.13889em;">T</span><span class="mbin mtight">+</span><span class="mord reset-scriptstyle scriptstyle uncramped mtight"><span class="mopen sizing reset-size5 size5 reset-scriptstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.344em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord scriptscriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.221429em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-scriptstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.384em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle uncramped mtight"><span class="mord scriptscriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.13889em;">P</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-scriptstyle textstyle uncramped nulldelimiter"></span></span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span> space, even though there are only order <span class="maths katex-rendered">O</mi>(</mo>T</mi>2</mn></msup>+</mo>P</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(T^2 + P^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>+</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> unique suffixes of <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> and  <span class="maths katex-rendered">T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span></span></span></span></span> that are actually required.</p>
</li>
</ul>

<h4 id="approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</h4>
Intuition</strong></p>
As the problem has an optimal substructure</strong>, it is natural to cache intermediate results.  We ask the question <span class="maths katex-rendered">d</mi>p</mi>(</mi>i</mi>,</mi>&nbsp;</mtext>j</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{dp(i, j)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">dp(i,&nbsp;j)</span></span></span></span></span></span>: does <span class="maths katex-rendered">t</mi>e</mi>x</mi>t</mi>[</mi>i</mi>:</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{text[i:]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">text[i:]</span></span></span></span></span></span> and <span class="maths katex-rendered">p</mi>a</mi>t</mi>t</mi>e</mi>r</mi>n</mi>[</mi>j</mi>:</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{pattern[j:]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">pattern[j:]</span></span></span></span></span></span> match?  We can describe our answer in terms of answers to questions involving smaller strings.</p>
Algorithm</strong></p>
We proceed with the same recursion as in Approach #1, except because calls will only ever be made to match(text[i:], pattern[j:])</code>, we use <span class="maths katex-rendered">d</mi>p</mi>(</mi>i</mi>,</mi>&nbsp;</mtext>j</mi>)</mi></mtext></mrow><annotation encoding="application/x-tex">text{dp(i, j)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">dp(i,&nbsp;j)</span></span></span></span></span></span> to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.</p>
Python</strong></p>
Top-Down Variation</em></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> isMatch</span>(</span>self</span>,</span> text</span>,</span> pattern</span>):</span>
        memo</span> =</span> {}</span>
        def</span> dp</span>(</span>i</span>,</span> j</span>):</span>
            if</span> (</span>i</span>,</span> j</span>)</span> not</span> in</span> memo</span>:</span>
                if</span> j</span> ==</span> len</span>(</span>pattern</span>):</span>
                    ans</span> =</span> i</span> ==</span> len</span>(</span>text</span>)</span>
                else</span>:</span>
                    first_match</span> =</span> i</span> &lt;</span> len</span>(</span>text</span>)</span> and</span> pattern</span>[</span>j</span>]</span> in</span> {</span>text</span>[</span>i</span>],</span> '.'</span>}</span>
                    if</span> j</span>+</span>1</span> &lt;</span> len</span>(</span>pattern</span>)</span> and</span> pattern</span>[</span>j</span>+</span>1</span>]</span> ==</span> '*'</span>:</span>
                        ans</span> =</span> dp</span>(</span>i</span>,</span> j</span>+</span>2</span>)</span> or</span> first_match</span> and</span> dp</span>(</span>i</span>+</span>1</span>,</span> j</span>)</span>
                    else</span>:</span>
                        ans</span> =</span> first_match</span> and</span> dp</span>(</span>i</span>+</span>1</span>,</span> j</span>+</span>1</span>)</span>

                memo</span>[</span>i</span>,</span> j</span>]</span> =</span> ans</span>
            return</span> memo</span>[</span>i</span>,</span> j</span>]</span>

        return</span> dp</span>(</span>0</span>,</span> 0</span>)</span>
</pre></div>


Bottom-Up Variation</em></p>
</span>class</span> Solution</span>(</span>object</span>):</span>
    def</span> isMatch</span>(</span>self</span>,</span> text</span>,</span> pattern</span>):</span>
        dp</span> =</span> [[</span>False</span>]</span> *</span> (</span>len</span>(</span>pattern</span>)</span> +</span> 1</span>)</span> for</span> _</span> in</span> range</span>(</span>len</span>(</span>text</span>)</span> +</span> 1</span>)]</span>

        dp</span>[</span>-</span>1</span>][</span>-</span>1</span>]</span> =</span> True</span>
        for</span> i</span> in</span> range</span>(</span>len</span>(</span>text</span>),</span> -</span>1</span>,</span> -</span>1</span>):</span>
            for</span> j</span> in</span> range</span>(</span>len</span>(</span>pattern</span>)</span> -</span> 1</span>,</span> -</span>1</span>,</span> -</span>1</span>):</span>
                first_match</span> =</span> i</span> &lt;</span> len</span>(</span>text</span>)</span> and</span> pattern</span>[</span>j</span>]</span> in</span> {</span>text</span>[</span>i</span>],</span> '.'</span>}</span>
                if</span> j</span>+</span>1</span> &lt;</span> len</span>(</span>pattern</span>)</span> and</span> pattern</span>[</span>j</span>+</span>1</span>]</span> ==</span> '*'</span>:</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> dp</span>[</span>i</span>][</span>j</span>+</span>2</span>]</span> or</span> first_match</span> and</span> dp</span>[</span>i</span>+</span>1</span>][</span>j</span>]</span>
                else</span>:</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> first_match</span> and</span> dp</span>[</span>i</span>+</span>1</span>][</span>j</span>+</span>1</span>]</span>

        return</span> dp</span>[</span>0</span>][</span>0</span>]</span>
</pre></div>


Java</strong></p>
Top-Down Variation</em></p>
</span>enum</span> Result</span> {</span>
    TRUE</span>,</span> FALSE</span>
}</span>

class</span> Solution</span> {</span>
    Result</span>[][]</span> memo</span>;</span>

    public</span> boolean</span> isMatch</span>(</span>String</span> text</span>,</span> String</span> pattern</span>)</span> {</span>
        memo</span> =</span> new</span> Result</span>[</span>text</span>.</span>length</span>()</span> +</span> 1</span>][</span>pattern</span>.</span>length</span>()</span> +</span> 1</span>];</span>
        return</span> dp</span>(</span>0</span>,</span> 0</span>,</span> text</span>,</span> pattern</span>);</span>
    }</span>

    public</span> boolean</span> dp</span>(</span>int</span> i</span>,</span> int</span> j</span>,</span> String</span> text</span>,</span> String</span> pattern</span>)</span> {</span>
        if</span> (</span>memo</span>[</span>i</span>][</span>j</span>]</span> !=</span> null</span>)</span> {</span>
            return</span> memo</span>[</span>i</span>][</span>j</span>]</span> ==</span> Result</span>.</span>TRUE</span>;</span>
        }</span>
        boolean</span> ans</span>;</span>
        if</span> (</span>j</span> ==</span> pattern</span>.</span>length</span>()){</span>
            ans</span> =</span> i</span> ==</span> text</span>.</span>length</span>();</span>
        }</span> else</span>{</span>
            boolean</span> first_match</span> =</span> (</span>i</span> &lt;</span> text</span>.</span>length</span>()</span> &amp;&amp;</span> 
                                   (</span>pattern</span>.</span>charAt</span>(</span>j</span>)</span> ==</span> text</span>.</span>charAt</span>(</span>i</span>)</span> ||</span>
                                    pattern</span>.</span>charAt</span>(</span>j</span>)</span> ==</span> '.'</span>));</span>

            if</span> (</span>j</span> +</span> 1</span> &lt;</span> pattern</span>.</span>length</span>()</span> &amp;&amp;</span> pattern</span>.</span>charAt</span>(</span>j</span>+</span>1</span>)</span> ==</span> '*'</span>){</span>
                ans</span> =</span> (</span>dp</span>(</span>i</span>,</span> j</span>+</span>2</span>,</span> text</span>,</span> pattern</span>)</span> ||</span> 
                       first_match</span> &amp;&amp;</span> dp</span>(</span>i</span>+</span>1</span>,</span> j</span>,</span> text</span>,</span> pattern</span>));</span>
            }</span> else</span> {</span>
                ans</span> =</span> first_match</span> &amp;&amp;</span> dp</span>(</span>i</span>+</span>1</span>,</span> j</span>+</span>1</span>,</span> text</span>,</span> pattern</span>);</span>
            }</span>
        }</span>
        memo</span>[</span>i</span>][</span>j</span>]</span> =</span> ans</span> ?</span> Result</span>.</span>TRUE</span> :</span> Result</span>.</span>FALSE</span>;</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Bottom-Up Variation</em></p>
</span>class</span> Solution</span> {</span>
    public</span> boolean</span> isMatch</span>(</span>String</span> text</span>,</span> String</span> pattern</span>)</span> {</span>
        boolean</span>[][]</span> dp</span> =</span> new</span> boolean</span>[</span>text</span>.</span>length</span>()</span> +</span> 1</span>][</span>pattern</span>.</span>length</span>()</span> +</span> 1</span>];</span>
        dp</span>[</span>text</span>.</span>length</span>()][</span>pattern</span>.</span>length</span>()]</span> =</span> true</span>;</span>

        for</span> (</span>int</span> i</span> =</span> text</span>.</span>length</span>();</span> i</span> &gt;=</span> 0</span>;</span> i</span>--){</span>
            for</span> (</span>int</span> j</span> =</span> pattern</span>.</span>length</span>()</span> -</span> 1</span>;</span> j</span> &gt;=</span> 0</span>;</span> j</span>--){</span>
                boolean</span> first_match</span> =</span> (</span>i</span> &lt;</span> text</span>.</span>length</span>()</span> &amp;&amp;</span> 
                                       (</span>pattern</span>.</span>charAt</span>(</span>j</span>)</span> ==</span> text</span>.</span>charAt</span>(</span>i</span>)</span> ||</span>
                                        pattern</span>.</span>charAt</span>(</span>j</span>)</span> ==</span> '.'</span>));</span>
                if</span> (</span>j</span> +</span> 1</span> &lt;</span> pattern</span>.</span>length</span>()</span> &amp;&amp;</span> pattern</span>.</span>charAt</span>(</span>j</span>+</span>1</span>)</span> ==</span> '*'</span>){</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> dp</span>[</span>i</span>][</span>j</span>+</span>2</span>]</span> ||</span> first_match</span> &amp;&amp;</span> dp</span>[</span>i</span>+</span>1</span>][</span>j</span>];</span>
                }</span> else</span> {</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> first_match</span> &amp;&amp;</span> dp</span>[</span>i</span>+</span>1</span>][</span>j</span>+</span>1</span>];</span>
                }</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>0</span>][</span>0</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Let <span class="maths katex-rendered">T</mi>,</mo>P</mi></mrow><annotation encoding="application/x-tex">T, P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">T</span>,</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> be the lengths of the text and the pattern respectively.  The work for every call to dp(i, j)</code> for <span class="maths katex-rendered">i</mi>=</mo>0</mn>,</mo>.</mi>.</mi>.</mi>,</mo>T</mi></mrow><annotation encoding="application/x-tex">i=0, ... ,T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>=</span><span class="mord mathrm">0</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>,</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span></span></span></span></span>; <span class="maths katex-rendered">j</mi>=</mo>0</mn>,</mo>.</mi>.</mi>.</mi>,</mo>P</mi></mrow><annotation encoding="application/x-tex">j=0, ... ,P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>=</span><span class="mord mathrm">0</span>,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span>,</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> is done once, and it is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> work.  Hence, the time complexity is <span class="maths katex-rendered">O</mi>(</mo>T</mi>P</mi>)</mo></mrow><annotation encoding="application/x-tex">O(TP)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>)</span></span></span></span></span>.</p>
</li>

Space Complexity:  The only memory we use is the <span class="maths katex-rendered">O</mi>(</mo>T</mi>P</mi>)</mo></mrow><annotation encoding="application/x-tex">O(TP)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>)</span></span></span></span></span> boolean entries in our cache.  Hence, the space complexity is <span class="maths katex-rendered">O</mi>(</mo>T</mi>P</mi>)</mo></mrow><annotation encoding="application/x-tex">O(TP)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>)</span></span></span></span></span>.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>