Solution
Approach #1 Brute Force [Time Limit Exceeded]
In the brute force approach we will generate all the possible
2^n
2
n
subsequences of both the strings and store their number of occurences in a hashmap. Longest subsequence whose frequency is equal to
1
1 will be the required subsequence. And, if it is not found we will return
-1
−1.
Java
public class Solution {
    public int findLUSlength(String a, String b) {
        HashMap < String, Integer > map = new HashMap < > ();
        for (String s: new String[] {a, b}) {
            for (int i = 0; i < (1 << s.length()); i++) {
                String t = "";
                for (int j = 0; j < s.length(); j++) {
                    if (((i >> j) & 1) != 0)
                        t += s.charAt(j);
                }
                if (map.containsKey(t))
                    map.put(t, map.get(t) + 1);
                else
                    map.put(t, 1);
            }
        }
        int res = -1;
        for (String s: map.keySet()) {
            if (map.get(s) == 1)
                res = Math.max(res, s.length());
        }
        return res;
    }
}
Complexity Analysis
Time complexity :
O(2^x+2^y)
O(2
x
+2
y
). where
x
x and
y
y are the lengths of strings
a
a and
b
b respectively . Number of subsequences will be
2^x+2^y
2
x
+2
y
.
Space complexity :
O(2^x+2^y)
O(2
x
+2
y
).
2^x+2^y
2
x
+2
y
subsequences will be generated.
Approach #2 Simple Solution[Accepted]
Algorithm
Simple analysis of this problem can lead to an easy solution.
These three cases are possible with string
a
a and
b
b:-
a=b
a=b. If both the strings are identical, it is obvious that no subsequence will be uncommon. Hence, return -1.
length(a)=length(b)
length(a)=length(b) and
a \ne b
a≠b. Example:
abc
abc and
abd
abd. In this case we can consider any string i.e.
abc
abc or
abd
abd as a required subsequence, as out of these two strings one string will never be a subsequence of other string. Hence, return
length(a)
length(a) or
length(b)
length(b).
length(a) \ne length(b)
length(a)≠length(b). Example
abcd
abcd and
abc
abc. In this case we can consider bigger string as a required subsequence because bigger string can't be a subsequence of smaller string. Hence, return
max(length(a),length(b))
max(length(a),length(b)).
Java
public class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b))
            return -1;
        return Math.max(a.length(), b.length());
    }
}
Complexity Analysis
Time complexity :
O(min(x,y))
O(min(x,y)). where
x
x and
y
y are the lengths of strings
a
a and
b
b respectively. Here equals method will take
min(x,y)
min(x,y) time .
Space complexity :
O(1)
O(1). No extra space required.
Analysis written by: @vinod23