<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-recursion-with-memoization-stack-overflow">Approach #1 Using Recursion with memoization [Stack Overflow]</a></li>
<a href="#approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</a></li>
<a href="#approach-3-constant-space-dynamic-programming-accepted">Approach #3 Constant Space Dynamic Programming [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-recursion-with-memoization-stack-overflow">Approach #1 Using Recursion with memoization [Stack Overflow]</h4>
Algorithm</strong></p>
In order to find the solution to the given problem, we need to consider every case possible(for the arrangement of the input digits/characters)
 and what value needs to be considered for each case. Let's look at each of the possibilites one by one.</p>
Firstly, let's assume, we have a function ways(s,i)</code> which returns the number of ways to decode the input string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, if only the characters upto the 
<span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index in this string are considered. We start off by calling the function ways(s, s.length()-1)</code> i.e. by considering the full length of this string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>.</p>
We started by using the last index of the string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>. Suppose, currently, we called the function as ways(s,i)</code>. Let's look at how we proceed. At every step, we need 
to look at the current character at the last index (<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>) and we need to determine the number of ways of decoding that using this <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character could 
add to the total value. There are the following possiblities for the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character.</p>
The <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character could be  a *</code>. In this case, firstly, we can see that this *</code> could be decoded into any of the digits from 1-9</code>. Thus, for every decoding possible 
upto the index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span>, this *</code> could be replaced by any of these digits(1-9</code>). Thus, the total number of decodings is 9 times the number of decodings possible 
for the same string upto the index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span>. Thus, this *</code> initially adds a factor of 9*ways(s,i-1)</code> to the total value. </p>
<img alt="Decode_Ways" src="../Figures/639/639_Decode_Ways2.png"></p>
Apart from this, this *</code> at the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index could also contribute further to the total number of ways depending upon the character/digit at its preceding
 index. If the preceding character happens to be a 1</code>, by combining this 1</code> with the current *</code>, we could obtain any of the digits from 11-19</code> which could be decoded
 into any of the characters from K-S</code>. We need to note that these decodings are in addition to the ones already obtained above by considering only a single current 
 *</code>(1-9</code> decoding to A-J</code>). Thus, this 1*</code> pair could be replaced by any of the numbers from 11-19</code> irrespective of the decodings done for the previous 
 indices(before <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span>). Thus, this 1*</code> pair leads to 8 times the number of decodings possible with the string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> upto the index <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span>. Thus, this adds
 a factor of 9 * ways(s, i - 2)</code> to the total number of decodings. </p>
Similarly, a 2*</code> pair obtained by a 2</code> at the index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span> could be considered of the numbers from 21-26</code>(decoding into U-Z</code>), adding a total of 6 times the 
 number of decodings possible upto the index <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span>. </p>
<img alt="Decode_Ways" src="../Figures/639/639_Decode_Ways3.PNG"></p>
On the same basis, if the character at the index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span> happens to be another *</code>, this **</code> pairing could be considered as 
 any of the numbers from 11-19</code>(9) and 21-26</code>(6). Thus, the total number of decodings will be 15(9+6) times  the number of decodings possible upto the index <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
Now, if the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character could be a digit from 1-9</code> as well. In this case, the number of decodings that considering this single digit can 
 contribute to the total number is equal to the number of decodings that can be contributed by the digits upto the index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span>. But, if the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> character is
 a 0</code>, this 0</code> alone can't contribute anything to the total number of decodings(but it can only contribute if the digit preceding it is a 1</code> or 2</code>. We'll consider this case below).</p>
Apart from the value obtained(just above) for the digit at the <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index being anyone from 0-9</code>, this digit could also pair with the digit at the 
 preceding index, contributing a value dependent on the previous digit. If the previous digit happens to be a 1</code>, this 1</code> can combine with any of the current 
digits forming a valid number in the range 10-19</code>. Thus, in this case, we can consider a pair formed by the current and the preceding digit, and, the number of 
decodings possible by considering the decoded character to be a one formed using this pair, is equal to the total number of decodings possible by using the digits 
upto the index <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span> only. </p>
But, if the previous digit is a 2</code>, a valid number for decoding could only be a one from the range 20-26</code>. Thus, if the current digit is lesser than 7, again
this pairing could add decodings with count equal to the ones possible by using the digits upto the <span class="maths katex-rendered">(</mo>i</mi>−</mo>2</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(i-2)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index only.</p>
Further, if the previous digit happens to be a *</code>, the additional number of decodings depend on the current digit again i.e. If the current digit is greater than 
6</code>, this *</code> could lead to pairings only in the range 17-19</code>(*</code> can't be replaced by 2</code> leading to 27-29</code>). Thus, additional decodings with count equal to the
decodings possible upto the index <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span>. </p>
On the other hand, if the current digit is lesser than 7, this *</code> could be replaced by either a 1</code> or a 2</code> leading to the 
decodings 10-16</code> and 20-26</code> respectively. Thus, the total number of decodings possible by considering this pair is equal to twice the number of decodings possible upto the 
index <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span>(since *</code> can now be replaced by two values).</p>
This way, by considering every possible case, we can obtain the required number of decodings by making use of the recursive function ways</code> as and where necessary.</p>
By making use of memoization, we can reduce the time complexity owing to duplicate function calls.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> M</span> =</span> 1000000007</span>;</span>
    public</span> int</span> numDecodings</span>(</span>String</span> s</span>)</span> {</span>
        Integer</span>[]</span> memo</span>=</span>new</span> Integer</span>[</span>s</span>.</span>length</span>()];</span>
        return</span> ways</span>(</span>s</span>,</span> s</span>.</span>length</span>()</span> -</span> 1</span>,</span>memo</span>);</span>
    }</span>
    public</span> int</span> ways</span>(</span>String</span> s</span>,</span> int</span> i</span>,</span>Integer</span>[]</span> memo</span>)</span> {</span>
        if</span> (</span>i</span> &lt;</span> 0</span>)</span>
            return</span> 1</span>;</span>
        if</span>(</span>memo</span>[</span>i</span>]!=</span>null</span>)</span>
            return</span> memo</span>[</span>i</span>];</span>
        if</span> (</span>s</span>.</span>charAt</span>(</span>i</span>)</span> ==</span> '*'</span>)</span> {</span>
            long</span> res</span> =</span> 9</span> *</span> ways</span>(</span>s</span>,</span> i</span> -</span> 1</span>,</span>memo</span>);</span>
            if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '1'</span>)</span>
                res</span> =</span> (</span>res</span> +</span> 9</span> *</span> ways</span>(</span>s</span>,</span> i</span> -</span> 2</span>,</span>memo</span>))</span> %</span> M</span>;</span>
            else</span> if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '2'</span>)</span>
                res</span> =</span> (</span>res</span> +</span> 6</span> *</span> ways</span>(</span>s</span>,</span> i</span> -</span> 2</span>,</span>memo</span>))</span> %</span> M</span>;</span>
            else</span> if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '*'</span>)</span>
                res</span> =</span> (</span>res</span> +</span> 15</span> *</span> ways</span>(</span>s</span>,</span> i</span> -</span> 2</span>,</span>memo</span>))</span> %</span> M</span>;</span>
            memo</span>[</span>i</span>]=(</span>int</span>)</span>res</span>;</span>
            return</span> memo</span>[</span>i</span>];</span>
        }</span>
        long</span> res</span> =</span> s</span>.</span>charAt</span>(</span>i</span>)</span> !=</span> '0'</span> ?</span> ways</span>(</span>s</span>,</span> i</span> -</span> 1</span>,</span>memo</span>)</span> :</span> 0</span>;</span>
        if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '1'</span>)</span>
            res</span> =</span> (</span>res</span> +</span> ways</span>(</span>s</span>,</span> i</span> -</span> 2</span>,</span>memo</span>))</span> %</span> M</span>;</span>
        else</span> if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '2'</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span>)</span> &lt;=</span> '6'</span>)</span>
            res</span> =</span> (</span>res</span> +</span> ways</span>(</span>s</span>,</span> i</span> -</span> 2</span>,</span>memo</span>))</span> %</span> M</span>;</span>
        else</span> if</span> (</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '*'</span>)</span>
                res</span> =</span> (</span>res</span> +</span> (</span>s</span>.</span>charAt</span>(</span>i</span>)&lt;=</span>'6'</span>?</span>2</span>:</span>1</span>)</span> *</span> ways</span>(</span>s</span>,</span> i</span> -</span> 2</span>,</span>memo</span>))</span> %</span> M</span>;</span>
        memo</span>[</span>i</span>]=</span> (</span>int</span>)</span>res</span>;</span>
        return</span> memo</span>[</span>i</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Size of recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, since <span class="maths katex-rendered">m</mi>e</mi>m</mi>o</mi></mrow><annotation encoding="application/x-tex">memo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span></span></span></span></span> array is filled exactly once. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of the input 
string.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</h4>
Algorithm</strong></p>
From the solutions discussed above, we can observe that the number of decodings possible upto any index, <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>, is dependent only on the characters upto the 
index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and not on any of the characters following it. This leads us to the idea that this problem can be solved by making use of Dynamic Programming.</p>
We can also easily observe from the recursive solution that, the number of decodings possible upto the index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> can be determined easily if we know 
the number of decodings possible upto the index <span class="maths katex-rendered">i</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">i</mi>−</mo>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span></span></span></span></span>. Thus, we fill in the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array in a forward manner. <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> is used to store the 
number of decodings possible by considering the characters in the given string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> upto the <span class="maths katex-rendered">(</mo>i</mi>−</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(i-1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index only(including it).</p>
The equations for filling this <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> at any step again depend on the current character and the just preceding character. These equations are similar 
to the ones used in the recursive solution.</p>
The following animation illustrates the process of filling the <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> for a simple example.</p>
<div class="diaporama" style="width: 1000px; height: 563px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 10</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> M</span> =</span> 1000000007</span>;</span>
    public</span> int</span> numDecodings</span>(</span>String</span> s</span>)</span> {</span>
        long</span>[]</span> dp</span> =</span> new</span> long</span>[</span>s</span>.</span>length</span>()</span> +</span> 1</span>];</span>
        dp</span>[</span>0</span>]</span> =</span> 1</span>;</span>
        dp</span>[</span>1</span>]</span> =</span> s</span>.</span>charAt</span>(</span>0</span>)</span> ==</span> '*'</span> ?</span> 9</span> :</span> s</span>.</span>charAt</span>(</span>0</span>)</span> ==</span> '0'</span> ?</span> 0</span> :</span> 1</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> s</span>.</span>length</span>();</span> i</span>++)</span> {</span>
            if</span> (</span>s</span>.</span>charAt</span>(</span>i</span>)</span> ==</span> '*'</span>)</span> {</span>
                dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> 9</span> *</span> dp</span>[</span>i</span>];</span>
                if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '1'</span>)</span>
                    dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> (</span>dp</span>[</span>i</span> +</span> 1</span>]</span> +</span> 9</span> *</span> dp</span>[</span>i</span> -</span> 1</span>])</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '2'</span>)</span>
                    dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> (</span>dp</span>[</span>i</span> +</span> 1</span>]</span> +</span> 6</span> *</span> dp</span>[</span>i</span> -</span> 1</span>])</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '*'</span>)</span>
                    dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> (</span>dp</span>[</span>i</span> +</span> 1</span>]</span> +</span> 15</span> *</span> dp</span>[</span>i</span> -</span> 1</span>])</span> %</span> M</span>;</span>
            }</span> else</span> {</span>
                dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> s</span>.</span>charAt</span>(</span>i</span>)</span> !=</span> '0'</span> ?</span> dp</span>[</span>i</span>]</span> :</span> 0</span>;</span>
                if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '1'</span>)</span>
                    dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> (</span>dp</span>[</span>i</span> +</span> 1</span>]</span> +</span> dp</span>[</span>i</span> -</span> 1</span>])</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '2'</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span>)</span> &lt;=</span> '6'</span>)</span>
                    dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> (</span>dp</span>[</span>i</span> +</span> 1</span>]</span> +</span> dp</span>[</span>i</span> -</span> 1</span>])</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '*'</span>)</span>
                    dp</span>[</span>i</span> +</span> 1</span>]</span> =</span> (</span>dp</span>[</span>i</span> +</span> 1</span>]</span> +</span> (</span>s</span>.</span>charAt</span>(</span>i</span>)</span> &lt;=</span> '6'</span> ?</span> 2</span> :</span> 1</span>)</span> *</span> dp</span>[</span>i</span> -</span> 1</span>])</span> %</span> M</span>;</span>
            }</span>
        }</span>
        return</span> (</span>int</span>)</span> dp</span>[</span>s</span>.</span>length</span>()];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> is filled once only. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of the input string.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of size <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-3-constant-space-dynamic-programming-accepted">Approach #3 Constant Space Dynamic Programming [Accepted]:</h4>
Algorithm</strong></p>
In the last approach, we can observe that only the last two values <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>2</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">2</span>]</span></span></span></span></span> and <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> are used to fill the entry at <span class="maths katex-rendered">d</mi>p</mi>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. We can save some 
space in the last approach, if instead of maintaining a whole <span class="maths katex-rendered">d</mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span></span></span></span></span> array of length <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>, we keep a track of only the required last two values. The rest of the 
process remains the same as in the last approach.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    int</span> M</span> =</span> 1000000007</span>;</span>
    public</span> int</span> numDecodings</span>(</span>String</span> s</span>)</span> {</span>
        long</span> first</span> =</span> 1</span>,</span> second</span> =</span> s</span>.</span>charAt</span>(</span>0</span>)</span> ==</span> '*'</span> ?</span> 9</span> :</span> s</span>.</span>charAt</span>(</span>0</span>)</span> ==</span> '0'</span> ?</span> 0</span> :</span> 1</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> s</span>.</span>length</span>();</span> i</span>++)</span> {</span>
            long</span> temp</span> =</span> second</span>;</span>
            if</span> (</span>s</span>.</span>charAt</span>(</span>i</span>)</span> ==</span> '*'</span>)</span> {</span>
                second</span> =</span> 9</span> *</span> second</span>;</span>
                if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '1'</span>)</span>
                    second</span> =</span> (</span>second</span> +</span> 9</span> *</span> first</span>)</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '2'</span>)</span>
                    second</span> =</span> (</span>second</span> +</span> 6</span> *</span> first</span>)</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '*'</span>)</span>
                    second</span> =</span> (</span>second</span> +</span> 15</span> *</span> first</span>)</span> %</span> M</span>;</span>
            }</span> else</span> {</span>
                second</span> =</span> s</span>.</span>charAt</span>(</span>i</span>)</span> !=</span> '0'</span> ?</span> second</span> :</span> 0</span>;</span>
                if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '1'</span>)</span>
                    second</span> =</span> (</span>second</span> +</span> first</span>)</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '2'</span> &amp;&amp;</span> s</span>.</span>charAt</span>(</span>i</span>)</span> &lt;=</span> '6'</span>)</span>
                    second</span> =</span> (</span>second</span> +</span> first</span>)</span> %</span> M</span>;</span>
                else</span> if</span> (</span>s</span>.</span>charAt</span>(</span>i</span> -</span> 1</span>)</span> ==</span> '*'</span>)</span>
                    second</span> =</span> (</span>second</span> +</span> (</span>s</span>.</span>charAt</span>(</span>i</span>)</span> &lt;=</span> '6'</span> ?</span> 2</span> :</span> 1</span>)</span> *</span> first</span>)</span> %</span> M</span>;</span>
            }</span>
            first</span> =</span> temp</span>;</span>
        }</span>
        return</span> (</span>int</span>)</span> second</span>;</span>
    }</span>

}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Single loop upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is required to find the required result. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of the input string <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>