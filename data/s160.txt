<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>
<a href="#approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</a></li>
<a href="#approach-3-two-pointers-accepted">Approach #3 (Two Pointers) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>
For each node ai</sub> in list A, traverse the entire list B and check if any node in list B coincides with ai</sub>.</p>
Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
</ul>

<h4 id="approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</h4>
Traverse list A and store the address / reference to each node in a hash set. Then check every node bi</sub> in list B: if bi</sub> appears in the hash set, then bi</sub> is the intersection node.</p>
Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>+</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>)</span></span></span></span></span> or <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</li>
</ul>

<h4 id="approach-3-two-pointers-accepted">Approach #3 (Two Pointers) [Accepted]</h4>

Maintain two pointers pA and pB initialized at the head of A and B, respectively. Then let them both traverse through the lists, one node at a time.</li>
When pA reaches the end of a list, then redirect it to the head of B (yes, B, that's right.); similarly when pB reaches the end of a list, redirect it the head of A.</li>
If at any point pA meets pB, then pA/pB is the intersection node.</li>
To see why the above trick would work, consider the following two lists: A = {1,3,5,7,9,11} and B = {2,4,9,11}, which are intersected at node '9'. Since B.length (=4) &lt; A.length (=6), pB would reach the end of the merged list first, because pB traverses exactly 2 nodes less than pA does. By redirecting pB to head A, and pA to head B, we now ask pB to travel exactly 2 more nodes than pA would. So in the second iteration, they are guaranteed to reach the intersection node at the same time.</li>
If two lists have intersection, then their last nodes must be the same one. So when pA/pB reaches the end of a list, record the last element of A/B respectively. If the two last elements are not the same one, then the two lists have no intersections.</li>
</ul>
Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>+</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span>+</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</li>
</ul>
Analysis written by @stellari.</p>