<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-two-pass-algorithm">Approach #1 (Two pass algorithm)</a></li>
<a href="#approach-2-one-pass-algorithm">Approach #2 (One pass algorithm)</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
This article is for beginners. It introduces the following idea:
Linked List traversal and removal of nth element from the end.</p>
Solution</h2>

<h4 id="approach-1-two-pass-algorithm">Approach #1 (Two pass algorithm)</h4>
Intuition</strong></p>
We notice that the problem could be simply reduced to another one : Remove the <span class="maths katex-rendered">(</mo>L</mi>−</mo>n</mi>+</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">(L - n + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">L</span>−</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span>)</span></span></span></span></span> th node from the beginning in the list , where <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> is the list length. This problem is easy to solve once we found list length <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span>.</p>
Algorithm</strong></p>
First we will add an auxiliary "dummy" node, which points to the list head. The "dummy" node is used to simplify some corner cases such as a list with only one node, or removing the head of the list. On the first pass, we find the list length <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span>. Then we set a pointer to the dummy node and start to move it through the list till it comes to the <span class="maths katex-rendered">(</mo>L</mi>−</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">(L - n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">L</span>−</span><span class="mord mathit">n</span>)</span></span></span></span></span> th node. We relink next</code> pointer of the <span class="maths katex-rendered">(</mo>L</mi>−</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">(L - n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">L</span>−</span><span class="mord mathit">n</span>)</span></span></span></span></span> th node to the <span class="maths katex-rendered">(</mo>L</mi>−</mo>n</mi>+</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">(L - n + 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">L</span>−</span><span class="mord mathit">n</span>+</span><span class="mord mathrm">2</span>)</span></span></span></span></span> th node and we are done.</p>
<img alt="Remove the nth element from a list" src="https://leetcode.com/media/original_images/19_Remove_nth_node_from_end_of_listA.png"></p>
Figure 1. Remove the L - n + 1 th element from a list.</em></p>
Java</strong></p>
</span>public</span> ListNode</span> removeNthFromEnd</span>(</span>ListNode</span> head</span>,</span> int</span> n</span>)</span> {</span>
    ListNode</span> dummy</span> =</span> new</span> ListNode</span>(</span>0</span>);</span>
    dummy</span>.</span>next</span> =</span> head</span>;</span>
    int</span> length</span>  =</span> 0</span>;</span>
    ListNode</span> first</span> =</span> head</span>;</span>
    while</span> (</span>first</span> !=</span> null</span>)</span> {</span>
        length</span>++;</span>
        first</span> =</span> first</span>.</span>next</span>;</span>
    }</span>
    length</span> -=</span> n</span>;</span>
    first</span> =</span> dummy</span>;</span>
    while</span> (</span>length</span> &gt;</span> 0</span>)</span> {</span>
        length</span>--;</span>
        first</span> =</span> first</span>.</span>next</span>;</span>
    }</span>
    first</span>.</span>next</span> =</span> first</span>.</span>next</span>.</span>next</span>;</span>
    return</span> dummy</span>.</span>next</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>L</mi>)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">L</span>)</span></span></span></span></span>.</li>
</ul>
The algorithm makes two traversal of the list, first to calculate list length <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> and second to find the <span class="maths katex-rendered">(</mo>L</mi>−</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">(L - n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">L</span>−</span><span class="mord mathit">n</span>)</span></span></span></span></span> th node. There are <span class="maths katex-rendered">2</mn>L</mi>−</mo>n</mi></mrow><annotation encoding="application/x-tex">2L-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit">L</span>−</span><span class="mord mathit">n</span></span></span></span></span> operations and time complexity is <span class="maths katex-rendered">O</mi>(</mo>L</mi>)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">L</span>)</span></span></span></span></span>.</p>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
We only used constant extra space.</li>
</ul>

<h4 id="approach-2-one-pass-algorithm">Approach #2 (One pass algorithm)</h4>
Algorithm</strong></p>
The above algorithm could be optimized to one pass. Instead of one pointer, we could use two pointers. The first pointer advances the list by <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are exactly separated by <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes apart. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>th node counting from the last.
We relink the next pointer of the node referenced by the second pointer to point to the node's next next node.</p>
<img alt="Remove the nth element from a list" src="https://leetcode.com/media/original_images/19_Remove_nth_node_from_end_of_listB.png"></p>
Figure 2. Remove the nth element from end of a list.</em></p>
Java</strong></p>
</span>public</span> ListNode</span> removeNthFromEnd</span>(</span>ListNode</span> head</span>,</span> int</span> n</span>)</span> {</span>
    ListNode</span> dummy</span> =</span> new</span> ListNode</span>(</span>0</span>);</span>
    dummy</span>.</span>next</span> =</span> head</span>;</span>
    ListNode</span> first</span> =</span> dummy</span>;</span>
    ListNode</span> second</span> =</span> dummy</span>;</span>
    // Advances first pointer so that the gap between first and second is n nodes apart</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span> +</span> 1</span>;</span> i</span>++)</span> {</span>
        first</span> =</span> first</span>.</span>next</span>;</span>
    }</span>
    // Move first to the end, maintaining the gap</span>
    while</span> (</span>first</span> !=</span> null</span>)</span> {</span>
        first</span> =</span> first</span>.</span>next</span>;</span>
        second</span> =</span> second</span>.</span>next</span>;</span>
    }</span>
    second</span>.</span>next</span> =</span> second</span>.</span>next</span>.</span>next</span>;</span>
    return</span> dummy</span>.</span>next</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>L</mi>)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">L</span>)</span></span></span></span></span>. The algorithm makes one traversal of the list of <span class="maths katex-rendered">L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span></span></span></span></span> nodes. Therefore time complexity is <span class="maths katex-rendered">O</mi>(</mo>L</mi>)</mo></mrow><annotation encoding="application/x-tex">O(L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">L</span>)</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
We only used constant extra space.</p>
</li>
</ul>
Analysis written by: @elmirap.</p>