<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>
<a href="#approach-2-dynamic-programming-accepted">Approach #2 (Dynamic Programming) [Accepted]</a></li>
<a href="#approach-3-better-dynamic-programming-accepted">Approach #3 (Better Dynamic Programming) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
We need to find the largest square comprising of all ones in the given <span class="maths katex-rendered">m</mi>×</mo>n</mi></mrow><annotation encoding="application/x-tex">m times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.58333em;"></span><span class="strut bottom" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span>×</span><span class="mord mathit">n</span></span></span></span></span> matrix. In other words we need to find the largest set of connected ones in the given matrix that forms a square.</p>
Solution</h2>

<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>
The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</p>
We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> maximalSquare</span>(</span>char</span>[][]</span> matrix</span>)</span> {</span>
        int</span> rows</span> =</span> matrix</span>.</span>length</span>,</span> cols</span> =</span> rows</span> &gt;</span> 0</span> ?</span> matrix</span>[</span>0</span>].</span>length</span> :</span> 0</span>;</span>
        int</span> maxsqlen</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> rows</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> cols</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>matrix</span>[</span>i</span>][</span>j</span>]</span> ==</span> '1'</span>)</span> {</span>
                    int</span> sqlen</span> =</span> 1</span>;</span>
                    boolean</span> flag</span> =</span> true</span>;</span>
                    while</span> (</span>sqlen</span> +</span> i</span> &lt;</span> rows</span> &amp;&amp;</span> sqlen</span> +</span> j</span> &lt;</span> cols</span> &amp;&amp;</span> flag</span>)</span> {</span>
                        for</span> (</span>int</span> k</span> =</span> j</span>;</span> k</span> &lt;=</span> sqlen</span> +</span> j</span>;</span> k</span>++)</span> {</span>
                            if</span> (</span>matrix</span>[</span>i</span> +</span> sqlen</span>][</span>k</span>]</span> ==</span> '0'</span>)</span> {</span>
                                flag</span> =</span> false</span>;</span>
                                break</span>;</span>
                            }</span>
                        }</span>
                        for</span> (</span>int</span> k</span> =</span> i</span>;</span> k</span> &lt;=</span> sqlen</span> +</span> i</span>;</span> k</span>++)</span> {</span>
                            if</span> (</span>matrix</span>[</span>k</span>][</span>j</span> +</span> sqlen</span>]</span> ==</span> '0'</span>)</span> {</span>
                                flag</span> =</span> false</span>;</span>
                                break</span>;</span>
                            }</span>
                        }</span>
                        if</span> (</span>flag</span>)</span>
                            sqlen</span>++;</span>
                    }</span>
                    if</span> (</span>maxsqlen</span> &lt;</span> sqlen</span>)</span> {</span>
                        maxsqlen</span> =</span> sqlen</span>;</span>
                    }</span>
                }</span>
            }</span>
        }</span>
        return</span> maxsqlen</span> *</span> maxsqlen</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>(</mo>m</mi>n</mi>)</mo>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">Obig((mn)^2big)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span>(</span><span class="mord mathit">m</span><span class="mord mathit">n</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span></span></span></span></span>. In worst case, we need to traverse the complete matrix for every 1.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. No extra space is used.</li>
</ul>

<h4 id="approach-2-dynamic-programming-accepted">Approach #2 (Dynamic Programming) [Accepted]</h4>
Algorithm</strong></p>
We will explain this approach with the help of an example.</p>
</span>0 1 1 1 0
1 1 1 1 1
0 1 1 1 1
0 1 1 1 1
0 0 1 1 1
</pre></div>


We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0’s.</p>
dp(i,j) represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix. </p>
Starting from index (0,0), for every 1 found in the original matrix, we update the value of the current element as </p>

<p class="maths katex-rendered">d</mi>p</mi></mtext>(</mo>i</mi>,</mo>&nbsp;</mtext>j</mi>)</mo>=</mo>min</mi>(</mo>d</mi>p</mi></mtext>(</mo>i</mi>−</mo>1</mn>,</mo>&nbsp;</mtext>j</mi>)</mo>,</mo>&nbsp;</mtext>d</mi>p</mi></mtext>(</mo>i</mi>−</mo>1</mn>,</mo>&nbsp;</mtext>j</mi>−</mo>1</mn>)</mo>,</mo>&nbsp;</mtext>d</mi>p</mi></mtext>(</mo>i</mi>,</mo>&nbsp;</mtext>j</mi>−</mo>1</mn>)</mo>)</mo>+</mo>1</mn>.</mi></mrow><annotation encoding="application/x-tex">
text{dp}(i,  j) = min big( text{dp}(i-1,  j),  text{dp}(i-1,  j-1),  text{dp}(i,  j-1) big) + 1.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.85em;"></span><span class="strut bottom" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord text displaystyle textstyle uncramped"><span class="mord mathrm">dp</span></span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit">&nbsp;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span>)</span>=</span>min</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">(</span></span><span class="mord text displaystyle textstyle uncramped"><span class="mord mathrm">dp</span></span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">&nbsp;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span>)</span>,</span><span class="mord text displaystyle textstyle uncramped">&nbsp;</span><span class="mord mathrm">dp</span></span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>,</span><span class="mord mathit">&nbsp;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span>−</span><span class="mord mathrm">1</span>)</span>,</span><span class="mord text displaystyle textstyle uncramped">&nbsp;</span><span class="mord mathrm">dp</span></span>(</span><span class="mord mathit">i</span>,</span><span class="mord mathit">&nbsp;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span>−</span><span class="mord mathrm">1</span>)</span><span class="mord style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing size1">)</span></span>+</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span></span></span></span></span></p>
</p>
We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size. This gives the side length of the square (say <span class="maths katex-rendered">m</mi>a</mi>x</mi>s</mi>q</mi>l</mi>e</mi>n</mi></mrow><annotation encoding="application/x-tex">maxsqlen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">n</span></span></span></span></span>). The required result is the area <span class="maths katex-rendered">m</mi>a</mi>x</mi>s</mi>q</mi>l</mi>e</mi>n</mi>2</mn></msup></mrow><annotation encoding="application/x-tex">maxsqlen^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.00855em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>.</p>
To understand how this solution works, see the figure below.</p>
<img alt="Max Square" src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true"></p>
An entry 2 at <span class="maths katex-rendered">(</mo>1</mn>,</mo>3</mn>)</mo></mrow><annotation encoding="application/x-tex">(1, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">1</span>,</span><span class="mord mathrm">3</span>)</span></span></span></span></span> implies that we have a square of side 2 up to that index in the original matrix. Similarly, a 2 at <span class="maths katex-rendered">(</mo>1</mn>,</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">(1, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">1</span>,</span><span class="mord mathrm">2</span>)</span></span></span></span></span> and <span class="maths katex-rendered">(</mo>2</mn>,</mo>2</mn>)</mo></mrow><annotation encoding="application/x-tex">(2, 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">2</span>,</span><span class="mord mathrm">2</span>)</span></span></span></span></span> implies that a square of side 2 exists up to that index in the original matrix. Now to make a square of side 3, only a single entry of 1 is pending at <span class="maths katex-rendered">(</mo>2</mn>,</mo>3</mn>)</mo></mrow><annotation encoding="application/x-tex">(2, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">2</span>,</span><span class="mord mathrm">3</span>)</span></span></span></span></span>. So, we enter a 3 corresponding to that position in the dp array.</p>
Now consider the case for the index <span class="maths katex-rendered">(</mo>3</mn>,</mo>4</mn>)</mo></mrow><annotation encoding="application/x-tex">(3, 4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">3</span>,</span><span class="mord mathrm">4</span>)</span></span></span></span></span>. Here, the entries at index <span class="maths katex-rendered">(</mo>3</mn>,</mo>3</mn>)</mo></mrow><annotation encoding="application/x-tex">(3, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">3</span>,</span><span class="mord mathrm">3</span>)</span></span></span></span></span> and <span class="maths katex-rendered">(</mo>2</mn>,</mo>3</mn>)</mo></mrow><annotation encoding="application/x-tex">(2, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">2</span>,</span><span class="mord mathrm">3</span>)</span></span></span></span></span> imply that a square of side 3 is possible up to their indices. But, the entry 1 at index <span class="maths katex-rendered">(</mo>2</mn>,</mo>4</mn>)</mo></mrow><annotation encoding="application/x-tex">(2, 4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">2</span>,</span><span class="mord mathrm">4</span>)</span></span></span></span></span> indicates that a square of side 1 only can be formed up to its index. Therefore, while making an entry at the index <span class="maths katex-rendered">(</mo>3</mn>,</mo>4</mn>)</mo></mrow><annotation encoding="application/x-tex">(3, 4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathrm">3</span>,</span><span class="mord mathrm">4</span>)</span></span></span></span></span>, this element obstructs the formation of a square having a side larger than 2. Thus, the maximum sized square that can be formed up to this index is of size <span class="maths katex-rendered">2</mn>×</mo>2</mn></mrow><annotation encoding="application/x-tex">2times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span>×</span><span class="mord mathrm">2</span></span></span></span></span>.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> maximalSquare</span>(</span>char</span>[][]</span> matrix</span>)</span> {</span>
        int</span> rows</span> =</span> matrix</span>.</span>length</span>,</span> cols</span> =</span> rows</span> &gt;</span> 0</span> ?</span> matrix</span>[</span>0</span>].</span>length</span> :</span> 0</span>;</span>
        int</span>[][]</span> dp</span> =</span> new</span> int</span>[</span>rows</span> +</span> 1</span>][</span>cols</span> +</span> 1</span>];</span>
        int</span> maxsqlen</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> rows</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 1</span>;</span> j</span> &lt;=</span> cols</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>matrix</span>[</span>i</span>-</span>1</span>][</span>j</span>-</span>1</span>]</span> ==</span> '1'</span>){</span>
                    dp</span>[</span>i</span>][</span>j</span>]</span> =</span> Math</span>.</span>min</span>(</span>Math</span>.</span>min</span>(</span>dp</span>[</span>i</span>][</span>j</span> -</span> 1</span>],</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span>]),</span> dp</span>[</span>i</span> -</span> 1</span>][</span>j</span> -</span> 1</span>])</span> +</span> 1</span>;</span>
                    maxsqlen</span> =</span> Math</span>.</span>max</span>(</span>maxsqlen</span>,</span> dp</span>[</span>i</span>][</span>j</span>]);</span>
                }</span>
            }</span>
        }</span>
        return</span> maxsqlen</span> *</span> maxsqlen</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Single pass.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Another matrix of same size is used for dp.</p>
</li>
</ul>

<h4 id="approach-3-better-dynamic-programming-accepted">Approach #3 (Better Dynamic Programming) [Accepted]</h4>
Algorithm</strong></p>
In the previous approach for calculating dp of <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> row we are using only the previous element and the <span class="maths katex-rendered">(</mo>i</mi>−</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(i-1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> row. Therefore, we don't need 2D dp matrix as 1D dp array will be sufficient for this.</p>
Initially the dp array contains all 0's. As we scan the elements of the original matrix across a row, we keep on updating the dp array as per the equation <span class="maths katex-rendered">d</mi>p</mi>[</mo>j</mi>]</mo>=</mo>m</mi>i</mi>n</mi>(</mo>d</mi>p</mi>[</mo>j</mi>−</mo>1</mn>]</mo>,</mo>d</mi>p</mi>[</mo>j</mi>]</mo>,</mo>p</mi>r</mi>e</mi>v</mi>)</mo></mrow><annotation encoding="application/x-tex">dp[j]=min(dp[j-1],dp[j],prev)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span>(</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>]</span>,</span><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>,</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span>)</span></span></span></span></span>, where prev refers to the old <span class="maths katex-rendered">d</mi>p</mi>[</mo>j</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">dp[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>. For every row, we repeat the same process and update in the same dp array.</p>
<img alt=" Max Square " src="https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true"></p>
java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> maximalSquare</span>(</span>char</span>[][]</span> matrix</span>)</span> {</span>
        int</span> rows</span> =</span> matrix</span>.</span>length</span>,</span> cols</span> =</span> rows</span> &gt;</span> 0</span> ?</span> matrix</span>[</span>0</span>].</span>length</span> :</span> 0</span>;</span>
        int</span>[]</span> dp</span> =</span> new</span> int</span>[</span>cols</span> +</span> 1</span>];</span>
        int</span> maxsqlen</span> =</span> 0</span>,</span> prev</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> rows</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 1</span>;</span> j</span> &lt;=</span> cols</span>;</span> j</span>++)</span> {</span>
                int</span> temp</span> =</span> dp</span>[</span>j</span>];</span>
                if</span> (</span>matrix</span>[</span>i</span> -</span> 1</span>][</span>j</span> -</span> 1</span>]</span> ==</span> '1'</span>)</span> {</span>
                    dp</span>[</span>j</span>]</span> =</span> Math</span>.</span>min</span>(</span>Math</span>.</span>min</span>(</span>dp</span>[</span>j</span> -</span> 1</span>],</span> prev</span>),</span> dp</span>[</span>j</span>])</span> +</span> 1</span>;</span>
                    maxsqlen</span> =</span> Math</span>.</span>max</span>(</span>maxsqlen</span>,</span> dp</span>[</span>j</span>]);</span>
                }</span> else</span> {</span>
                    dp</span>[</span>j</span>]</span> =</span> 0</span>;</span>
                }</span>
                prev</span> =</span> temp</span>;</span>
            }</span>
        }</span>
        return</span> maxsqlen</span> *</span> maxsqlen</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>m</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">m</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Single pass.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Another array which stores elements in a row is used for dp.</p>
</li>
</ul>
Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>