Solution
Approach #1 Using Recursion [Accepted]
Algorithm
Before discussing the steps involved in the process, we need to note a few points. Firstly, whenever an offer is used from amongst the ones available in the
special
special list, we need to update the
needs
needs appropriately, such that the number of items in the current offer of each type are deducted from the ones in the corresponding entry in
needs
needs.
Further, an offer can be used only if the number of items, of each type, required for using the offer, is lesser than or equal to the ones available in the current
needs
needs.
Now, let's discuss the algorithm. We make use of a shopping(price,special,needs) function, which takes the
price
price and
special
special list along with the current(updated)
needs
needs as the input and returns the minimum cost of buying these items as required by this
needs
needs list.
In every call of the function shopping(price,special,needs), we do as follows:
Determine the cost of buying items as per the
needs
needs array, without applying any offer. Store the result in
res
res.
Iterate over every offer in the
special
special list. For every offer chosen, repeat steps 3 to 5.
Create a copy of the current
needs
needs in a
clone
clone list(so that the original needs can be used again, while selecting the next offer).
Try to apply the current offer. If possible, update the required number of items in
clone
clone.
If the current offer could be applied, find the minimum cost out of
res
res and offer_\current + shopping(price,special,clone). Here, \(offer_\current\) refers to the price that needs to be paid for the current offer. Update the
res
res with the minimum value.
Return the
res
res corresponding to the minimum cost.
We need to note that the
clone
clone needs to be updated afresh from
needs
needs(coming to the current function call) when we choose a new offer. This needs to be done, because solely applying the next offer could result in a lesser cost than the one resulting by using the previous offer first.
Java
public class Solution {
    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {
        return shopping(price, special, needs);
    }
    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {
        int j = 0, res = dot(needs, price);
        for (List < Integer > s: special) {
            ArrayList < Integer > clone = new ArrayList < > (needs);
            for (j = 0; j < needs.size(); j++) {
                int diff = clone.get(j) - s.get(j);
                if (diff < 0)
                    break;
                clone.set(j, diff);
            }
            if (j == needs.size())
                res = Math.min(res, s.get(j) + shopping(price, special, clone));
        }
        return res;
    }
    public int dot(List < Integer > a, List < Integer > b) {
        int sum = 0;
        for (int i = 0; i < a.size(); i++) {
            sum += a.get(i) * b.get(i);
        }
        return sum;
    }

}
Approach #2 Using Recursion with memoization [Accepted]
Algorithm
In the last approach, we can observe that the same
needs
needs can be reached by applying the offers in various orders. e.g. We can choose the first offer followed by the second offer or vice-versa. But, both lead to the same requirement of updated
needs
needs and the cost as well. Thus, instead of repeating the whole process for the same
needs
needs state through various recursive paths, we can create an entry corresponding to the current set of
needs
needs in a HashMap,
map
map, which stores the minimum cost corresponding to this set of
needs
needs. Thus, whenever the same call is made again in the future through a different path, we need not repeat the whole process over, and we can directly return the result stored in the
map
map.
Java
public class Solution {
    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {
        Map < List < Integer > , Integer > map = new HashMap();
        return shopping(price, special, needs, map);
    }
    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs, Map < List < Integer > , Integer > map) {
        if (map.containsKey(needs))
            return map.get(needs);
        int j = 0, res = dot(needs, price);
        for (List < Integer > s: special) {
            ArrayList < Integer > clone = new ArrayList < > (needs);
            for (j = 0; j < needs.size(); j++) {
                int diff = clone.get(j) - s.get(j);
                if (diff < 0)
                    break;
                clone.set(j, diff);
            }
            if (j == needs.size())
                res = Math.min(res, s.get(j) + shopping(price, special, clone, map));
        }
        map.put(needs, res);
        return res;
    }
    public int dot(List < Integer > a, List < Integer > b) {
        int sum = 0;
        for (int i = 0; i < a.size(); i++) {
            sum += a.get(i) * b.get(i);
        }
        return sum;
    }

}
Analysis written by: @vinod23