Solution
Approach #1 Brute Force (using Double Length Array) [Time Limit Exceeded]
In this method, we make use of an array
doublenums
doublenums which is formed by concatenating two copies of the given
nums
nums array one after the other. Now, when we need to find out the next greater element for
nums[i]
nums[i], we can simply scan all the elements
doublenums[j]
doublenums[j], such that
i < j < length(doublenums)
i<j<length(doublenums). The first element found satisfying the given condition is the required result for
nums[i]
nums[i]. If no such element is found, we put a
\text{-1}
-1 at the appropriate position in the
res
res array.
Java
 public class Solution {

    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        int[] doublenums = new int[nums.length * 2];
        System.arraycopy(nums, 0, doublenums, 0, nums.length);
        System.arraycopy(nums, 0, doublenums, nums.length, nums.length);
        for (int i = 0; i < nums.length; i++) {
            res[i]=-1;
            for (int j = i + 1; j < doublenums.length; j++) {
                if (doublenums[j] > doublenums[i]) {
                    res[i] = doublenums[j];
                    break;
                }
            }
        }
        return res;
    }
}
Complexity Analysis
Time complexity :
O(n^2)
O(n
2
). The complete
doublenums
doublenums array(of size
\text{2n}
2n) is scanned for all the elements of
nums
nums in the worst case.
Space complexity :
O(n)
O(n).
doublenums
doublenums array of size
\text{2n}
2n is used.
res
res array of size
\text{n}
n is used.
Approach #2 Better Brute Force [Accepted]
Instead of making a double length copy of
nums
nums array , we can traverse circularly in the
nums
nums array by making use of the \text{%(modulus)} operator. For every element
nums[i]
nums[i], we start searching in the
nums
nums array(of length
n
n) from the index \((i+1)%n\) and look at the next(cicularly)
n-1
n−1 elements. For
nums[i]
nums[i] we do so by scanning over
nums[j]
nums[j], such that \((i+1)%n ≤ j ≤ (i+(n-1))%n\), and we look for the first greater element found. If no such element is found, we put a
\text{-1}
-1 at the appropriate position in the
res
res array.
Java
 public class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            res[i] = -1;
            for (int j = 1; j < nums.length; j++) {
                if (nums[(i + j) % nums.length] > nums[i]) {
                    res[i] = nums[(i + j) % nums.length];
                    break;
                }
            }
        }
        return res;
    }
}
Complexity Analysis
Time complexity :
O(n^2)
O(n
2
). The complete
nums
nums array of size
n
n is scanned for all the elements of
nums
nums in the worst case.
Space complexity :
O(n)
O(n).
res
res array of size
n
n is used.
Approach #3 Using Stack [Accepted]
This approach makes use of a stack. This stack stores the indices of the appropriate elements from
nums
nums array. The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the
nums
nums array. The description of the method will make the above statement clearer.
We start traversing the
nums
nums array from right towards the left. For an element
nums[i]
nums[i] encountered, we pop all the elements
stack[top]
stack[top] from the stack such that \(nums\big[stack[top]\big] ≤ nums[i]\). We continue the popping till we encounter a
stack[top]
stack[top] satisfying
nums\big[stack[top]\big] > nums[i]
nums[stack[top]]>nums[i]. Now, it is obvious that the current
stack[top]
stack[top] only can act as the Next Greater Element for
nums[i]
nums[i](right now, considering only the elements lying to the right of
nums[i]
nums[i]).
If no element remains on the top of the stack, it means no larger element than
nums[i]
nums[i] exists to its right. Along with this, we also push the index of the element just encountered(
nums[i]
nums[i]), i.e.
i
i over the top of the stack, so that
nums[i]
nums[i](or
stack[top
stack[top) now acts as the Next Greater Element for the elements lying to its left.
We go through two such passes over the complete
nums
nums array. This is done so as to complete a circular traversal over the
nums
nums array. The first pass could make some wrong entries in the
res
res array since it considers only the elements lying to the right of
nums[i]
nums[i], without a circular traversal. But, these entries are corrected in the second pass.
Further, to ensure the correctness of the method, let's look at the following cases.
Assume that
nums[j]
nums[j] is the correct Next Greater Element for
nums[i]
nums[i], such that \(i < j ≤ stack[top]\). Now, whenever we encounter
nums[j]
nums[j], if
nums[j] > nums\big[stack[top]\big]
nums[j]>nums[stack[top]], it would have already popped the previous
stack[top]
stack[top] and
j
j would have become the topmost element. On the other hand, if
nums[j] < nums\big[stack[top]\big]
nums[j]<nums[stack[top]], it would have become the topmost element by being pushed above the previous
stack[top]
stack[top]. In both the cases, if
nums[j] > nums[i]
nums[j]>nums[i], it will be correctly determined to be the Next Greater Element.
The following example makes the procedure clear:
1 / 25
As the animation above depicts, after the first pass, there are a number of wrong entries(marked as
\text{-1}
-1) in the
res
res array, because only the elements lying to the corresponding right(non-circular) have been considered till now. But, after the second pass, the correct values are substituted.
Java
public class Solution {

    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Stack<Integer> stack = new Stack<>();
        for (int i = 2 * nums.length - 1; i >= 0; --i) {
            while (!stack.empty() && nums[stack.peek()] <= nums[i % nums.length]) {
                stack.pop();
            }
            res[i % nums.length] = stack.empty() ? -1 : nums[stack.peek()];
            stack.push(i % nums.length);
        }
        return res;
    }
}
Complexity Analysis
Time complexity :
O(n)
O(n). Only two traversals of the
nums
nums array are done. Further, atmost
\text{2n}
2n elements are pushed and popped from the stack.
Space complexity :
O(n)
O(n). A stack of size
n
n is used.
res
res array of size
n
n is used.
Analysis written by: @vinod23