<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>
<a href="#approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</a></li>
<a href="#approach-5-without-using-extra-space-accepted">Approach #5 Without Using Extra Space [Accepted]:</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
In the brute force approach, we consider every possible subarray that can be formed from the given array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>. For every subarray <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>:</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i:j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>:</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> considered, we need to check whether this is the smallest unsorted subarray or not. Thus, for every such subarray considered, we find out the maximum and minimum values lying in that subarray given by <span class="maths katex-rendered">m</mi>a</mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span></span> and <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> respectively.</p>
If the subarrays <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>0</mn>:</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[0:i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathrm">0</span>:</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>:</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[j:n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>:</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> are correctly sorted, then only <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>:</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i:j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>:</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> could be the required subrray. Further, the elements in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>0</mn>:</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[0:i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathrm">0</span>:</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> all need to be lesser than the <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> for satisfying the required condition. Similarly, all the elements in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>:</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[j:n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>:</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> need to be larger than <span class="maths katex-rendered">m</mi>a</mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span></span>. We check for these conditions for every possible <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> selected.</p>
Further, we also need to check if <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>0</mn>:</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[0:i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathrm">0</span>:</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>:</mo>n</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">nums[j:n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>:</span><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span> are sorted correctly. If all the above conditions are satisfied, we determine the length of the unsorted subarray as <span class="maths katex-rendered">j</mi>−</mo>i</mi></mrow><annotation encoding="application/x-tex">j-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span></span></span></span></span>. We do the same process for every subarray chosen and determine the length of the smallest unsorted subarray found.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findUnsortedSubarray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> res</span> =</span> nums</span>.</span>length</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> i</span>;</span> j</span> &lt;=</span> nums</span>.</span>length</span>;</span> j</span>++)</span> {</span>
                int</span> min</span> =</span> Integer</span>.</span>MAX_VALUE</span>,</span> max</span> =</span> Integer</span>.</span>MIN_VALUE</span>,</span> prev</span> =</span> Integer</span>.</span>MIN_VALUE</span>;</span>
                for</span> (</span>int</span> k</span> =</span> i</span>;</span> k</span> &lt;</span> j</span>;</span> k</span>++)</span> {</span>
                    min</span> =</span> Math</span>.</span>min</span>(</span>min</span>,</span> nums</span>[</span>k</span>]);</span>
                    max</span> =</span> Math</span>.</span>max</span>(</span>max</span>,</span> nums</span>[</span>k</span>]);</span>
                }</span>
                if</span> ((</span>i</span> &gt;</span> 0</span> &amp;&amp;</span> nums</span>[</span>i</span> -</span> 1</span>]</span> &gt;</span> min</span>)</span> ||</span> (</span>j</span> &lt;</span> nums</span>.</span>length</span> &amp;&amp;</span> nums</span>[</span>j</span>]</span> &lt;</span> max</span>))</span>
                    continue</span>;</span>
                int</span> k</span> =</span> 0</span>;</span>
                while</span> (</span>k</span> &lt;</span> i</span> &amp;&amp;</span> prev</span> &lt;=</span> nums</span>[</span>k</span>])</span> {</span>
                    prev</span> =</span> nums</span>[</span>k</span>];</span>
                    k</span>++;</span>
                }</span>
                if</span> (</span>k</span> !=</span> i</span>)</span>
                    continue</span>;</span>
                k</span> =</span> j</span>;</span>
                while</span> (</span>k</span> &lt;</span> nums</span>.</span>length</span> &amp;&amp;</span> prev</span> &lt;=</span> nums</span>[</span>k</span>])</span> {</span>
                    prev</span> =</span> nums</span>[</span>k</span>];</span>
                    k</span>++;</span>
                }</span>
                if</span> (</span>k</span> ==</span> nums</span>.</span>length</span>)</span> {</span>
                    res</span> =</span> Math</span>.</span>min</span>(</span>res</span>,</span> j</span> -</span> i</span>);</span>

                }</span>
            }</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Three nested loops are there.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
In this approach, we make use of an idea based on selection sort. We can traverse over the given <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array choosing the elements <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>. For every such element chosen, we try to determine its correct position in the sorted array. For this, we compare <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> with every <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, such that <span class="maths katex-rendered">i</mi>&lt;</mo>j</mi>&lt;</mo>n</mi></mrow><annotation encoding="application/x-tex">i &lt; j &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>&lt;</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>&lt;</span><span class="mord mathit">n</span></span></span></span></span>. Here, <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the length of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array.</p>
If any <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> happens to be lesser than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, it means both <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> aren't at their correct position for the sorted array. Thus, we need to swap the two elements to bring them at their correct positions. Here, instead of swapping, we just note the position of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>(given by <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>) and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>(given by <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>). These two elements now mark the boundary of the unsorted subarray(atleast for the time being).</p>
Thus, out of all the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> chosen, we determine the leftmost <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> which isn't at its correct position. This marks the left boundary of the smallest unsorted subarray(<span class="maths katex-rendered">l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span>). Similarly, out of all the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>'s considered for all <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>'s we determine the rightmost <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> which isn't at its correct position. This marks the right boundary of the smallest unsorted subarray(<span class="maths katex-rendered">r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span></span></span></span></span>).</p>
<img alt="Unsorted_subarray" src="../Figures/581/Unsorted_subarray_1.PNG"></p>
Thus, we can determine the length of the smallest unsorted subarray as <span class="maths katex-rendered">r</mi>−</mo>l</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">r - l + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span>−</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span>+</span><span class="mord mathrm">1</span></span></span></span></span>.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findUnsortedSubarray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> l</span> =</span> nums</span>.</span>length</span>,</span> r</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span> -</span> 1</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> i</span> +</span> 1</span>;</span> j</span> &lt;</span> nums</span>.</span>length</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>nums</span>[</span>j</span>]</span> &lt;</span> nums</span>[</span>i</span>])</span> {</span>
                    r</span> =</span> Math</span>.</span>max</span>(</span>r</span>,</span> j</span>);</span>
                    l</span> =</span> Math</span>.</span>min</span>(</span>l</span>,</span> i</span>);</span>
                }</span>
            }</span>
        }</span>
        return</span> r</span> -</span> l</span> &lt;</span> 0</span> ?</span> 0</span> :</span> r</span> -</span> l</span> +</span> 1</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Two nested loops are there.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>
Algorithm</strong></p>
Another very simple idea is as follows. We can sort a copy of the given array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>, say given by <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>_</mi>s</mi>o</mi>r</mi>t</mi>e</mi>d</mi></mrow><annotation encoding="application/x-tex">nums_sorted</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span></span></span></span></span>. Then, if we compare the elements of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>_</mi>s</mi>o</mi>r</mi>t</mi>e</mi>d</mi></mrow><annotation encoding="application/x-tex">nums_sorted</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span></span></span></span></span>, we can determine the leftmost and rightmost elements which mismatch. The subarray lying between them is, then, the required shorted unsorted subarray.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findUnsortedSubarray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span>[]</span> snums</span> =</span> nums</span>.</span>clone</span>();</span>
        Arrays</span>.</span>sort</span>(</span>snums</span>);</span>
        int</span> start</span> =</span> snums</span>.</span>length</span>,</span> end</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> snums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>snums</span>[</span>i</span>]</span> !=</span> nums</span>[</span>i</span>])</span> {</span>
                start</span> =</span> Math</span>.</span>min</span>(</span>start</span>,</span> i</span>);</span>
                end</span> =</span> Math</span>.</span>max</span>(</span>end</span>,</span> i</span>);</span>
            }</span>
        }</span>
        return</span> (</span>end</span> -</span> start</span> &gt;=</span> 0</span> ?</span> end</span> -</span> start</span> +</span> 1</span> :</span> 0</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>l</mi>o</mi>g</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Sorting takes <span class="maths katex-rendered">n</mi>l</mi>o</mi>g</mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. We are making copy of original array.</p>
</li>
</ul>

<h4 id="approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</h4>
Algorithm</strong></p>
The idea behind this approach is also based on selective sorting. We need to determine the correct position of the minimum and the maximum element in the unsorted subarray to determine the boundaries of the required unsorted subarray.</p>
To do so, in this implementation, we make use of a <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. We traverse over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array starting from the beginning. As we go on facing elements in ascending order(a rising slope), we keep on pushing the elements' indices over the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. This is done because such elements are in the correct sorted order(as it seems till now). As soon as we encounter a falling slope, i.e. an element <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> which is smaller than the element on the top of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, we know that <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> isn't at its correct position.</p>
In order to determine the correct position of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, we keep on popping the elemnents from the top of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> until we reach the stage where the element(corresponding to the index) on the top of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> is lesser than <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>. Let's say the popping stops when the index on <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>'s top is <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. Now, <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span> has found its correct position. It needs to lie at an index <span class="maths katex-rendered">k</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span>+</span><span class="mord mathrm">1</span></span></span></span></span>.</p>
We follow the same process while traversing over the whole array, and determine the value of minimum such <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. This marks the left boundary of the unsorted subarray.</p>
Similarly, to find the right boundary of the unsorted subarray, we traverse over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array backwards. This time we keep on pushing the elements if we see a falling slope. As soon as we find a rising slope, we trace forwards now and determine the larger element's correct position. We do so for the complete array and thus, determine the right boundary.</p>
We can look at the figure below for reference. We can observe that the slopes directly indicate the relative ordering. We can also observe that the point <span class="maths katex-rendered">b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span></span> needs to lie just after index 0 marking the left boundary and the point <span class="maths katex-rendered">a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span></span></span></span></span> needs to lie just before index 7 marking the right boundary of the unsorted subarray.</p>
<img alt="Unsorted_subarray" src="../Figures/581/Unsorted_subarray_2.PNG"></p>
Below code is inpired by <a href="http://leetcode.com/fallcreek">@fallcreek</a></p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findUnsortedSubarray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        Stack</span> &lt;</span> Integer</span> &gt;</span> stack</span> =</span> new</span> Stack</span> &lt;</span> Integer</span> &gt;</span> ();</span>
        int</span> l</span> =</span> nums</span>.</span>length</span>,</span> r</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            while</span> (!</span>stack</span>.</span>isEmpty</span>()</span> &amp;&amp;</span> nums</span>[</span>stack</span>.</span>peek</span>()]</span> &gt;</span> nums</span>[</span>i</span>])</span>
                l</span> =</span> Math</span>.</span>min</span>(</span>l</span>,</span> stack</span>.</span>pop</span>());</span>
            stack</span>.</span>push</span>(</span>i</span>);</span>
        }</span>
        stack</span>.</span>clear</span>();</span>
        for</span> (</span>int</span> i</span> =</span> nums</span>.</span>length</span> -</span> 1</span>;</span> i</span> &gt;=</span> 0</span>;</span> i</span>--)</span> {</span>
            while</span> (!</span>stack</span>.</span>isEmpty</span>()</span> &amp;&amp;</span> nums</span>[</span>stack</span>.</span>peek</span>()]</span> &lt;</span> nums</span>[</span>i</span>])</span>
                r</span> =</span> Math</span>.</span>max</span>(</span>r</span>,</span> stack</span>.</span>pop</span>());</span>
            stack</span>.</span>push</span>(</span>i</span>);</span>
        }</span>
        return</span> r</span> -</span> l</span> &gt;</span> 0</span> ?</span> r</span> -</span> l</span> +</span> 1</span> :</span> 0</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Stack of size <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is filled.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Stack size grows upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-5-without-using-extra-space-accepted">Approach #5 Without Using Extra Space [Accepted]:</h4>
Algorithm</strong></p>
The idea behind this method is that the correct position of the minimum element in the unsorted subarray helps to determine the required left boundary. Similarly, the correct position of the maximum element in the unsorted subarray helps to determine the required right boundary.</p>
Thus, firstly we need to determine when the correctly sorted array goes wrong. We keep a track of this by observing rising slope starting from the beginning of the array. Whenever the slope falls, we know that the unsorted array has surely started. Thus, now we determine the minimum element found till the end of the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span>, given by <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span>.</p>
Similarly, we scan the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> in the reverse order and when the slope becomes rising instead of falling, we start looking for the maximum element till we reach the beginning of the array, given by <span class="maths katex-rendered">m</mi>a</mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span></span>.</p>
Then, we traverse over <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> and determine the correct position of <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span> and <span class="maths katex-rendered">m</mi>a</mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span></span> by comparing these elements with the other array elements. e.g. To determine the correct position of <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span>, we know the initial portion of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> is already sorted. Thus, we need to find the first element which is just larger than <span class="maths katex-rendered">m</mi>i</mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span></span>. Similarly, for <span class="maths katex-rendered">m</mi>a</mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span></span>'s position, we need to find the first element which is just smaller than <span class="maths katex-rendered">m</mi>a</mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span></span> searching in <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> backwards.</p>
We can take this figure for reference again:</p>
<img alt="Unsorted_subarray" src="../Figures/581/Unsorted_subarray_2.PNG"></p>
We can observe that the point <span class="maths katex-rendered">b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span></span> needs to lie just after index 0 marking the left boundary and the point <span class="maths katex-rendered">a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span></span></span></span></span> needs to lie just before index 7 marking the right boundary of the unsorted subarray.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> findUnsortedSubarray</span>(</span>int</span>[]</span> nums</span>)</span> {</span>
        int</span> min</span> =</span> Integer</span>.</span>MAX_VALUE</span>,</span> max</span> =</span> Integer</span>.</span>MIN_VALUE</span>;</span>
        boolean</span> flag</span> =</span> false</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            if</span> (</span>nums</span>[</span>i</span>]</span> &lt;</span> nums</span>[</span>i</span> -</span> 1</span>])</span>
                flag</span> =</span> true</span>;</span>
            if</span> (</span>flag</span>)</span>
                min</span> =</span> Math</span>.</span>min</span>(</span>min</span>,</span> nums</span>[</span>i</span>]);</span>
        }</span>
        flag</span> =</span> false</span>;</span>
        for</span> (</span>int</span> i</span> =</span> nums</span>.</span>length</span> -</span> 2</span>;</span> i</span> &gt;=</span> 0</span>;</span> i</span>--)</span> {</span>
            if</span> (</span>nums</span>[</span>i</span>]</span> &gt;</span> nums</span>[</span>i</span> +</span> 1</span>])</span>
                flag</span> =</span> true</span>;</span>
            if</span> (</span>flag</span>)</span>
                max</span> =</span> Math</span>.</span>max</span>(</span>max</span>,</span> nums</span>[</span>i</span>]);</span>
        }</span>
        int</span> l</span>,</span> r</span>;</span>
        for</span> (</span>l</span> =</span> 0</span>;</span> l</span> &lt;</span> nums</span>.</span>length</span>;</span> l</span>++)</span> {</span>
            if</span> (</span>min</span> &lt;</span> nums</span>[</span>l</span>])</span>
                break</span>;</span>
        }</span>
        for</span> (</span>r</span> =</span> nums</span>.</span>length</span> -</span> 1</span>;</span> r</span> &gt;=</span> 0</span>;</span> r</span>--)</span> {</span>
            if</span> (</span>max</span> &gt;</span> nums</span>[</span>r</span>])</span>
                break</span>;</span>
        }</span>
        return</span> r</span> -</span> l</span> &lt;</span> 0</span> ?</span> 0</span> :</span> r</span> -</span> l</span> +</span> 1</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Four <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> loops are used.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>