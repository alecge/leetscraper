<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>
<a href="#approach-2-using-recursion-with-memoization-accepted">Approach #2 Using Recursion with memoization [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>
Algorithm</strong></p>
Before discussing the steps involved in the process, we need to note a few points. Firstly, whenever an offer is used from amongst the ones available in the <span class="maths katex-rendered">s</mi>p</mi>e</mi>c</mi>i</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">special</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">p</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> list, we need to update the <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> appropriately, such that the number of items in the current offer of each type are deducted from the ones in the corresponding entry in <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span>.</p>
Further, an offer can be used only if the number of items, of each type, required for using the offer, is lesser than or equal to the ones available in the current <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span>. </p>
Now, let's discuss the algorithm. We make use of a shopping(price,special,needs)</code> function, which takes the <span class="maths katex-rendered">p</mi>r</mi>i</mi>c</mi>e</mi></mrow><annotation encoding="application/x-tex">price</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">e</span></span></span></span></span> and <span class="maths katex-rendered">s</mi>p</mi>e</mi>c</mi>i</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">special</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">p</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> list along with the current(updated) <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> as the input and returns the minimum cost of buying these items as required by this <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> list. </p>
In every call of the function shopping(price,special,needs)</code>, we do as follows:</p>


Determine the cost of buying items as per the <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> array, without applying any offer. Store the result in <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span>.</p>
</li>

Iterate over every offer in the <span class="maths katex-rendered">s</mi>p</mi>e</mi>c</mi>i</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">special</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">p</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> list. For every offer chosen, repeat steps 3 to 5.</p>
</li>

Create a copy of the current <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> in a <span class="maths katex-rendered">c</mi>l</mi>o</mi>n</mi>e</mi></mrow><annotation encoding="application/x-tex">clone</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">e</span></span></span></span></span> list(so that the original needs can be used again, while selecting the next offer).</p>
</li>

Try to apply the current offer. If possible, update the required number of items in <span class="maths katex-rendered">c</mi>l</mi>o</mi>n</mi>e</mi></mrow><annotation encoding="application/x-tex">clone</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">e</span></span></span></span></span>.</p>
</li>

If the current offer could be applied, find the minimum cost out of <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">offer_current</span><script type="math/tex">offer_current</script></span> + shopping(price,special,clone)</code>. Here, <span class="maths katex-rendered">(offer_current)</span> refers to the price that needs to be paid for the current offer. Update the <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> with the minimum value.</p>
</li>

Return the <span class="maths katex-rendered">r</mi>e</mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></span> corresponding to the minimum cost.</p>
</li>
</ol>
We need to note that the <span class="maths katex-rendered">c</mi>l</mi>o</mi>n</mi>e</mi></mrow><annotation encoding="application/x-tex">clone</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">e</span></span></span></span></span> needs to be updated afresh from <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span>(coming to the current function call) when we choose a new offer. This needs to be done, because solely applying the next offer could result in a lesser cost than the one resulting by using the previous offer first.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> shoppingOffers</span>(</span>List</span> &lt;</span> Integer</span> &gt;</span> price</span>,</span> List</span> &lt;</span> List</span> &lt;</span> Integer</span> &gt;&gt;</span> special</span>,</span> List</span> &lt;</span> Integer</span> &gt;</span> needs</span>)</span> {</span>
        return</span> shopping</span>(</span>price</span>,</span> special</span>,</span> needs</span>);</span>
    }</span>
    public</span> int</span> shopping</span>(</span>List</span> &lt;</span> Integer</span> &gt;</span> price</span>,</span> List</span> &lt;</span> List</span> &lt;</span> Integer</span> &gt;&gt;</span> special</span>,</span> List</span> &lt;</span> Integer</span> &gt;</span> needs</span>)</span> {</span>
        int</span> j</span> =</span> 0</span>,</span> res</span> =</span> dot</span>(</span>needs</span>,</span> price</span>);</span>
        for</span> (</span>List</span> &lt;</span> Integer</span> &gt;</span> s</span>:</span> special</span>)</span> {</span>
            ArrayList</span> &lt;</span> Integer</span> &gt;</span> clone</span> =</span> new</span> ArrayList</span> &lt;</span> &gt;</span> (</span>needs</span>);</span>
            for</span> (</span>j</span> =</span> 0</span>;</span> j</span> &lt;</span> needs</span>.</span>size</span>();</span> j</span>++)</span> {</span>
                int</span> diff</span> =</span> clone</span>.</span>get</span>(</span>j</span>)</span> -</span> s</span>.</span>get</span>(</span>j</span>);</span>
                if</span> (</span>diff</span> &lt;</span> 0</span>)</span>
                    break</span>;</span>
                clone</span>.</span>set</span>(</span>j</span>,</span> diff</span>);</span>
            }</span>
            if</span> (</span>j</span> ==</span> needs</span>.</span>size</span>())</span>
                res</span> =</span> Math</span>.</span>min</span>(</span>res</span>,</span> s</span>.</span>get</span>(</span>j</span>)</span> +</span> shopping</span>(</span>price</span>,</span> special</span>,</span> clone</span>));</span>
        }</span>
        return</span> res</span>;</span>
    }</span>
    public</span> int</span> dot</span>(</span>List</span> &lt;</span> Integer</span> &gt;</span> a</span>,</span> List</span> &lt;</span> Integer</span> &gt;</span> b</span>)</span> {</span>
        int</span> sum</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> a</span>.</span>size</span>();</span> i</span>++)</span> {</span>
            sum</span> +=</span> a</span>.</span>get</span>(</span>i</span>)</span> *</span> b</span>.</span>get</span>(</span>i</span>);</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>

}</span>
</pre></div>



<h4 id="approach-2-using-recursion-with-memoization-accepted">Approach #2 Using Recursion with memoization [Accepted]</h4>
Algorithm</strong></p>
In the last approach, we can observe that the same <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> can be reached by applying the offers in various orders. e.g. We can choose the first offer followed by the second offer or vice-versa. But, both lead to the same requirement of updated <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> and the cost as well. Thus, instead of repeating the whole process for the same <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> state through various recursive paths, we can create an entry corresponding to the current set of <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span> in a HashMap, <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span>, which stores the minimum cost corresponding to this set of <span class="maths katex-rendered">n</mi>e</mi>e</mi>d</mi>s</mi></mrow><annotation encoding="application/x-tex">needs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">s</span></span></span></span></span>. Thus, whenever the same call is made again in the future through a different path, we need not repeat the whole process over, and we can directly return the result stored in the <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span>.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> shoppingOffers</span>(</span>List</span> &lt;</span> Integer</span> &gt;</span> price</span>,</span> List</span> &lt;</span> List</span> &lt;</span> Integer</span> &gt;&gt;</span> special</span>,</span> List</span> &lt;</span> Integer</span> &gt;</span> needs</span>)</span> {</span>
        Map</span> &lt;</span> List</span> &lt;</span> Integer</span> &gt;</span> ,</span> Integer</span> &gt;</span> map</span> =</span> new</span> HashMap</span>();</span>
        return</span> shopping</span>(</span>price</span>,</span> special</span>,</span> needs</span>,</span> map</span>);</span>
    }</span>
    public</span> int</span> shopping</span>(</span>List</span> &lt;</span> Integer</span> &gt;</span> price</span>,</span> List</span> &lt;</span> List</span> &lt;</span> Integer</span> &gt;&gt;</span> special</span>,</span> List</span> &lt;</span> Integer</span> &gt;</span> needs</span>,</span> Map</span> &lt;</span> List</span> &lt;</span> Integer</span> &gt;</span> ,</span> Integer</span> &gt;</span> map</span>)</span> {</span>
        if</span> (</span>map</span>.</span>containsKey</span>(</span>needs</span>))</span>
            return</span> map</span>.</span>get</span>(</span>needs</span>);</span>
        int</span> j</span> =</span> 0</span>,</span> res</span> =</span> dot</span>(</span>needs</span>,</span> price</span>);</span>
        for</span> (</span>List</span> &lt;</span> Integer</span> &gt;</span> s</span>:</span> special</span>)</span> {</span>
            ArrayList</span> &lt;</span> Integer</span> &gt;</span> clone</span> =</span> new</span> ArrayList</span> &lt;</span> &gt;</span> (</span>needs</span>);</span>
            for</span> (</span>j</span> =</span> 0</span>;</span> j</span> &lt;</span> needs</span>.</span>size</span>();</span> j</span>++)</span> {</span>
                int</span> diff</span> =</span> clone</span>.</span>get</span>(</span>j</span>)</span> -</span> s</span>.</span>get</span>(</span>j</span>);</span>
                if</span> (</span>diff</span> &lt;</span> 0</span>)</span>
                    break</span>;</span>
                clone</span>.</span>set</span>(</span>j</span>,</span> diff</span>);</span>
            }</span>
            if</span> (</span>j</span> ==</span> needs</span>.</span>size</span>())</span>
                res</span> =</span> Math</span>.</span>min</span>(</span>res</span>,</span> s</span>.</span>get</span>(</span>j</span>)</span> +</span> shopping</span>(</span>price</span>,</span> special</span>,</span> clone</span>,</span> map</span>));</span>
        }</span>
        map</span>.</span>put</span>(</span>needs</span>,</span> res</span>);</span>
        return</span> res</span>;</span>
    }</span>
    public</span> int</span> dot</span>(</span>List</span> &lt;</span> Integer</span> &gt;</span> a</span>,</span> List</span> &lt;</span> Integer</span> &gt;</span> b</span>)</span> {</span>
        int</span> sum</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> a</span>.</span>size</span>();</span> i</span>++)</span> {</span>
            sum</span> +=</span> a</span>.</span>get</span>(</span>i</span>)</span> *</span> b</span>.</span>get</span>(</span>i</span>);</span>
        }</span>
        return</span> sum</span>;</span>
    }</span>

}</span>
</pre></div>



Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>