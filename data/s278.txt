<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-linear-scan-time-limit-exceeded">Approach #1 (Linear Scan) [Time Limit Exceeded]</a></li>
<a href="#approach-2-binary-search-accepted">Approach #2 (Binary Search) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
This is a very simple problem. There is a subtle trap that you may fall into if you are not careful. Other than that, it is a direct application of a very famous algorithm.</p>
Solution</h2>

<h4 id="approach-1-linear-scan-time-limit-exceeded">Approach #1 (Linear Scan) [Time Limit Exceeded]</h4>
The straight forward way is to brute force it by doing a linear scan.</p>
</span>public</span> int</span> firstBadVersion</span>(</span>int</span> n</span>)</span> {</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++)</span> {</span>
        if</span> (</span>isBadVersion</span>(</span>i</span>))</span> {</span>
            return</span> i</span>;</span>
        }</span>
    }</span>
    return</span> n</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.
Assume that <span class="maths katex-rendered">i</mi>s</mi>B</mi>a</mi>d</mi>V</mi>e</mi>r</mi>s</mi>i</mi>o</mi>n</mi>(</mo>v</mi>e</mi>r</mi>s</mi>i</mi>o</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">isBadVersion(version)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right: 0.22222em;">V</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span>(</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span>)</span></span></span></span></span> takes constant time to check if a version</em> is bad. It takes at most <span class="maths katex-rendered">n</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>−</span><span class="mord mathrm">1</span></span></span></span></span> checks, therefore the overall time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>

<h4 id="approach-2-binary-search-accepted">Approach #2 (Binary Search) [Accepted]</h4>
It is not difficult to see that this could be solved using a classic algorithm - Binary search. Let us see how the search space could be halved each time below.</p>
</span>Scenario #1: isBadVersion(mid) =&gt; false

 1 2 3 4 5 6 7 8 9
 G G G G G G B B B       G = Good, B = Bad
 |       |       |
left    mid    right
</pre></div>


Let us look at the first scenario above where <span class="maths katex-rendered">i</mi>s</mi>B</mi>a</mi>d</mi>V</mi>e</mi>r</mi>s</mi>i</mi>o</mi>n</mi>(</mo>m</mi>i</mi>d</mi>)</mo>⇒</mo>f</mi>a</mi>l</mi>s</mi>e</mi></mrow><annotation encoding="application/x-tex">isBadVersion(mid) Rightarrow  false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right: 0.22222em;">V</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span>(</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span>)</span>⇒</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></span>. We know that all versions preceding and including <span class="maths katex-rendered">m</mi>i</mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span></span> are all good. So we set <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>=</mo>m</mi>i</mi>d</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">left = mid + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span>+</span><span class="mord mathrm">1</span></span></span></span></span> to indicate that the new search space is the interval <span class="maths katex-rendered">[</mo>m</mi>i</mi>d</mi>+</mo>1</mn>,</mo>r</mi>i</mi>g</mi>h</mi>t</mi>]</mo></mrow><annotation encoding="application/x-tex">[mid + 1, right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span>+</span><span class="mord mathrm">1</span>,</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span>]</span></span></span></span></span> (inclusive).</p>
</span>Scenario #2: isBadVersion(mid) =&gt; true

 1 2 3 4 5 6 7 8 9
 G G G B B B B B B       G = Good, B = Bad
 |       |       |
left    mid    right
</pre></div>


The only scenario left is where <span class="maths katex-rendered">i</mi>s</mi>B</mi>a</mi>d</mi>V</mi>e</mi>r</mi>s</mi>i</mi>o</mi>n</mi>(</mo>m</mi>i</mi>d</mi>)</mo>⇒</mo>t</mi>r</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">isBadVersion(mid) Rightarrow true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right: 0.22222em;">V</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span>(</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span>)</span>⇒</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>. This tells us that <span class="maths katex-rendered">m</mi>i</mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span></span> may or may not be the first bad version, but we can tell for sure that all versions after <span class="maths katex-rendered">m</mi>i</mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span></span> can be discarded. Therefore we set <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>=</mo>m</mi>i</mi>d</mi></mrow><annotation encoding="application/x-tex">right = mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span>=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span></span> as the new search space of interval <span class="maths katex-rendered">[</mo>l</mi>e</mi>f</mi>t</mi>,</mo>m</mi>i</mi>d</mi>]</mo></mrow><annotation encoding="application/x-tex">[left,mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>,</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span>]</span></span></span></span></span> (inclusive).</p>
In our case, we indicate <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> as the boundary of our search space (both inclusive). This is why we initialize <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>=</mo>1</mn></mrow><annotation encoding="application/x-tex">left = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>=</span><span class="mord mathrm">1</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi>=</mo>n</mi></mrow><annotation encoding="application/x-tex">right = n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span>=</span><span class="mord mathit">n</span></span></span></span></span>. How about the terminating condition? We could guess that <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> eventually both meet and it must be the first bad version, but how could you tell for sure?</p>
The formal way is to <a href="http://www.cs.cornell.edu/courses/cs211/2006sp/Lectures/L06-Induction/binary_search.html">prove by induction</a>, which you can read up yourself if you are interested. Here is a helpful tip to quickly prove the correctness of your binary search algorithm
during an interview. We just need to test an input of size 2. Check if it reduces the search space to a single element (which must be the answer) for both of the scenarios above. If not, your algorithm will never terminate.</p>
If you are setting <span class="maths katex-rendered">m</mi>i</mi>d</mi>=</mo>l</mi>e</mi>f</mi>t</mi>+</mo>r</mi>i</mi>g</mi>h</mi>t</mi></mrow>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">mid = frac{left + right}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.932216em;"></span><span class="strut bottom" style="height: 1.27722em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span>=</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span><span class="mord mathit mtight">t</span><span class="mbin mtight">+</span><span class="mord mathit mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.03588em;">g</span><span class="mord mathit mtight">h</span><span class="mord mathit mtight">t</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span>, you have to be very careful. Unless you are using a language that does not overflow such as <a href="https://www.reddit.com/r/Python/comments/36xu5z/can_integer_operations_overflow_in_python/">Python</a>, <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>+</mo>r</mi>i</mi>g</mi>h</mi>t</mi></mrow><annotation encoding="application/x-tex">left + right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>+</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span></span></span></span></span> could overflow. One way to fix this is to use <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi>+</mo>r</mi>i</mi>g</mi>h</mi>t</mi>−</mo>l</mi>e</mi>f</mi>t</mi></mrow>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">left + frac{right - left}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.932216em;"></span><span class="strut bottom" style="height: 1.27722em; vertical-align: -0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">t</span>+</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.446108em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight" style="margin-right: 0.03588em;">g</span><span class="mord mathit mtight">h</span><span class="mord mathit mtight">t</span><span class="mbin mtight">−</span><span class="mord mathit mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span><span class="mord mathit mtight">t</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span> instead.</p>
If you fall into this subtle overflow bug, you are not alone. Even Jon Bentley's own implementation of binary search had this <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm#Implementation_issues">overflow bug</a> and remained undetected for over twenty years.</p>
</span>public</span> int</span> firstBadVersion</span>(</span>int</span> n</span>)</span> {</span>
    int</span> left</span> =</span> 1</span>;</span>
    int</span> right</span> =</span> n</span>;</span>
    while</span> (</span>left</span> &lt;</span> right</span>)</span> {</span>
        int</span> mid</span> =</span> left</span> +</span> (</span>right</span> -</span> left</span>)</span> /</span> 2</span>;</span>
        if</span> (</span>isBadVersion</span>(</span>mid</span>))</span> {</span>
            right</span> =</span> mid</span>;</span>
        }</span> else</span> {</span>
            left</span> =</span> mid</span> +</span> 1</span>;</span>
        }</span>
    }</span>
    return</span> left</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span>.
The search space is halved each time, so the time complexity is <span class="maths katex-rendered">O</mi>(</mo>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>
</ul>