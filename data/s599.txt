<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-using-recursiondfs-accepted">Approach #1 Using Recursion(DFS) [Accepted]</a></li>
<a href="#approach-2-using-stackdfs-accepted">Approach #2 Using stack(DFS) [Accepted]</a></li>
<a href="#approach-3-using-queuebfs-accepted">Approach #3 Using queue(BFS) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-using-recursiondfs-accepted">Approach #1 Using Recursion(DFS) [Accepted]</h4>
If the given depth <span class="maths katex-rendered">d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span></span> happens to be equal to 1, we can directly put the whole current tree as a left child of the newly added node. Otherwise, we need to put the new node at appropriate levels. </p>
To do so, we make use of a recursive function insert(val,node,depth,n)</code>. Here, <span class="maths katex-rendered">v</mi>a</mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span> refers to the value of the new node to be inserted, <span class="maths katex-rendered">d</mi>e</mi>p</mi>t</mi>h</mi></mrow><annotation encoding="application/x-tex">depth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">h</span></span></span></span></span> refers to the depth of the node currently considered, <span class="maths katex-rendered">n</mi>o</mi>d</mi>e</mi></mrow><annotation encoding="application/x-tex">node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span></span> refers to the node calling the current function for its child subtrees and <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> refers to the height at which the new node needs to be inserted. </p>
For inserting the new node at appropriate level, we can start by making a call to insert</code> with the root node and 1 as the current level. Inside every such call, we check if we've reached one level prior to the level where the new node needs to be inserted. </p>
From this level, we can store the roots of the left and right subtrees of the current node temporarily, and insert the new node as the new left and right subchild of the current node, with the temporarily stored left and right subtrees as the left and right subtrees of the newly inserted left or right subchildren appropriately.</p>
But, if we haven't reached the destined level, we keep on continuing the recursive calling process with the left and right children of the current node respectively. At every such call, we also incrmenet the depth of the current level to reflect the depth change appropriately.</p>
The animation below illustrates the process:</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 16</div></div></div>
Java</strong></p>
</span>/**</span>
 * Definition for a binary tree node.</span>
 * public class TreeNode {</span>
 *     int val;</span>
 *     TreeNode left;</span>
 *     TreeNode right;</span>
 *     TreeNode(int x) { val = x; }</span>
 * }</span>
 */</span>
public</span> class</span> Solution</span> {</span>
    public</span> TreeNode</span> addOneRow</span>(</span>TreeNode</span> t</span>,</span> int</span> v</span>,</span> int</span> d</span>)</span> {</span>
        if</span> (</span>d</span> ==</span> 1</span>)</span> {</span>
            TreeNode</span> n</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
            n</span>.</span>left</span> =</span> t</span>;</span>
            return</span> n</span>;</span>
        }</span>
        insert</span>(</span>v</span>,</span> t</span>,</span> 1</span>,</span> d</span>);</span>
        return</span> t</span>;</span>
    }</span>

    public</span> void</span> insert</span>(</span>int</span> val</span>,</span> TreeNode</span> node</span>,</span> int</span> depth</span>,</span> int</span> n</span>)</span> {</span>
        if</span> (</span>node</span> ==</span> null</span>)</span>
            return</span>;</span>
        if</span> (</span>depth</span> ==</span> n</span> -</span> 1</span>)</span> {</span>
            TreeNode</span> t</span> =</span> node</span>.</span>left</span>;</span>
            node</span>.</span>left</span> =</span> new</span> TreeNode</span>(</span>val</span>);</span>
            node</span>.</span>left</span>.</span>left</span> =</span> t</span>;</span>
            t</span> =</span> node</span>.</span>right</span>;</span>
            node</span>.</span>right</span> =</span> new</span> TreeNode</span>(</span>val</span>);</span>
            node</span>.</span>right</span>.</span>right</span> =</span> t</span>;</span>
        }</span> else</span> {</span>
            insert</span>(</span>val</span>,</span> node</span>.</span>left</span>,</span> depth</span> +</span> 1</span>,</span> n</span>);</span>
            insert</span>(</span>val</span>,</span> node</span>.</span>right</span>,</span> depth</span> +</span> 1</span>,</span> n</span>);</span>
        }</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. A total of <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes of the given tree will be considered.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the recursion tree can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> in the worst case(skewed tree).</p>
</li>
</ul>

<h4 id="approach-2-using-stackdfs-accepted">Approach #2 Using stack(DFS) [Accepted]</h4>
Algorithm</strong></p>
We can do the same task as discussed in the last approach by making use of a <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> as well. But, we need to make use of a new data structure, <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span></span> here, to keep a track of the depth of the current node along with its value. </p>
We start by pushing the root <span class="maths katex-rendered">N</mi>o</mi>d</mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span></span> onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. Then, at every step we do as follows:</p>


Pop an element from the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. </p>
</li>

For every Node popped, check if its depth corresponds to one prior to the depth at which the new node needs to be inserted. </p>
</li>

If yes, insert the new nodes appropriately as in the last approach. </p>
</li>

If no, we push both the left and the right child Node(value+depth) of the current node onto the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. </p>
</li>

Continue the popping and pushing process till the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> becomes empty.</p>
</li>
</ul>
Look at the animation below for a better understanding.</p>
!?!../Documents/623_Add_One_Row_Stack_new.json:1000,563!?!</p>
Java</strong></p>
</span>/**</span>
 * Definition for a binary tree node.</span>
 * public class TreeNode {</span>
 *     int val;</span>
 *     TreeNode left;</span>
 *     TreeNode right;</span>
 *     TreeNode(int x) { val = x; }</span>
 * }</span>
 */</span>
public</span> class</span> Solution</span> {</span>
    class</span> Node</span>{</span>
        Node</span>(</span>TreeNode</span> n</span>,</span>int</span> d</span>){</span>
            node</span>=</span>n</span>;</span>
            depth</span>=</span>d</span>;</span>
        }</span>
        TreeNode</span> node</span>;</span>
        int</span> depth</span>;</span>
    }</span>
    public</span> TreeNode</span> addOneRow</span>(</span>TreeNode</span> t</span>,</span> int</span> v</span>,</span> int</span> d</span>)</span> {</span>
        if</span> (</span>d</span> ==</span> 1</span>)</span> {</span>
            TreeNode</span> n</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
            n</span>.</span>left</span> =</span> t</span>;</span>
            return</span> n</span>;</span>
        }</span> 
        Stack</span>&lt;</span>Node</span>&gt;</span> stack</span>=</span>new</span> Stack</span>&lt;&gt;();</span>
        stack</span>.</span>push</span>(</span>new</span> Node</span>(</span>t</span>,</span>1</span>));</span>
        while</span>(!</span>stack</span>.</span>isEmpty</span>())</span>
        {</span>
            Node</span> n</span>=</span>stack</span>.</span>pop</span>();</span>
            if</span>(</span>n</span>.</span>node</span>==</span>null</span>)</span>
                continue</span>;</span>
            if</span> (</span>n</span>.</span>depth</span> ==</span> d</span> -</span> 1</span> )</span> {</span>
                TreeNode</span> temp</span> =</span> n</span>.</span>node</span>.</span>left</span>;</span>
                n</span>.</span>node</span>.</span>left</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
                n</span>.</span>node</span>.</span>left</span>.</span>left</span> =</span> temp</span>;</span>
                temp</span> =</span> n</span>.</span>node</span>.</span>right</span>;</span>
                n</span>.</span>node</span>.</span>right</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
                n</span>.</span>node</span>.</span>right</span>.</span>right</span> =</span> temp</span>;</span>

            }</span> else</span>{</span>
                stack</span>.</span>push</span>(</span>new</span> Node</span>(</span>n</span>.</span>node</span>.</span>left</span>,</span> n</span>.</span>depth</span> +</span> 1</span>));</span>
                stack</span>.</span>push</span>(</span>new</span> Node</span>(</span>n</span>.</span>node</span>.</span>right</span>,</span> n</span>.</span>depth</span> +</span> 1</span>));</span>
            }</span>
        }</span>
        return</span> t</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. A total of <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes of the given tree will be considered.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The depth of the <span class="maths katex-rendered">s</mi>t</mi>a</mi>c</mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> can go upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> in the worst case(skewed tree).</p>
</li>
</ul>

<h4 id="approach-3-using-queuebfs-accepted">Approach #3 Using queue(BFS) [Accepted]</h4>
Algorithm</strong></p>
The idea of traversal in the last approach is similar to Depth First Search. In that case, we need to traverse through all the nodes of the given tree in the order of branches. Firstly we explored one branch to as much depth as possible and then continued with the other ones. </p>
If, instead, we go for Breadth First Search, along with keeping track of the depth of the nodes being considered at any moment during the Breadth First Search, we can stop the search process as soon as all the nodes at the depth <span class="maths katex-rendered">d</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">d - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span>−</span><span class="mord mathrm">1</span></span></span></span></span> have been considered once. </p>
To implement this BFS, we make use of a <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>. We start off by pushing the root node of the given tree at the back of the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> and with the depth of the current level set as 1. Then, at every step, we do the following:</p>


Remove an element from the front of the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> and add all its children to the back of another temporary queue, <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span>. </p>
</li>

Keep on adding the elements to the back of the <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> till <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> becomes empty. (Once <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> becomes empty, it indicates that all the nodes at the current level have been considered and now <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> contains all the nodes lying at the next level).</p>
</li>

Reinitialize <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span>  with its value as <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span>. Update the current value of the <span class="maths katex-rendered">d</mi>e</mi>p</mi>t</mi>h</mi></mrow><annotation encoding="application/x-tex">depth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">h</span></span></span></span></span> to reflect the level of nodes currently being considered. </p>
</li>

Repeat the process till we reach the depth <span class="maths katex-rendered">d</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">d - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span>−</span><span class="mord mathrm">1</span></span></span></span></span>. </p>
</li>

On hitting this depth level(<span class="maths katex-rendered">d</mi>−</mo>1</mn></mrow><annotation encoding="application/x-tex">d-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span>−</span><span class="mord mathrm">1</span></span></span></span></span>), add the new nodes appropriately to all the nodes in the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> currently, as done in the previous approaches.</p>
</li>
</ul>
The following animation illustrates the process.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 13</div></div></div>
Java</strong></p>
</span>/**</span>
 * Definition for a binary tree node.</span>
 * public class TreeNode {</span>
 *     int val;</span>
 *     TreeNode left;</span>
 *     TreeNode right;</span>
 *     TreeNode(int x) { val = x; }</span>
 * }</span>
 */</span>
public</span> class</span> Solution</span> {</span>
    public</span> TreeNode</span> addOneRow</span>(</span>TreeNode</span> t</span>,</span> int</span> v</span>,</span> int</span> d</span>)</span> {</span>
        if</span> (</span>d</span> ==</span> 1</span>)</span> {</span>
            TreeNode</span> n</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
            n</span>.</span>left</span> =</span> t</span>;</span>
            return</span> n</span>;</span>
        }</span>
        Queue</span> &lt;</span> TreeNode</span> &gt;</span> queue</span> =</span> new</span> LinkedList</span> &lt;</span> &gt;</span> ();</span>
        queue</span>.</span>add</span>(</span>t</span>);</span>
        int</span> depth</span> =</span> 1</span>;</span>
        while</span> (</span>depth</span> &lt;</span> d</span> -</span> 1</span>)</span> {</span>
            Queue</span> &lt;</span> TreeNode</span> &gt;</span> temp</span> =</span> new</span> LinkedList</span> &lt;</span> &gt;</span> ();</span>
            while</span> (!</span>queue</span>.</span>isEmpty</span>())</span> {</span>
                TreeNode</span> node</span> =</span> queue</span>.</span>remove</span>();</span>
                if</span> (</span>node</span>.</span>left</span> !=</span> null</span>)</span> temp</span>.</span>add</span>(</span>node</span>.</span>left</span>);</span>
                if</span> (</span>node</span>.</span>right</span> !=</span> null</span>)</span> temp</span>.</span>add</span>(</span>node</span>.</span>right</span>);</span>
            }</span>
            queue</span> =</span> temp</span>;</span>
            depth</span>++;</span>
        }</span>
        while</span> (!</span>queue</span>.</span>isEmpty</span>())</span> {</span>
            TreeNode</span> node</span> =</span> queue</span>.</span>remove</span>();</span>
            TreeNode</span> temp</span> =</span> node</span>.</span>left</span>;</span>
            node</span>.</span>left</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
            node</span>.</span>left</span>.</span>left</span> =</span> temp</span>;</span>
            temp</span> =</span> node</span>.</span>right</span>;</span>
            node</span>.</span>right</span> =</span> new</span> TreeNode</span>(</span>v</span>);</span>
            node</span>.</span>right</span>.</span>right</span> =</span> temp</span>;</span>
        }</span>
        return</span> t</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. A total of <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> nodes of the given tree will be considered in the worst case.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>x</mi>)</mo></mrow><annotation encoding="application/x-tex">O(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">x</span>)</span></span></span></span></span>. The size of the <span class="maths katex-rendered">q</mi>u</mi>e</mi>u</mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">q</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></span> or <span class="maths katex-rendered">t</mi>e</mi>m</mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">p</span></span></span></span></span> queue can grow upto <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> only. Here, <span class="maths katex-rendered">x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span></span> refers to the number of maximum number of nodes at any level in the given tree.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>