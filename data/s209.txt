<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>
<a href="#approach-2-a-better-brute-force-accepted">Approach #2 A better brute force [Accepted]</a></li>
<a href="#approach-3-using-binary-search-accepted">Approach #3 Using Binary search [Accepted]</a></li>
<a href="#approach-4-using-2-pointers-accepted">Approach #4 Using 2 pointers [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>
Intuition</strong></p>
Do as directed in question. Find the sum for all the possible subarrays and update the <span class="maths katex-rendered">a</mi>n</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">ans</span></span></span></span></span></span> as and when we get a better subarray that fulfill the requirements (<span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext>≥</mo>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum} geq text{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.63597em;"></span><span class="strut bottom" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span>≥</span><span class="mord text textstyle uncramped"><span class="mord mathrm">s</span></span></span></span></span></span>).</p>
Algorithm</strong></p>

Initialize <span class="maths katex-rendered">text{ans}=text{INT_MAX}</span><script type="math/tex">text{ans}=text{INT_MAX}</script></span>
</li>
Iterate the array from left to right using <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>:
Iterate from the current element to the end of vector using <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>:
Find the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span> of elements from index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>
</li>
If sum is greater then <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>:
Update <span class="maths katex-rendered">a</mi>n</mi>s</mi></mtext>=</mo>min</mi>(</mo>a</mi>n</mi>s</mi></mtext>,</mo>(</mo>j</mi>−</mo>i</mi>+</mo>1</mn>)</mo>)</mo></mrow><annotation encoding="application/x-tex">text{ans} = min(text{ans}, (j - i + 1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">ans</span></span>=</span>min</span>(</span><span class="mord text textstyle uncramped"><span class="mord mathrm">ans</span></span>,</span>(</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>−</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>)</span>)</span></span></span></span></span>
</li>
Start the next <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>th iteration, since, we got the smallest subarray with <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext>≥</mo>s</mi></mrow><annotation encoding="application/x-tex">text{sum} geq s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.63597em;"></span><span class="strut bottom" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span>≥</span><span class="mord mathit">s</span></span></span></span></span> starting from the current index.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>int</span> minSubArrayLen</span>(</span>int</span> s</span>,</span> vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    int</span> ans</span> =</span> INT_MAX</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        for</span> (</span>int</span> j</span> =</span> i</span>;</span> j</span> &lt;</span> n</span>;</span> j</span>++</span>)</span> {</span>
            int</span> sum</span> =</span> 0</span>;</span>
            for</span> (</span>int</span> k</span> =</span> i</span>;</span> k</span> &lt;=</span> j</span>;</span> k</span>++</span>)</span> {</span>
                sum</span> +=</span> nums</span>[</span>k</span>];</span>
            }</span>
            if</span> (</span>sum</span> &gt;=</span> s</span>)</span> {</span>
                ans</span> =</span> min</span>(</span>ans</span>,</span> (</span>j</span> -</span> i</span> +</span> 1</span>));</span>
                break</span>;</span> //Found the smallest subarray with sum&gt;=s starting with index i, hence move to next index</span>
            }</span>
        }</span>
    }</span>
    return</span> (</span>ans</span> !=</span> INT_MAX</span>)</span> ?</span> ans</span> :</span> 0</span>;</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</p>

For each element of array, we find all the subarrays starting from that index which is <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</li>
Time complexity to find the sum of each subarray is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.</li>
Thus, the total time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>∗</mo>n</mi>)</mo>=</mo>O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2 * n) = O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>∗</span><span class="mord mathit">n</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>
</li>
</ul>
</li>

Space complexity: <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> extra space.</p>
</li>
</ul>

<h4 id="approach-2-a-better-brute-force-accepted">Approach #2 A better brute force [Accepted]</h4>
Intuition</strong></p>
In Approach #1, you may notice that the sum is calculated for every surarray in <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time. But, we could easily find the sum in O(1) time by storing the cumulative sum from the beginning(Memoization). After we have stored the cumulative sum in <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span>, we could easily find the sum of any subarray from <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>.</p>
Algorithm</strong></p>

The algorithm is similar to Approach #1.</li>
The only difference is in the way of finding the sum of subarrays:
Create a vector <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span> of size of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span></span></span></span></span>
</li>
Initialize <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext>[</mo>0</mn>]</mo>=</mo>n</mi>u</mi>m</mi>s</mi></mtext>[</mo>0</mn>]</mo></mrow><annotation encoding="application/x-tex">text{sums}[0]=text{nums}[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathrm">0</span>]</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>[</span><span class="mord mathrm">0</span>]</span></span></span></span></span>
</li>
Iterate over the <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span> vector:
Update <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo>=</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>n</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">text{sums}[i] = text{sums}[i-1] + text{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>
</li>
</ul>
</li>
Sum of subarray from <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> is calculated as:
<span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext>=</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>j</mi>]</mo>−</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo>+</mo>n</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">text{sum}=text{sums}[j] - text{sums}[i] +text{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>]</span>+</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>, , wherein <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext>[</mo>j</mi>]</mo>−</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">text{sums}[j] - text{sums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> is the sum from (<span class="maths katex-rendered">i</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span></span></span></span></span>)th element to the <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span>th element.</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>int</span> minSubArrayLen</span>(</span>int</span> s</span>,</span> vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    if</span> (</span>n</span> ==</span> 0</span>)</span>
        return</span> 0</span>;</span>
    int</span> ans</span> =</span> INT_MAX</span>;</span>
    vector</span>&lt;</span>int</span>&gt;</span> sums</span>(</span>n</span>);</span>
    sums</span>[</span>0</span>]</span> =</span> nums</span>[</span>0</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span>
        sums</span>[</span>i</span>]</span> =</span> sums</span>[</span>i</span> -</span> 1</span>]</span> +</span> nums</span>[</span>i</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        for</span> (</span>int</span> j</span> =</span> i</span>;</span> j</span> &lt;</span> n</span>;</span> j</span>++</span>)</span> {</span>
            int</span> sum</span> =</span> sums</span>[</span>j</span>]</span> -</span> sums</span>[</span>i</span>]</span> +</span> nums</span>[</span>i</span>];</span>
            if</span> (</span>sum</span> &gt;=</span> s</span>)</span> {</span>
                ans</span> =</span> min</span>(</span>ans</span>,</span> (</span>j</span> -</span> i</span> +</span> 1</span>));</span>
                break</span>;</span> //Found the smallest subarray with sum&gt;=s starting with index i, hence move to next index</span>
            }</span>
        }</span>
    }</span>
    return</span> (</span>ans</span> !=</span> INT_MAX</span>)</span> ?</span> ans</span> :</span> 0</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>


Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</p>

Time complexity to find all the subarrays is <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>.</li>
Sum of the subarrays is calculated in <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> time.</li>
Thus, the total time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>∗</mo>1</mn>)</mo>=</mo>O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2 * 1) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>∗</span><span class="mord mathrm">1</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>
</li>
</ul>
</li>

Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> extra space.</p>

Additional <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> space for <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span> vector than in Approach #1.</li>
</ul>
</li>
</ul>

<h4 id="approach-3-using-binary-search-accepted">Approach #3 Using Binary search [Accepted]</h4>
Intuition</strong></p>
We could further improve the Approach #2 using the binary search. Notice that we find the subarray with <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext>&gt;</mo>=</mo>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum} &gt;=text{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.5391em;"></span><span class="strut bottom" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span>&gt;</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">s</span></span></span></span></span></span> starting with an index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> in <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time. But, we could reduce the time to <span class="maths katex-rendered">O</mi>(</mo>log</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> using binary search. Note that in Approach #2, we search for subarray starting with index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>, until we find <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext>=</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>j</mi>]</mo>−</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo>+</mo>n</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">text{sum}=text{sums}[j] - text{sums}[i] +text{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>−</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>]</span>+</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> that is greater than <span class="maths katex-rendered">s</mi></mtext></mrow><annotation encoding="application/x-tex">text{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">s</span></span></span></span></span></span>. So, instead of iterating linearly to find the sum, we could use binary search to find the index that is not lower than  <span class="maths katex-rendered">s</mi></mtext>−</mo>s</mi>u</mi>m</mi>s</mi>[</mi>i</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{s}-text{sums[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">s</span></span>−</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums[i]</span></span></span></span></span></span> in the <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span>, which can be done using <span class="maths katex-rendered">(text{lower_bound})</span> function in C++ STL or could be implemented manually.</p>
Algorithm</strong></p>


Create vector <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">sums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> with :
<span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext>[</mo>0</mn>]</mo>=</mo>0</mn>,</mi>&nbsp;</mtext></mtext>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo>=</mo>s</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>−</mo>1</mn>]</mo>+</mo>n</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>−</mo>1</mn>]</mo></mrow><annotation encoding="application/x-tex">text{sums}[0]=0text{, }text{sums}[i]=text{sums}[i-1]+text{nums}[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathrm">0</span>]</span>=</span><span class="mord mathrm">0</span><span class="mord text textstyle uncramped"><span class="mord mathrm">,&nbsp;</span></span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>]</span>=</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span>+</span><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>[</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>]</span></span></span></span></span>
</p>
</li>

Iterate from <span class="maths katex-rendered">i</mi>=</mo>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>=</span><span class="mord mathrm">1</span></span></span></span></span> to <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>:</p>

Find the value <span class="maths katex-rendered">(text{to_find})</span> in <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span> required for minimum subarray starting from index <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> to have sum greater than <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, that is:
<span class="maths katex-rendered">(text{to_find}=text{s}+text{sums}[i-1])</span>
</li>
Find the index in <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span> such that value at that index is not lower than the <span class="maths katex-rendered">(text{to_find})</span> value, say <span class="maths katex-rendered">b</mi>o</mi>u</mi>n</mi>d</mi></mtext></mrow><annotation encoding="application/x-tex">text{bound}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">bound</span></span></span></span></span></span>
</li>
If we find the <span class="maths katex-rendered">(text{to_find})</span> in <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span>, then:
Size of current subarray is given by:
  <span class="maths katex-rendered">b</mi>o</mi>u</mi>n</mi>d</mi></mtext>−</mo>(</mo>s</mi>u</mi>m</mi>s</mi>.</mi>b</mi>e</mi>g</mi>i</mi>n</mi></mtext>(</mo>)</mo>+</mo>i</mi>−</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">text{bound} - (text{sums.begin}()+i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">bound</span></span>−</span>(</span><span class="mord text textstyle uncramped"><span class="mord mathrm">sums.begin</span></span>(</span>)</span>+</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span></span></span></span></span>
</li>
Compare <span class="maths katex-rendered">a</mi>n</mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">s</span></span></span></span></span> with the current subarray size and store minimum in <span class="maths katex-rendered">a</mi>n</mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">s</span></span></span></span></span>
</li>
</ul>
</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>int</span> minSubArrayLen</span>(</span>int</span> s</span>,</span> vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    if</span> (</span>n</span> ==</span> 0</span>)</span>
        return</span> 0</span>;</span>
    int</span> ans</span> =</span> INT_MAX</span>;</span>
    vector</span>&lt;</span>int</span>&gt;</span> sums</span>(</span>n</span> +</span> 1</span>,</span> 0</span>);</span> //size = n+1 for easier calculations</span>
    //sums[0]=0 : Meaning that it is the sum of first 0 elements</span>
    //sums[1]=A[0] : Sum of first 1 elements</span>
    //ans so on...</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span>;</span> i</span>++</span>)</span>
        sums</span>[</span>i</span>]</span> =</span> sums</span>[</span>i</span> -</span> 1</span>]</span> +</span> nums</span>[</span>i</span> -</span> 1</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> n</span>;</span> i</span>++</span>)</span> {</span>
        int</span> to_find</span> =</span> s</span> +</span> sums</span>[</span>i</span> -</span> 1</span>];</span>
        auto</span> bound</span> =</span> lower_bound</span>(</span>sums</span>.</span>begin</span>(),</span> sums</span>.</span>end</span>(),</span> to_find</span>);</span>
        if</span> (</span>bound</span> !=</span> sums</span>.</span>end</span>())</span> {</span>
            ans</span> =</span> min</span>(</span>ans</span>,</span> static_cast</span>&lt;</span>int</span>&gt;</span>(</span>bound</span> -</span> (</span>sums</span>.</span>begin</span>()</span> +</span> i</span> -</span> 1</span>)));</span>
        }</span>
    }</span>
    return</span> (</span>ans</span> !=</span> INT_MAX</span>)</span> ?</span> ans</span> :</span> 0</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>log</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>.
For each element in the vector, find the subarray starting from that index, and having sum greater than <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> using binary search. Hence, the time required is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> for iteration over the vector and <span class="maths katex-rendered">O</mi>(</mo>log</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span>lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span> for finding the subarray for each index using binary search.</li>
Therefore, total time complexity = <span class="maths katex-rendered">O</mi>(</mo>n</mi>∗</mo>log</mi>(</mo>n</mi>)</mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>∗</span>lo<span style="margin-right: 0.01389em;">g</span></span>(</span><span class="mord mathit">n</span>)</span>)</span></span></span></span></span>
</li>
</ul>
</li>
Space complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Additional <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> space for <span class="maths katex-rendered">s</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{sums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sums</span></span></span></span></span></span> vector</li>
</ul>

<h4 id="approach-4-using-2-pointers-accepted">Approach #4 Using 2 pointers [Accepted]</h4>
Intuition</strong></p>
Until now, we have kept the starting index of subarray fixed, and found the last position. Instead, we could move the starting index of the current subarray as soon as we know that no better could be done with this index as the starting index. We could keep 2 pointer,one for the start and another for the end of the current subarray, and make optimal moves so as to keep the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span> greater than <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> as well as maintain the lowest size possible.</p>
Algorithm</strong></p>

Initialize <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span> pointer to 0 and <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span> to 0</li>
Iterate over the <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span></span></span></span></span>:
Add <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mtext>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">text{nums}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums</span></span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> to <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span>
</li>
While <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span> is greater than or equal to <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>:
Update <span class="maths katex-rendered">a</mi>n</mi>s</mi></mtext>=</mo>min</mi>(</mo>a</mi>n</mi>s</mi></mtext>,</mo>i</mi>+</mo>1</mn>−</mo>l</mi>e</mi>f</mi>t</mi></mtext>)</mo></mrow><annotation encoding="application/x-tex">text{ans}=min(text{ans},i+1-text{left})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">ans</span></span>=</span>min</span>(</span><span class="mord text textstyle uncramped"><span class="mord mathrm">ans</span></span>,</span><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>−</span><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span>)</span></span></span></span></span>, where <span class="maths katex-rendered">i</mi>+</mo>1</mn>−</mo>l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">i+1-text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span>+</span><span class="mord mathrm">1</span>−</span><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span> is the size of current subarray</li>
It means that the first index can safely be incremented, since, the minimum subarray starting with this index with <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext>≥</mo>s</mi></mrow><annotation encoding="application/x-tex">text{sum} geq s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.63597em;"></span><span class="strut bottom" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span>≥</span><span class="mord mathit">s</span></span></span></span></span> has been achieved</li>
Subtract <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mi>l</mi>e</mi>f</mi>t</mi>]</mi></mtext></mrow><annotation encoding="application/x-tex">text{nums[left]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">nums[left]</span></span></span></span></span></span> from <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span> and increment <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span>
</li>
</ul>
</li>
</ul>
</li>
</ul>
C++</strong></p>
</span>int</span> minSubArrayLen</span>(</span>int</span> s</span>,</span> vector</span>&lt;</span>int</span>&gt;&amp;</span> nums</span>)</span>
{</span>
    int</span> n</span> =</span> nums</span>.</span>size</span>();</span>
    int</span> ans</span> =</span> INT_MAX</span>;</span>
    int</span> left</span> =</span> 0</span>;</span>
    int</span> sum</span> =</span> 0</span>;</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> n</span>;</span> i</span>++</span>)</span> {</span>
        sum</span> +=</span> nums</span>[</span>i</span>];</span>
        while</span> (</span>sum</span> &gt;=</span> s</span>)</span> {</span>
            ans</span> =</span> min</span>(</span>ans</span>,</span> i</span> +</span> 1</span> -</span> left</span>);</span>
            sum</span> -=</span> nums</span>[</span>left</span>++</span>];</span>
        }</span>
    }</span>
    return</span> (</span>ans</span> !=</span> INT_MAX</span>)</span> ?</span> ans</span> :</span> 0</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>

Time complexity: <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Single iteration of <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.
Each element can be visited atmost twice, once by the right pointer(<span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>) and (atmost)once by the <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span> pointer.</li>
</ul>
</li>
Space complexity: <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> extra space. Only constant space required for <span class="maths katex-rendered">l</mi>e</mi>f</mi>t</mi></mtext></mrow><annotation encoding="application/x-tex">text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">left</span></span></span></span></span></span>, <span class="maths katex-rendered">s</mi>u</mi>m</mi></mtext></mrow><annotation encoding="application/x-tex">text{sum}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">sum</span></span></span></span></span></span>, <span class="maths katex-rendered">a</mi>n</mi>s</mi></mtext></mrow><annotation encoding="application/x-tex">text{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord text textstyle uncramped"><span class="mord mathrm">ans</span></span></span></span></span></span> and <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>.</li>
</ul>

Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>