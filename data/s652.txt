<div class="toc hide">

<a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>
<a href="#approach-2-prefix-hashmap-accepted">Approach #2: Prefix Hashmap [Accepted]</a></li>
<a href="#approach-3-trie-accepted">Approach #3: Trie [Accepted]</a></li>
</ul>
</div>
<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>
Intuition and Algorithm</strong></p>
For each key in the map, if that key starts with the given prefix, then add it to the answer.</p>
Python</strong></p>
</span>class</span> MapSum</span>(</span>object</span>):</span>
    def</span> __init__</span>(</span>self</span>):</span>
        self</span>.</span>map</span> =</span> {}</span>

    def</span> insert</span>(</span>self</span>,</span> key</span>,</span> val</span>):</span>
        self</span>.</span>map</span>[</span>key</span>]</span> =</span> val</span>

    def</span> sum</span>(</span>self</span>,</span> prefix</span>):</span>
        return</span> sum</span>(</span>val</span> for</span> key</span>,</span> val</span> in</span> self</span>.</span>map</span>.</span>items</span>()</span>
                   if</span> key</span>.</span>startswith</span>(</span>prefix</span>))</span>
</pre></div>


Java</strong></p>
</span>class</span> MapSum</span> {</span>
    HashMap</span>&lt;</span>String</span>,</span> Integer</span>&gt;</span> map</span>;</span>
    public</span> MapSum</span>()</span> {</span>
        map</span> =</span> new</span> HashMap</span>&lt;&gt;();</span>
    }</span>
    public</span> void</span> insert</span>(</span>String</span> key</span>,</span> int</span> val</span>)</span> {</span>
        map</span>.</span>put</span>(</span>key</span>,</span> val</span>);</span>
    }</span>
    public</span> int</span> sum</span>(</span>String</span> prefix</span>)</span> {</span>
        int</span> ans</span> =</span> 0</span>;</span>
        for</span> (</span>String</span> key</span>:</span> map</span>.</span>keySet</span>())</span> {</span>
            if</span> (</span>key</span>.</span>startsWith</span>(</span>prefix</span>))</span> {</span>
                ans</span> +=</span> map</span>.</span>get</span>(</span>key</span>);</span>
            }</span>
        }</span>
        return</span> ans</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Every insert operation is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.  Every sum operation is <span class="maths katex-rendered">O</mi>(</mo>N</mi>∗</mo>P</mi>)</mo></mrow><annotation encoding="application/x-tex">O(N * P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.10903em;">N</span>∗</span><span class="mord mathit" style="margin-right: 0.13889em;">P</span>)</span></span></span></span></span> where <span class="maths katex-rendered">N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the number of items in the map, and <span class="maths katex-rendered">P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">P</span></span></span></span></span> is the length of the input prefix.</p>
</li>

Space Complexity: The space used by map</code> is linear in the size of all input key</code> and val</code> values combined.</p>
</li>
</ul>

<h4 id="approach-2-prefix-hashmap-accepted">Approach #2: Prefix Hashmap [Accepted]</h4>
Intuition and Algorithm</strong></p>
We can remember the answer for all possible prefixes in a HashMap score</code>.  When we get a new (key, val)</code> pair, we update every prefix of key</code> appropriately: each prefix will be changed by delta = val - map[key]</code>, where map</code> is the previous associated value of key</code> (zero if undefined.)</p>
Python</strong></p>
</span>class</span> MapSum</span>(</span>object</span>):</span>
    def</span> __init__</span>(</span>self</span>):</span>
        self</span>.</span>map</span> =</span> {}</span>
        self</span>.</span>score</span> =</span> collections</span>.</span>Counter</span>()</span>

    def</span> insert</span>(</span>self</span>,</span> key</span>,</span> val</span>):</span>
        delta</span> =</span> val</span> -</span> self</span>.</span>map</span>.</span>get</span>(</span>key</span>,</span> 0</span>)</span>
        self</span>.</span>map</span>[</span>key</span>]</span> =</span> val</span>
        for</span> i</span> in</span> xrange</span>(</span>len</span>(</span>key</span>)</span> +</span> 1</span>):</span>
            prefix</span> =</span> key</span>[:</span>i</span>]</span>
            self</span>.</span>score</span>[</span>prefix</span>]</span> +=</span> delta</span>

    def</span> sum</span>(</span>self</span>,</span> prefix</span>):</span>
        return</span> self</span>.</span>score</span>[</span>prefix</span>]</span>
</pre></div>


Java</strong></p>
</span>class</span> MapSum</span> {</span>
    Map</span>&lt;</span>String</span>,</span> Integer</span>&gt;</span> map</span>;</span>
    Map</span>&lt;</span>String</span>,</span> Integer</span>&gt;</span> score</span>;</span>
    public</span> MapSum</span>()</span> {</span>
        map</span> =</span> new</span> HashMap</span>();</span>
        score</span> =</span> new</span> HashMap</span>();</span>
    }</span>
    public</span> void</span> insert</span>(</span>String</span> key</span>,</span> int</span> val</span>)</span> {</span>
        int</span> delta</span> =</span> val</span> -</span> map</span>.</span>getOrDefault</span>(</span>key</span>,</span> 0</span>);</span>
        map</span>.</span>put</span>(</span>key</span>,</span> val</span>);</span>
        String</span> prefix</span> =</span> ""</span>;</span>
        for</span> (</span>char</span> c</span>:</span> key</span>.</span>toCharArray</span>())</span> {</span>
            prefix</span> +=</span> c</span>;</span>
            score</span>.</span>put</span>(</span>prefix</span>,</span> score</span>.</span>getOrDefault</span>(</span>prefix</span>,</span> 0</span>)</span> +</span> delta</span>);</span>
        }</span>
    }</span>
    public</span> int</span> sum</span>(</span>String</span> prefix</span>)</span> {</span>
        return</span> score</span>.</span>getOrDefault</span>(</span>prefix</span>,</span> 0</span>);</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Every insert operation is <span class="maths katex-rendered">O</mi>(</mo>K</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(K^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.07153em;">K</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>, where <span class="maths katex-rendered">K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">K</span></span></span></span></span> is the length of the key, as <span class="maths katex-rendered">K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">K</span></span></span></span></span> strings are made of an average length of <span class="maths katex-rendered">K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">K</span></span></span></span></span>.  Every sum operation is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.</p>
</li>

Space Complexity: The space used by map</code> and score</code> is linear in the size of all input key</code> and val</code> values combined.</p>
</li>
</ul>

<h4 id="approach-3-trie-accepted">Approach #3: Trie [Accepted]</h4>
Intuition and Algorithm</strong></p>
Since we are dealing with prefixes, a Trie (prefix tree) is a natural data structure to approach this problem.  For every node of the trie corresponding to some prefix, we will remember the desired answer (score) and store it at this node.  As in Approach #2</em>, this involves modifying each node by delta = val - map[key]</code>.</p>
Python</strong></p>
</span>class</span> TrieNode</span>(</span>object</span>):</span>
    __slots__</span> =</span> 'children'</span>,</span> 'score'</span>
    def</span> __init__</span>(</span>self</span>):</span>
        self</span>.</span>children</span> =</span> {}</span>
        self</span>.</span>score</span> =</span> 0</span>

class</span> MapSum</span>(</span>object</span>):</span>
    def</span> __init__</span>(</span>self</span>):</span>
        self</span>.</span>map</span> =</span> {}</span>
        self</span>.</span>root</span> =</span> TrieNode</span>()</span>

    def</span> insert</span>(</span>self</span>,</span> key</span>,</span> val</span>):</span>
        delta</span> =</span> val</span> -</span> self</span>.</span>map</span>.</span>get</span>(</span>key</span>,</span> 0</span>)</span>
        self</span>.</span>map</span>[</span>key</span>]</span> =</span> val</span>
        cur</span> =</span> self</span>.</span>root</span>
        cur</span>.</span>score</span> +=</span> delta</span>
        for</span> char</span> in</span> key</span>:</span>
            cur</span> =</span> cur</span>.</span>children</span>.</span>setdefault</span>(</span>char</span>,</span> TrieNode</span>())</span>
            cur</span>.</span>score</span> +=</span> delta</span>

    def</span> sum</span>(</span>self</span>,</span> prefix</span>):</span>
        cur</span> =</span> self</span>.</span>root</span>
        for</span> char</span> in</span> prefix</span>:</span>
            if</span> char</span> not</span> in</span> cur</span>.</span>children</span>:</span>
                return</span> 0</span>
            cur</span> =</span> cur</span>.</span>children</span>[</span>char</span>]</span>
        return</span> cur</span>.</span>score</span>
</pre></div>


Java</strong></p>
</span>class</span> MapSum</span> {
    HashMap</span>&lt;String, Integer&gt;</span> map</span>;
    TrieNode</span> root</span>;
    public</span> MapSum</span>() {
        map</span> = new</span> HashMap</span>();
        root</span> = new</span> TrieNode</span>();
    }
    public</span> void</span> insert</span>(String</span> key</span>, int</span> val</span>) {
        int</span> delta</span> = val</span> - map</span>.getOrDefault</span>(key</span>, 0</span>);
        map</span>.put</span>(key</span>, val</span>);
        TrieNode</span> cur</span> = root</span>;
        cur</span>.score</span> += delta</span>;
        for</span> (char</span> c:</span> key</span>.toCharArray</span>()) {
            cur</span>.children</span>.putIfAbsent</span>(c</span>, new</span> TrieNode</span>());
            cur</span> = cur</span>.children</span>.get</span>(c</span>);
            cur</span>.score</span> += delta</span>;
        }
    }
    public</span> int</span> sum</span>(String</span> prefix</span>) {
        TrieNode</span> cur</span> = root</span>;
        for</span> (char</span> c:</span> prefix</span>.toCharArray</span>()) {
            cur</span> = cur</span>.children</span>.get</span>(c</span>);
            if</span> (cur</span> == null</span>) return</span> 0</span>;
        }
        return</span> cur</span>.score</span>;
    }
}
class</span> TrieNode</span> {
    Map</span>&lt;Character, TrieNode&gt;</span> children</span> = new</span> HashMap</span>();
    int</span> score</span>;
}
</pre></div>


Complexity Analysis</strong></p>


Time Complexity: Every insert operation is <span class="maths katex-rendered">O</mi>(</mo>K</mi>)</mo></mrow><annotation encoding="application/x-tex">O(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.07153em;">K</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">K</span></span></span></span></span> is the length of the key.  Every sum operation is <span class="maths katex-rendered">O</mi>(</mo>K</mi>)</mo></mrow><annotation encoding="application/x-tex">O(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.07153em;">K</span>)</span></span></span></span></span>.</p>
</li>

Space Complexity: The space used is linear in the size of the total input.</p>
</li>
</ul>