Solution
Approach #1 Using HashMap [Accepted]
In this approach, we compare every string in
list1
list1 and
list2
list2 by traversing over the whole list
list2
list2 for every string chosen from
list1
list1. We make use of a hashmap
map
map, which contains elements of the form
(sum : list_{sum})
(sum:list
sum
). Here,
sum
sum refers to the sum of indices of matching elements and
list_{sum}
list
sum
refers to the list of matching strings whose indices' sum equals
sum
sum.
Thus, while doing the comparisons, whenever a match between a string at
i^{th}
i
th
index of
list1
list1 and
j^{th}
j
th
index of
list2
list2 is found, we make an entry in the
map
map corresponding to the sum
i + j
i+j, if this entry isn't already present. If an entry with this sum already exists, we need to keep a track of all the strings which lead to the same index sum. Thus, we append the current string to the list of strings corresponding to sum
i + j
i+j.
At the end, we traverse over the keys of the
map
map and find out the list of strings corresponding to the key reprsenting the minimum sum.
Java
public class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
        HashMap < Integer, List < String >> map = new HashMap < > ();
        for (int i = 0; i < list1.length; i++) {
            for (int j = 0; j < list2.length; j++) {
                if (list1[i].equals(list2[j])) {
                    if (!map.containsKey(i + j))
                        map.put(i + j, new ArrayList < String > ());
                    map.get(i + j).add(list1[i]);
                }
            }
        }
        int min_index_sum = Integer.MAX_VALUE;
        for (int key: map.keySet())
            min_index_sum = Math.min(min_index_sum, key);
        String[] res = new String[map.get(min_index_sum).size()];
        return map.get(min_index_sum).toArray(res);
    }
}
Complexity Analysis
Time complexity :
O(l_1*l_2*x)
O(l
1
∗l
2
∗x). Every item of
list1
list1 is compared with all the items of
list2
list2.
l_1
l
1
and
l_2
l
2
are the lengths of
list1
list1 and
list2
list2 respectively. And
x
x refers to average string length.
Space complexity :
O(l_1*l_2*x)
O(l
1
∗l
2
∗x). In worst case all items of
list1
list1 and
list2
list2 are same. In that case, hashmap size grows upto
l_1*l_2*x
l
1
∗l
2
∗x, where
x
x refers to average string length.
Approach #2 Without Using HashMap [Accepted]
Algorithm
Another method could be to traverse over the various
sum
sum(index sum) values and determine if any such string exists in
list1
list1 and
list2
list2 such that the sum of its indices in the two lists equals
sum
sum.
Now, we know that the value of index sum,
sum
sum could range from 0 to
m + n - 1
m+n−1. Here,
m
m and
n
n refer to the length of lists
list1
list1 and
list2
list2 respectively. Thus, we choose every value of
sum
sum in ascending order. For every
sum
sum chosen, we iterate over
list1
list1. Suppose, currently the string at
i^{th}
i
th
index in
list1
list1 is being considered. Now, in order for the index sum
sum
sum to be the one corresponding to matching strings in
list1
list1 and
list2
list2, the string at index
j
j in
list2
list2 should match the string at index
i
i in
list1
list1, such that
sum = i + j
sum=i+j.
Or, stating in other terms, the string at index
j
j in
list2
list2 should be equal to the string at index
i
i in
list1
list1, such that
j = sum - i
j=sum−i. Thus, for a particular
sum
sum and
i
i(from
list1
list1), we can directly determine that we need to check the element at index
j= sum - i
j=sum−i in
list2
list2, instead of traversing over the whole
list2
list2.
Doing such checks/comparisons, iterate over all the indices of
list1
list1 for every
sum
sum value chosen. Whenver a match occurs between
list1
list1 and
list2
list2, we put the matching string in a list
res
res.
We do the same process of checking the strings for all the values of
sum
sum in ascending order. After completing every iteration over
list1
list1 for a particular
sum
sum, we check if the
res
res list is empty or not. If it is empty, we need to continue the process with the next
sum
sum value considered. If not, the current
res
res gives the required list with minimum index sum. This is because we are already considering the index sum values in ascending order. So, the first list to be found is the required resultant list.
The following example depicts the process:
1 / 14
Java
public class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
        List < String > res = new ArrayList < > ();
        for (int sum = 0; sum < list1.length + list2.length - 1; sum++) {
            for (int i = 0; i <= sum; i++) {
                if (i < list1.length && sum - i < list2.length && list1[i].equals(list2[sum - i]))
                    res.add(list1[i]);
            }
            if (res.size() > 0)
                break;
        }
        return res.toArray(new String[res.size()]);
    }
}
Complexity Analysis
Time complexity :
O((l_1+l_2)^2*x)
O((l
1
+l
2
)
2
∗x). There are two nested loops upto
l_1+l_2
l
1
+l
2
and string comparison takes
x
x time. Here,
x
x refers to the average string length.
Space complexity :
O(r*x)
O(r∗x).
res
res list is used to store the result. Assuming
r
r is the length of
res
res.
Approach #3 Using HashMap (linear) [Accepted]
We make use of a HashMap to solve the given problem in a different way in this approach. Firstly, we traverse over the whole
list1
list1 and create an entry for each element of
list1
list1 in a HashMap
map
map, of the form
(list[i], i)
(list[i],i). Here,
i
i refers to the index of the
i^{th}
i
th
element, and
list[i]
list[i] is the
i^{th}
i
th
element itself. Thus, we create a mapping from the elements of
list1
list1 to their indices.
Now, we traverse over
list2
list2. For every element ,
list2[j]
list2[j], of
list2
list2 encountered, we check if the same element already exists as a key in the
map
map. If so, it means that the element exists in both
list1
list1 and
list2
list2. Thus, we find out the sum of indices corresponding to this element in the two lists, given by
sum = map.get(list[j]) + j
sum=map.get(list[j])+j. If this
sum
sum is lesser than the minimum sum obtained till now, we update the resultant list to be returned,
res
res, with the element
list2[j]
list2[j] as the only entry in it.
If the
sum
sum is equal to the minimum sum obtained till now, we put an extra entry corresponding to the element
list2[j]
list2[j] in the
res
res list.
Below code is inspired by @cloud.runner
Java
public class Solution {
    public String[] findRestaurant(String[] list1, String[] list2) {
        HashMap < String, Integer > map = new HashMap < String, Integer > ();
        for (int i = 0; i < list1.length; i++)
            map.put(list1[i], i);
        List < String > res = new ArrayList < > ();
        int min_sum = Integer.MAX_VALUE, sum;
        for (int j = 0; j < list2.length && j <= min_sum; j++) {
            if (map.containsKey(list2[j])) {
                sum = j + map.get(list2[j]);
                if (sum < min_sum) {
                    res.clear();
                    res.add(list2[j]);
                    min_sum = sum;
                } else if (sum == min_sum)
                    res.add(list2[j]);
            }
        }
        return res.toArray(new String[res.size()]);
    }
}
Complexity Analysis
Time complexity :
O(l_1+l_2)
O(l
1
+l
2
). Every item of
list2
list2 is checked in a map of
list1
list1.
l_1
l
1
and
l_2
l
2
are the lengths of
list1
list1 and
list2
list2 respectively.
Space complexity :
O(l_1*x)
O(l
1
∗x). hashmap size grows upto
l_1*x
l
1
∗x, where
x
x refers to average string length.
Analysis written by: @vinod23