<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>
<a href="#approach-2-using-cummulative-sum-accepted">Approach #2 Using Cummulative sum [Accepted]</a></li>
<a href="#approach-3-without-space-accepted">Approach #3 Without space [Accepted]</a></li>
<a href="#approach-4-using-hashmap-accepted">Approach #4 Using hashmap [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>
Algorithm</strong></p>
The simplest method is to consider every possible subarray of the given <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array, find the sum of the elements of each of those subarrays and check for the equality of the sum obtained with the given <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>. Whenver the sum equals <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, we can increment the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> used to store the required result.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> subarraySum</span>(</span>int</span>[]</span> nums</span>,</span> int</span> k</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> start</span> =</span> 0</span>;</span> start</span> &lt;</span> nums</span>.</span>length</span>;</span> start</span>++)</span> {</span>
            for</span> (</span>int</span> end</span> =</span> start</span> +</span> 1</span>;</span> end</span> &lt;=</span> nums</span>.</span>length</span>;</span> end</span>++)</span> {</span>
                int</span> sum</span> =</span> 0</span>;</span>
                for</span> (</span>int</span> i</span> =</span> start</span>;</span> i</span> &lt;</span> end</span>;</span> i</span>++)</span>
                    sum</span> +=</span> nums</span>[</span>i</span>];</span>
                if</span> (</span>sum</span> ==</span> k</span>)</span>
                    count</span>++;</span>
            }</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Considering every possible subarray takes <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> time. For each of the subarray we calculate the sum taking <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> time in the worst case, taking a total of <span class="maths katex-rendered">O</mi>(</mo>n</mi>3</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> time.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

<h4 id="approach-2-using-cummulative-sum-accepted">Approach #2 Using Cummulative sum [Accepted]</h4>
Algorithm</strong></p>
Instead of determining the sum of elements everytime for every new subarray considered, we can make use of a cumulative sum array , <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>. Then, in order to calculate the sum of elements lying between two indices, we can subtract the cumulative sum corresponding to the two indices to obtain the sum directly, instead of iterating over the subarray to obtain the sum.</p>
In this implementation, we make use of a cumulative sum array, <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span>, such that <span class="maths katex-rendered">s</mi>u</mi>m</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">sum[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> is used to store the cumulative sum of <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array upto the element corresponding to the <span class="maths katex-rendered">(</mo>i</mi>−</mo>1</mn>)</mo>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(i-1)^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">i</span>−</span><span class="mord mathrm">1</span>)</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index. Thus, to determine the sum of elements for the subarray <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi>[</mo>i</mi>:</mo>j</mi>]</mo></mrow><annotation encoding="application/x-tex">nums[i:j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span>[</span><span class="mord mathit">i</span>:</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span></span></span></span></span>, we can directly use <span class="maths katex-rendered">s</mi>u</mi>m</mi>[</mo>j</mi>+</mo>1</mn>]</mo>−</mo>s</mi>u</mi>m</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">sum[j+1] - sum[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>+</span><span class="mord mathrm">1</span>]</span>−</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span>.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> subarraySum</span>(</span>int</span>[]</span> nums</span>,</span> int</span> k</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        int</span>[]</span> sum</span> =</span> new</span> int</span>[</span>nums</span>.</span>length</span> +</span> 1</span>];</span>
        sum</span>[</span>0</span>]</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> nums</span>.</span>length</span>;</span> i</span>++)</span>
            sum</span>[</span>i</span>]</span> =</span> sum</span>[</span>i</span> -</span> 1</span>]</span> +</span> nums</span>[</span>i</span> -</span> 1</span>];</span>
        for</span> (</span>int</span> start</span> =</span> 0</span>;</span> start</span> &lt;</span> nums</span>.</span>length</span>;</span> start</span>++)</span> {</span>
            for</span> (</span>int</span> end</span> =</span> start</span> +</span> 1</span>;</span> end</span> &lt;=</span> nums</span>.</span>length</span>;</span> end</span>++)</span> {</span>
                if</span> (</span>sum</span>[</span>end</span>]</span> -</span> sum</span>[</span>start</span>]</span> ==</span> k</span>)</span>
                    count</span>++;</span>
            }</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. Considering every possible subarray takes <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> time. Finding out the sum of any subarray takes <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> time after the initial processing of <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> for creating the cumulative sum array.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Cumulative sum array <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> of size <span class="maths katex-rendered">n</mi>+</mo>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span>+</span><span class="mord mathrm">1</span></span></span></span></span> is used.</p>
</li>
</ul>

<h4 id="approach-3-without-space-accepted">Approach #3 Without space [Accepted]</h4>
Algorithm</strong></p>
Instead of considering all the <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">t</span></span></span></span></span> and <span class="maths katex-rendered">e</mi>n</mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span></span> points and then finding the sum for each subarray corresponding to those points, we can directly find the sum on the go while considering different <span class="maths katex-rendered">e</mi>n</mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span></span> points. i.e. We can choose a particular <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">t</span></span></span></span></span> point and while iterating over the <span class="maths katex-rendered">e</mi>n</mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span></span> points, we can add the element corresponding to the <span class="maths katex-rendered">e</mi>n</mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span></span> point to the sum formed till now. Whenver the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> equals the required <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> value, we can update the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> value. We do so while iterating over all the <span class="maths katex-rendered">e</mi>n</mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span></span> indices possible for every <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">t</span></span></span></span></span> index. Whenver, we update the <span class="maths katex-rendered">s</mi>t</mi>a</mi>r</mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">t</span></span></span></span></span> index, we need to reset the <span class="maths katex-rendered">s</mi>u</mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span></span></span></span></span> value to 0.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> subarraySum</span>(</span>int</span>[]</span> nums</span>,</span> int</span> k</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>;</span>
        for</span> (</span>int</span> start</span> =</span> 0</span>;</span> start</span> &lt;</span> nums</span>.</span>length</span>;</span> start</span>++)</span> {</span>
            int</span> sum</span>=</span>0</span>;</span>
            for</span> (</span>int</span> end</span> =</span> start</span>;</span> end</span> &lt;</span> nums</span>.</span>length</span>;</span> end</span>++)</span> {</span>
                sum</span>+=</span>nums</span>[</span>end</span>];</span>
                if</span> (</span>sum</span> ==</span> k</span>)</span>
                    count</span>++;</span>
            }</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>2</mn></msup>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. We need to consider every subarray possible.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>. Constant space is used.</p>
</li>
</ul>

<h4 id="approach-4-using-hashmap-accepted">Approach #4 Using hashmap [Accepted]</h4>
Algorithm</strong></p>
The idea behind this approach is as follows: If the cumulative sum(repreesnted by <span class="maths katex-rendered">s</mi>u</mi>m</mi>[</mo>i</mi>]</mo></mrow><annotation encoding="application/x-tex">sum[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>[</span><span class="mord mathit">i</span>]</span></span></span></span></span> for sum upto <span class="maths katex-rendered">i</mi>t</mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">i^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">t</span><span class="mord mathit mtight">h</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> index) upto two indices is the same, the sum of the elements lying in between those indices is zero. Extending the same thought further, if the cumulative sum upto two indices, say <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> is at a difference of <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> i.e. if <span class="maths katex-rendered">s</mi>u</mi>m</mi>[</mo>i</mi>]</mo>−</mo>s</mi>u</mi>m</mi>[</mo>j</mi>]</mo>=</mo>k</mi></mrow><annotation encoding="application/x-tex">sum[i] - sum[j] = k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>[</span><span class="mord mathit">i</span>]</span>−</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>[</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span>]</span>=</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>, the sum of elements lying between indices <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> and <span class="maths katex-rendered">j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05724em;">j</span></span></span></span></span> is <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span>.</p>
Based on these thoughts, we make use of a hashmap <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> which is used to store the cumulative sum upto all the indices possible along with the number of times the same sum occurs. We store the data in the form: <span class="maths katex-rendered">(</mo>s</mi>u</mi>m</mi>i</mi></msub>,</mo>n</mi>o</mi>.</mi>o</mi>f</mi>o</mi>c</mi>c</mi>u</mi>r</mi>e</mi>n</mi>c</mi>e</mi>s</mi>o</mi>f</mi>s</mi>u</mi>m</mi>i</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">(sum_i, no. of occurences of sum_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">(</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mord mathrm">.</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">o</span><span class="mord mathit">c</span><span class="mord mathit">c</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. We traverse over the array <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> and keep on finding the cumulative sum. Every time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. If the same sum occurs again, we increment the count corresponding to that sum in the hashmap. Further, for every sum encountered, we also determine the number of times the sum <span class="maths katex-rendered">s</mi>u</mi>m</mi>−</mo>k</mi></mrow><annotation encoding="application/x-tex">sum-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span>−</span><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> has occured already, since it will determine the number of times a subarray with sum <span class="maths katex-rendered">k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03148em;">k</span></span></span></span></span> has occured upto the current index. We increment the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> by the same amount. </p>
After the complete array has been traversed, the <span class="maths katex-rendered">c</mi>o</mi>u</mi>n</mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span> gives the required result.</p>
The animation below depicts the process.</p>
<div class="diaporama" style="width: 940px; height: 529px;"><div class="initial-play play-container"><div class="fa fa-play"></div></div><canvas width="940" height="529" style="width: 940px; height: 529px;"></canvas></div><div class="control-panel" style="width: 940px;"><div class="control-group dia-back fa fa-step-backward"></div><div class="toggle-play control-group fa fa-play"></div><div class="control-group fa fa-step-forward"></div></div>1 / 9</div></div></div>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> subarraySum</span>(</span>int</span>[]</span> nums</span>,</span> int</span> k</span>)</span> {</span>
        int</span> count</span> =</span> 0</span>,</span> sum</span> =</span> 0</span>;</span>
        HashMap</span> &lt;</span> Integer</span>,</span> Integer</span> &gt;</span> map</span> =</span> new</span> HashMap</span> &lt;</span> &gt;</span> ();</span>
        map</span>.</span>put</span>(</span>0</span>,</span> 1</span>);</span>
        for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> nums</span>.</span>length</span>;</span> i</span>++)</span> {</span>
            sum</span> +=</span> nums</span>[</span>i</span>];</span>
            if</span> (</span>map</span>.</span>containsKey</span>(</span>sum</span> -</span> k</span>))</span>
                count</span> +=</span> map</span>.</span>get</span>(</span>sum</span> -</span> k</span>);</span>
            map</span>.</span>put</span>(</span>sum</span>,</span> map</span>.</span>getOrDefault</span>(</span>sum</span>,</span> 0</span>)</span> +</span> 1</span>);</span>
        }</span>
        return</span> count</span>;</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. The entire <span class="maths katex-rendered">n</mi>u</mi>m</mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span></span> array is traversed only once.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Hashmap <span class="maths katex-rendered">m</mi>a</mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span></span> can contain upto <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> distinct entries in the worst case.</p>
</li>
</ul>

Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>