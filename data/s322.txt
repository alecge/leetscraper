<div class="toc hide">

<a href="#summary">Summary</a></li>
<a href="#solution">Solution</a>
<a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute force) [Time Limit Exceeded]</a></li>
<a href="#approach-2-dynamic-programming-top-down-accepted">Approach #2 (Dynamic programming - Top down) [Accepted]</a></li>
<a href="#approach-3-dynamic-programming-bottom-up-accepted">Approach #3 (Dynamic programming - Bottom up) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Summary</h2>
This article is for intermediate users. It introduces the following ideas:
Backtracking, Dynamic programming.</p>
Solution</h2>

<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute force) [Time Limit Exceeded]</h4>
Intuition</strong></p>
The problem could be modeled as the following optimization problem :
<p class="maths katex-rendered">
min_{x} sum_{i=0}^{n - 1} x_i 
text{subject to} sum_{i=0}^{n - 1} x_i*c_i = S
</span><script type="math/tex; mode=display">
min_{x} sum_{i=0}^{n - 1} x_i 
text{subject to} sum_{i=0}^{n - 1} x_i*c_i = S
</script></p>
</p>
, where <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> is the amount,    <span class="maths katex-rendered">c</mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> is the coin denominations, <span class="maths katex-rendered">x</mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span>  is the number of coins with denominations <span class="maths katex-rendered">c</mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> used in change of amount <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span>. We could easily see that <span class="maths katex-rendered">x</mi>i</mi></msub>=</mo>[</mo>0</mn>,</mo>S</mi></mrow>c</mi>i</mi></msub></mrow></mfrac></mrow>]</mo></mrow><annotation encoding="application/x-tex">x_i = [{0, frac{S}{c_i}}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.872331em;"></span><span class="strut bottom" style="height: 1.31743em; vertical-align: -0.4451em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>=</span>[</span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span>,</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mtight"><span class="mord mathit mtight">c</span><span class="" style="top: 0.143em; margin-right: 0.0714286em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span>]</span></span></span></span></span>.</p>
A trivial solution is to enumerate all subsets of coin frequencies <span class="maths katex-rendered">([x_0dots x_{n - 1}])</span>  that satisfy the constraints above, compute their sums and return the minimum among them.</p>
Algorithm</strong></p>
To apply this idea, the algorithm uses backtracking technique to generate all combinations of coin frequencies <span class="maths katex-rendered">([x_0dots x_{n-1}])</span> in the range <script type="math/tex">[{0, frac{S}{c_i}}]</script> which satisfy the constraints above. It makes a sum of the combinations and returns their minimum or <span class="maths katex-rendered">−</mo>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped">−</span><span class="mord mathrm">1</span></span></span></span></span> in case there is no acceptable combination.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>    

    public</span> int</span> coinChange</span>(</span>int</span>[]</span> coins</span>,</span> int</span> amount</span>)</span> {</span>
        return</span> coinChange</span>(</span>0</span>,</span> coins</span>,</span> amount</span>);</span>
    }</span>

    private</span> int</span> coinChange</span>(</span>int</span> idxCoin</span>,</span> int</span>[]</span> coins</span>,</span> int</span> amount</span>)</span> {</span>
        if</span> (</span>amount</span> ==</span> 0</span>)</span>
            return</span> 0</span>;</span>
        if</span> (</span>idxCoin</span> &lt;</span> coins</span>.</span>length</span> &amp;&amp;</span> amount</span> &gt;</span> 0</span>)</span> {</span>
            int</span> maxVal</span> =</span> amount</span>/</span>coins</span>[</span>idxCoin</span>];</span>
            int</span> minCost</span> =</span> Integer</span>.</span>MAX_VALUE</span>;</span>
            for</span> (</span>int</span> x</span> =</span> 0</span>;</span> x</span> &lt;=</span> maxVal</span>;</span> x</span>++)</span> {</span>
                if</span> (</span>amount</span> &gt;=</span> x</span> *</span> coins</span>[</span>idxCoin</span>])</span> {</span>
                    int</span> res</span> =</span> coinChange</span>(</span>idxCoin</span> +</span> 1</span>,</span> coins</span>,</span> amount</span> -</span> x</span> *</span> coins</span>[</span>idxCoin</span>]);</span>
                    if</span> (</span>res</span> !=</span> -</span>1</span>)</span>
                        minCost</span> =</span> Math</span>.</span>min</span>(</span>minCost</span>,</span> res</span> +</span> x</span>);</span>
                }</span>                    
            }</span>           
            return</span> (</span>minCost</span> ==</span> Integer</span>.</span>MAX_VALUE</span>)?</span> -</span>1</span>:</span> minCost</span>;</span>
        }</span>        
        return</span> -</span>1</span>;</span>
    }</span>  
}</span>

// Time Limit Exceeded</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>n</mi></msup>)</mo></mrow><annotation encoding="application/x-tex">O(S^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span>. In the worst case, complexity is exponential in the number of the coins <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. The reason is that every coin denomination <span class="maths katex-rendered">c</mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> could have at most <span class="maths katex-rendered">S</mi></mrow>c</mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">frac{S}{c_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.872331em;"></span><span class="strut bottom" style="height: 1.31743em; vertical-align: -0.4451em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mtight"><span class="mord mathit mtight">c</span><span class="" style="top: 0.143em; margin-right: 0.0714286em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05764em;">S</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span> values. Therefore the number of possible combinations is :</li>
</ul>

<p class="maths katex-rendered">S</mi></mrow>c</mi>1</mn></msub></mrow></mfrac>∗</mo>S</mi></mrow>c</mi>2</mn></msub></mrow></mfrac>∗</mo>S</mi></mrow>c</mi>3</mn></msub></mrow></mfrac>…</mo>S</mi></mrow>c</mi>n</mi></msub></mrow></mfrac>=</mo>S</mi>n</mi></mrow></msup></mrow>c</mi>1</mn></msub></mrow>∗</mo>c</mi>2</mn></msub></mrow>∗</mo>c</mi>3</mn></msub></mrow>…</mo>c</mi>n</mi></msub></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">
frac{S}{c_1}*frac{S}{c_2}*frac{S}{c_3}ldotsfrac{S}{c_n} = frac{S^{n}}{{c_1}*{c_2}*{c_3}ldots{c_n}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.36033em;"></span><span class="strut bottom" style="height: 2.19633em; vertical-align: -0.836em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>∗</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>∗</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>…</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span>=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="" style="top: 0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span>∗</span><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span>∗</span><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span>…</span><span class="mord textstyle cramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span><span class="" style="top: -0.23em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span class="" style="top: -0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
</p>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.
In the worst case the maximum depth of recursion is <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span>. Therefore we need <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O( n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> space used by the system recursive stack.</li>
</ul>

<h4 id="approach-2-dynamic-programming-top-down-accepted">Approach #2 (Dynamic programming - Top down) [Accepted]</h4>
Intuition</strong></p>
Could we improve the exponential solution above? Definitely! The problem could be solved with polynomial time using Dynamic programming technique. First, let's define:</p>


<span class="maths katex-rendered">F</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span> - minimum number of coins needed to make change for amount <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> using coin denominations <span class="maths katex-rendered">[</mo>c</mi>0</mn></msub>…</mo>c</mi>n</mi>−</mo>1</mn></mrow></msub></mrow>]</mo></mrow><annotation encoding="application/x-tex">[{c_0ldots c_{n-1}}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped">[</span><span class="mord textstyle uncramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span>]</span></span></span></span></span>
</p>
</blockquote>
We note that this problem has an optimal substructure property, which is the key piece in solving any Dynamic Programming problems. In other words, the optimal solution can be constructed from optimal solutions of its subproblems.
How to split the problem into subproblems? Let's assume that we know <span class="maths katex-rendered">F</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span> where some change <span class="maths katex-rendered">v</mi>a</mi>l</mi>1</mn></msub>,</mo>v</mi>a</mi>l</mi>2</mn></msub>,</mo>…</mo></mrow><annotation encoding="application/x-tex">val_1, val_2, ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.01968em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: -0.01968em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span>…</span></span></span></span></span> for <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> which is optimal and the last coin's denomination is <span class="maths katex-rendered">C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">C</span></span></span></span></span>.
Then the following equation should be true because of optimal substructure of the problem:</p>

<p class="maths katex-rendered">F</mi>(</mo>S</mi>)</mo>=</mo>F</mi>(</mo>S</mi>−</mo>C</mi>)</mo>+</mo>1</mn></mrow><annotation encoding="application/x-tex">
F(S) = F(S - C) + 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span>=</span><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>−</span><span class="mord mathit" style="margin-right: 0.07153em;">C</span>)</span>+</span><span class="mord mathrm">1</span></span></span></span></span></p>
</p>
But we don't know which is the denomination of the last coin <span class="maths katex-rendered">C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.07153em;">C</span></span></span></span></span>. We compute  <span class="maths katex-rendered">F</mi>(</mo>S</mi>−</mo>c</mi>i</mi></msub>)</mo></mrow><annotation encoding="application/x-tex">F(S - c_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>−</span><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span></span></span></span> for each possible denomination <span class="maths katex-rendered">c</mi>0</mn></msub>,</mo>c</mi>1</mn></msub>,</mo>c</mi>2</mn></msub>…</mo>c</mi>n</mi>−</mo>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">c_0, c_1, c_2 ldots c_{n -1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>,</span><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>…</span><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span></span></span></span></span> and choose the minimum among them. The following recurrence relation holds:</p>

<p class="maths katex-rendered">[
F(S) = min_{i=0 ... n-1} { F(S - c_i) } + 1 
text{subject to}    S-c_i geq 0 
]</p>
</p>

<p class="maths katex-rendered">[
F(S) = 0  , text{when}  S = 0 
F(S) = -1  , text{when}  n = 0
]</p>
</p>
<img alt="Recursion tree for finding coin change of amount 6 with coin denominations {1,2,3}." src="https://leetcode.com/media/original_images/322_coin_change_tree.png" width="100%"></p>
In the recursion tree above, we could see that a lot of subproblems were calculated multiple times.  For example the problem <span class="maths katex-rendered">F</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">F(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> was calculated <span class="maths katex-rendered">1</mn>3</mn></mrow><annotation encoding="application/x-tex">13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">3</span></span></span></span></span> times. Therefore we should cache the solutions to the subproblems in a table and access them in constant time when necessary</p>
Algorithm</strong></p>
The idea of the algorithm is to build the solution of the problem from top to bottom. It applies the idea described above. It use backtracking and cut the partial solutions in the recursive tree, which doesn't lead to a viable solution. Тhis happens when we try to make a change of a coin with a value greater than the amount <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span></em>. To improve  time complexity we should store the solutions of the already calculated subproblems in a table.</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>

    public</span> int</span> coinChange</span>(</span>int</span>[]</span> coins</span>,</span> int</span> amount</span>)</span> {</span>        
        if</span> (</span>amount</span> &lt;</span> 1</span>)</span> return</span> 0</span>;</span>
        return</span> coinChange</span>(</span>coins</span>,</span> amount</span>,</span> new</span> int</span>[</span>amount</span>]);</span>
    }</span>

    private</span> int</span> coinChange</span>(</span>int</span>[]</span> coins</span>,</span> int</span> rem</span>,</span> int</span>[]</span> count</span>)</span> {</span>
        if</span> (</span>rem</span> &lt;</span> 0</span>)</span> return</span> -</span>1</span>;</span>
        if</span> (</span>rem</span> ==</span> 0</span>)</span> return</span> 0</span>;</span>
        if</span> (</span>count</span>[</span>rem</span> -</span> 1</span>]</span> !=</span> 0</span>)</span> return</span> count</span>[</span>rem</span> -</span> 1</span>];</span>
        int</span> min</span> =</span> Integer</span>.</span>MAX_VALUE</span>;</span>
        for</span> (</span>int</span> coin</span> :</span> coins</span>)</span> {</span>
            int</span> res</span> =</span> coinChange</span>(</span>coins</span>,</span> rem</span> -</span> coin</span>,</span> count</span>);</span>
            if</span> (</span>res</span> &gt;=</span> 0</span> &amp;&amp;</span> res</span> &lt;</span> min</span>)</span>
                min</span> =</span> 1</span> +</span> res</span>;</span>
        }</span>
        count</span>[</span>rem</span> -</span> 1</span>]</span> =</span> (</span>min</span> ==</span> Integer</span>.</span>MAX_VALUE</span>)</span> ?</span> -</span>1</span> :</span> min</span>;</span>
        return</span> count</span>[</span>rem</span> -</span> 1</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>. where S is the amount, n is denomination count.
In the worst case the recursive tree of the algorithm has height of <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> and the algorithm  solves only <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> subproblems because it caches precalculated solutions in a table. Each subproblem is computed with  <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> iterations, one by coin denomination. Therefore there is <span class="maths katex-rendered">O</mi>(</mo>S</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span> time complexity.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span>, where <span class="maths katex-rendered">S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> is the amount to change
We use extra space for the memoization table.</p>
</li>
</ul>

<h4 id="approach-3-dynamic-programming-bottom-up-accepted">Approach #3 (Dynamic programming - Bottom up) [Accepted]</h4>
Algorithm</strong></p>
For the iterative solution, we think in bottom-up manner. Before calculating <span class="maths katex-rendered">F</mi>(</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit">i</span>)</span></span></span></span></span></em>, we have to compute all minimum counts for amounts up to <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span>. On each iteration <span class="maths katex-rendered">i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span></span> of the algorithm <span class="maths katex-rendered">F</mi>(</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit">i</span>)</span></span></span></span></span></em> is computed as <span class="maths katex-rendered">min</mi>j</mi>=</mo>0</mn>…</mo>n</mi>−</mo>1</mn></mrow></msub>F</mi>(</mo>i</mi>−</mo>c</mi>j</mi></msub>)</mo></mrow>+</mo>1</mn></mrow><annotation encoding="application/x-tex">min_{j=0 ldots n-1}{F(i -c_j)} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="base textstyle uncramped">min</span><span class="" style="top: 0.15em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathrm mtight">0</span><span class="minner mtight">…</span><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit">i</span>−</span><span class="mord mathit">c</span><span class="" style="top: 0.15em; margin-right: 0.05em; margin-left: 0em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​</span></span>​</span></span></span></span>)</span></span>+</span><span class="mord mathrm">1</span></span></span></span></span>
</p>
<img alt="Bottom-up approach using a table to build up the solution to F6." src="https://leetcode.com/media/original_images/322_coin_change_table.png" width="539px"></p>
In the example above you can see that:</p>

<p class="maths katex-rendered">[
begin{align}
F(3) &amp;= min{{F(3- c_1), F(3-c_2), F(3-c_3)}} + 1 
&amp;= min{{F(3- 1), F(3-2), F(3-3)}} + 1 
&amp;= min{{F(2), F(1), F(0)}} + 1 
&amp;= min{{1, 1, 0}} + 1 
&amp;= 1
end{align}
]</p>
</p>
Java</strong></p>
</span>public</span> class</span> Solution</span> {</span>
    public</span> int</span> coinChange</span>(</span>int</span>[]</span> coins</span>,</span> int</span> amount</span>)</span> {</span>
        int</span> max</span> =</span> amount</span> +</span> 1</span>;</span>             
        int</span>[]</span> dp</span> =</span> new</span> int</span>[</span>amount</span> +</span> 1</span>];</span>  
        Arrays</span>.</span>fill</span>(</span>dp</span>,</span> max</span>);</span>  
        dp</span>[</span>0</span>]</span> =</span> 0</span>;</span>   
        for</span> (</span>int</span> i</span> =</span> 1</span>;</span> i</span> &lt;=</span> amount</span>;</span> i</span>++)</span> {</span>
            for</span> (</span>int</span> j</span> =</span> 0</span>;</span> j</span> &lt;</span> coins</span>.</span>length</span>;</span> j</span>++)</span> {</span>
                if</span> (</span>coins</span>[</span>j</span>]</span> &lt;=</span> i</span>)</span> {</span>
                    dp</span>[</span>i</span>]</span> =</span> Math</span>.</span>min</span>(</span>dp</span>[</span>i</span>],</span> dp</span>[</span>i</span> -</span> coins</span>[</span>j</span>]]</span> +</span> 1</span>);</span>
                }</span>
            }</span>
        }</span>
        return</span> dp</span>[</span>amount</span>]</span> &gt;</span> amount</span> ?</span> -</span>1</span> :</span> dp</span>[</span>amount</span>];</span>
    }</span>
}</span>
</pre></div>


Complexity Analysis</strong></p>

Time complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>∗</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>∗</span><span class="mord mathit">n</span>)</span></span></span></span></span>.
On each step the algorithm finds the next <span class="maths katex-rendered">F</mi>(</mo>i</mi>)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.13889em;">F</span>(</span><span class="mord mathit">i</span>)</span></span></span></span></span></em> in <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> iterations, where <span class="maths katex-rendered">1</mn>≤</mo>i</mi>≤</mo>S</mi></mrow><annotation encoding="application/x-tex">1leq i leq S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.8193em; vertical-align: -0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span>≤</span><span class="mord mathit">i</span>≤</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span>. Therefore in total the iterations are <span class="maths katex-rendered">S</mi>∗</mo>n</mi></mrow><annotation encoding="application/x-tex">S*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.05764em;">S</span>∗</span><span class="mord mathit">n</span></span></span></span></span>.</li>
Space complexity : <span class="maths katex-rendered">O</mi>(</mo>S</mi>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span>)</span></span></span></span></span>.
We use extra space for the memoization table.</li>
</ul>
Analysis written by: @elmirap.</p>