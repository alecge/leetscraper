<div class="toc hide">

<a href="#solution">Solution</a>
<a href="#approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</a></li>
<a href="#approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
Solution</h2>

<h4 id="approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</h4>
Algorithm</strong></p>
An anagram is produced by rearranging the letters of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> into <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span>. Therefore, if <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> is an anagram of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, sorting both strings will result in two identical strings. Furthermore, if <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> have different lengths, <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> must not be an anagram of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and we can return early.</p>
</span>public</span> boolean</span> isAnagram</span>(</span>String</span> s</span>,</span> String</span> t</span>)</span> {</span>
    if</span> (</span>s</span>.</span>length</span>()</span> !=</span> t</span>.</span>length</span>())</span> {</span>
        return</span> false</span>;</span>
    }</span>
    char</span>[]</span> str1</span> =</span> s</span>.</span>toCharArray</span>();</span>
    char</span>[]</span> str2</span> =</span> t</span>.</span>toCharArray</span>();</span>
    Arrays</span>.</span>sort</span>(</span>str1</span>);</span>
    Arrays</span>.</span>sort</span>(</span>str2</span>);</span>
    return</span> Arrays</span>.</span>equals</span>(</span>str1</span>,</span> str2</span>);</span>
}</span>
</pre></div>


Complexity analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span>.
Assume that <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is the length of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, sorting costs <span class="maths katex-rendered">O</mi>(</mo>n</mi>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span> and comparing two strings costs <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>. Sorting time dominates and the overall time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>log</mi>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>lo<span style="margin-right: 0.01389em;">g</span></span><span class="mord mathit">n</span>)</span></span></span></span></span>.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
Space depends on the sorting implementation which, usually, costs <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> auxiliary space if heapsort</code> is used. Note that in Java, toCharArray()</code> makes a copy of the string so it costs <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> extra space, but we ignore this for complexity analysis because:</p>

It is a language dependent detail.</li>
It depends on how the function is designed. For example, the function parameter types can be changed to char[]</code>.</li>
</ul>
</li>
</ul>

<h4 id="approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</h4>
Algorithm</strong></p>
To examine if <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> is a rearrangement of <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, we can count occurrences of each letter in the two strings and compare them. Since both <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> contain only letters from <span class="maths katex-rendered">a</mi>−</mo>z</mi></mrow><annotation encoding="application/x-tex">a-z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.58333em;"></span><span class="strut bottom" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span>−</span><span class="mord mathit" style="margin-right: 0.04398em;">z</span></span></span></span></span>, a simple counter table of size 26 is suffice.</p>
Do we need two</em> counter tables for comparison? Actually no, because we could increment the counter for each letter in <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and decrement the counter for each letter in <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span>, then check if the counter reaches back to zero.</p>
</span>public</span> boolean</span> isAnagram</span>(</span>String</span> s</span>,</span> String</span> t</span>)</span> {</span>
    if</span> (</span>s</span>.</span>length</span>()</span> !=</span> t</span>.</span>length</span>())</span> {</span>
        return</span> false</span>;</span>
    }</span>
    int</span>[]</span> counter</span> =</span> new</span> int</span>[</span>26</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> s</span>.</span>length</span>();</span> i</span>++)</span> {</span>
        counter</span>[</span>s</span>.</span>charAt</span>(</span>i</span>)</span> -</span> 'a'</span>]++;</span>
        counter</span>[</span>t</span>.</span>charAt</span>(</span>i</span>)</span> -</span> 'a'</span>]--;</span>
    }</span>
    for</span> (</span>int</span> count</span> :</span> counter</span>)</span> {</span>
        if</span> (</span>count</span> !=</span> 0</span>)</span> {</span>
            return</span> false</span>;</span>
        }</span>
    }</span>
    return</span> true</span>;</span>
}</span>
</pre></div>


Or we could first increment the counter for <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span>, then decrement the counter for <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span>. If at any point the counter drops below zero, we know that <span class="maths katex-rendered">t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.61508em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span></span> contains an extra letter not in <span class="maths katex-rendered">s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span></span> and return false immediately.</p>
</span>public</span> boolean</span> isAnagram</span>(</span>String</span> s</span>,</span> String</span> t</span>)</span> {</span>
    if</span> (</span>s</span>.</span>length</span>()</span> !=</span> t</span>.</span>length</span>())</span> {</span>
        return</span> false</span>;</span>
    }</span>
    int</span>[]</span> table</span> =</span> new</span> int</span>[</span>26</span>];</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> s</span>.</span>length</span>();</span> i</span>++)</span> {</span>
        table</span>[</span>s</span>.</span>charAt</span>(</span>i</span>)</span> -</span> 'a'</span>]++;</span>
    }</span>
    for</span> (</span>int</span> i</span> =</span> 0</span>;</span> i</span> &lt;</span> t</span>.</span>length</span>();</span> i</span>++)</span> {</span>
        table</span>[</span>t</span>.</span>charAt</span>(</span>i</span>)</span> -</span> 'a'</span>]--;</span>
        if</span> (</span>table</span>[</span>t</span>.</span>charAt</span>(</span>i</span>)</span> -</span> 'a'</span>]</span> &lt;</span> 0</span>)</span> {</span>
            return</span> false</span>;</span>
        }</span>
    }</span>
    return</span> true</span>;</span>
}</span>
</pre></div>


Complexity analysis</strong></p>


Time complexity : <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span>.
Time complexity is <span class="maths katex-rendered">O</mi>(</mo>n</mi>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathit">n</span>)</span></span></span></span></span> because accessing the counter table is a constant time operation.</p>
</li>

Space complexity : <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span>.
Although we do use extra space, the space complexity is <span class="maths katex-rendered">O</mi>(</mo>1</mn>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.02778em;">O</span>(</span><span class="mord mathrm">1</span>)</span></span></span></span></span> because the table's size stays constant no matter how large <span class="maths katex-rendered">n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span></span> is.</p>
</li>
</ul>
Follow up</strong></p>
What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
Answer</strong></p>
Use a hash table instead of a fixed size counter. Imagine allocating a large size array to fit the entire range of unicode characters, which could go up to <a href="http://stackoverflow.com/a/5928054/490463">more than 1 million</a>. A hash table is a more generic solution and could adapt to any range of characters.</p>