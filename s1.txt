<div class="toc hide">
<ul>
<li><a href="#solution">Solution</a><ul>
<li><a href="#approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</a></li>
<li><a href="#approach-2-two-pass-hash-table-accepted">Approach #2 (Two-pass Hash Table) [Accepted]</a></li>
<li><a href="#approach-3-one-pass-hash-table-accepted">Approach #3 (One-pass Hash Table) [Accepted]</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="solution">Solution</h2>
<hr>
<h4 id="approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</h4>
<p>The brute force approach is simple. Loop through each element <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;">x and find if there is another value that equals to <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">target - x</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"><span class="strut bottom" style="height: 0.80952em; vertical-align: -0.19444em;">ta<span class="mord mathit" style="margin-right: 0.02778em;">r<span class="mord mathit" style="margin-right: 0.03588em;">get−x.</p>
<div class="codehilite"><pre><span>public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i &lt; nums.length; i++) {
        for (int j = i + 1; j &lt; nums.length; j++) {
            if (nums[j] == target - nums[i]) {
                return new int[] { i, j };
            }
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
</pre></div>


<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n<span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​<span class="reset-textstyle scriptstyle uncramped mtight">2<span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​​).
For each element, we try to find its complement by looping through the rest of array which takes <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n) time. Therefore, the time complexity is <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"><span class="strut bottom" style="height: 1.06411em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n<span class="" style="top: -0.363em; margin-right: 0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​<span class="reset-textstyle scriptstyle uncramped mtight">2<span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span class="" style="font-size: 0em;">​​).</p>
</li>
<li>
<p>Space complexity : <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(1).</p>
</li>
</ul>
<hr>
<h4 id="approach-2-two-pass-hash-table-accepted">Approach #2 (Two-pass Hash Table) [Accepted]</h4>
<p>To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.</p>
<p>We reduce the look up time from <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n) to <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say "near" because if a collision occurred, a look up could degenerate to <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n) time. But look up in hash table should be amortized <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(1) time as long as the hash function was chosen carefully.</p>
<p>A simple implementation uses two iterations. In the first iteration, we add each element's value and its index to the table. Then, in the second iteration we check if each element's complement (<span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">target - nums[i]</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;">ta<span class="mord mathit" style="margin-right: 0.02778em;">r<span class="mord mathit" style="margin-right: 0.03588em;">get−nums[i]) exists in the table. Beware that the complement must not be <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;">nums[i] itself!</p>
<div class="codehilite"><pre><span>public int[] twoSum(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i &lt; nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {
            return new int[] { i, map.get(complement) };
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
</pre></div>


<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>
<p>Time complexity : <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n).
We traverse the list containing <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;">n elements exactly twice. Since the hash table reduces the look up time to <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(1), the time complexity is <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n).</p>
</li>
<li>
<p>Space complexity : <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n).
The extra space required depends on the number of items stored in the hash table, which stores exactly <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;">n elements.</p>
</li>
</ul>
<hr>
<h4 id="approach-3-one-pass-hash-table-accepted">Approach #3 (One-pass Hash Table) [Accepted]</h4>
<p>It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element's complement already exists in the table. If it exists, we have found a solution and return immediately.</p>
<div class="codehilite"><pre><span>public int[] twoSum(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
</pre></div>


<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>
<p>Time complexity : <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n).
We traverse the list containing <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;">n elements only once. Each look up in the table costs only <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(1) time.</p>
</li>
<li>
<p>Space complexity : <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"><span class="mord mathit" style="margin-right: 0.02778em;">O(n).
The extra space required depends on the number of items stored in the hash table, which stores at most <span class="maths katex-rendered"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;">n elements.</p>
</li>
</ul>